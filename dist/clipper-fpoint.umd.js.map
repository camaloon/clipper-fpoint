{"version":3,"file":"clipper-fpoint.umd.js","sources":["../src/clipper_unminified.js"],"sourcesContent":["/*******************************************************************************\n *                                                                              *\n * Author    :  Angus Johnson                                                   *\n * Version   :  6.4.2                                                           *\n * Date      :  27 February 2017                                                *\n * Website   :  http://www.angusj.com                                           *\n * Copyright :  Angus Johnson 2010-2017                                         *\n *                                                                              *\n * License:                                                                     *\n * Use, modification & distribution is subject to Boost Software License Ver 1. *\n * http://www.boost.org/LICENSE_1_0.txt                                         *\n *                                                                              *\n * Attributions:                                                                *\n * The code in this library is an extension of Bala Vatti's clipping algorithm: *\n * \"A generic solution to polygon clipping\"                                     *\n * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n * http://portal.acm.org/citation.cfm?id=129906                                 *\n *                                                                              *\n * Computer graphics and geometric modeling: implementation and algorithms      *\n * By Max K. Agoston                                                            *\n * Springer; 1 edition (January 4, 2005)                                        *\n * http://books.google.com/books?q=vatti+clipping+agoston                       *\n *                                                                              *\n * See also:                                                                    *\n * \"Polygon Offsetting by Computing Winding Numbers\"                            *\n * Paper no. DETC2005-85513 pp. 565-575                                         *\n * ASME 2005 International Design Engineering Technical Conferences             *\n * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n * September 24-28, 2005 , Long Beach, California, USA                          *\n * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Author    :  Timo                                                            *\n * Version   :  6.4.2.2 (FPoint)                                                *\n * Date      :  8 September 2017                                                *\n *                                                                              *\n * This is a translation of the C# Clipper library to Javascript.               *\n *                                                                              *\n *******************************************************************************/\n\nvar ClipperLib = {};\nClipperLib.version = '6.4.2.2';\n\n//UseLines: Enables open path clipping. Adds a very minor cost to performance.\nClipperLib.use_lines = false;\n\n//ClipperLib.use_xyz: adds a Z member to FPoint. Adds a minor cost to performance.\nClipperLib.use_xyz = false;\n// Here starts the actual Clipper library:\n// Helper function to support Inheritance in Javascript\nvar Inherit = function (ce, ce2)\n{\n  var p;\n  if (typeof (Object.getOwnPropertyNames) === 'undefined')\n  {\n    for (p in ce2.prototype)\n      if (typeof (ce.prototype[p]) === 'undefined' || ce.prototype[p] === Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];\n    for (p in ce2)\n      if (typeof (ce[p]) === 'undefined') ce[p] = ce2[p];\n    ce.$baseCtor = ce2;\n  }\n  else\n  {\n    var props = Object.getOwnPropertyNames(ce2.prototype);\n    for (var i = 0; i < props.length; i++)\n      if (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) === 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));\n    for (p in ce2)\n      if (typeof (ce[p]) === 'undefined') ce[p] = ce2[p];\n    ce.$baseCtor = ce2;\n  }\n};\n\n/**\n* @constructor\n*/\nClipperLib.Path = function ()\n{\n  return [];\n};\n\nClipperLib.Path.prototype.push = Array.prototype.push;\n\n/**\n* @constructor\n*/\nClipperLib.Paths = function ()\n{\n  return []; // Was previously [[]], but caused problems when pushed\n};\n\nClipperLib.Paths.prototype.push = Array.prototype.push;\n\n// PolyTree & PolyNode start\n/**\n* @suppress {missingProperties}\n*/\nClipperLib.PolyNode = function ()\n{\n  this.m_Parent = null;\n  this.m_polygon = new ClipperLib.Path();\n  this.m_Index = 0;\n  this.m_jointype = 0;\n  this.m_endtype = 0;\n  this.m_Childs = [];\n  this.IsOpen = false;\n};\n\nClipperLib.PolyNode.prototype.IsHoleNode = function ()\n{\n  var result = true;\n  var node = this.m_Parent;\n  while (node !== null)\n  {\n    result = !result;\n    node = node.m_Parent;\n  }\n  return result;\n};\n\nClipperLib.PolyNode.prototype.ChildCount = function ()\n{\n  return this.m_Childs.length;\n};\n\nClipperLib.PolyNode.prototype.Contour = function ()\n{\n  return this.m_polygon;\n};\n\nClipperLib.PolyNode.prototype.AddChild = function (Child)\n{\n  var cnt = this.m_Childs.length;\n  this.m_Childs.push(Child);\n  Child.m_Parent = this;\n  Child.m_Index = cnt;\n};\n\nClipperLib.PolyNode.prototype.GetNext = function ()\n{\n  if (this.m_Childs.length > 0)\n    return this.m_Childs[0];\n  else\n    return this.GetNextSiblingUp();\n};\n\nClipperLib.PolyNode.prototype.GetNextSiblingUp = function ()\n{\n  if (this.m_Parent === null)\n    return null;\n  else if (this.m_Index === this.m_Parent.m_Childs.length - 1)\n    return this.m_Parent.GetNextSiblingUp();\n  else\n    return this.m_Parent.m_Childs[this.m_Index + 1];\n};\n\nClipperLib.PolyNode.prototype.Childs = function ()\n{\n  return this.m_Childs;\n};\n\nClipperLib.PolyNode.prototype.Parent = function ()\n{\n  return this.m_Parent;\n};\n\nClipperLib.PolyNode.prototype.IsHole = function ()\n{\n  return this.IsHoleNode();\n};\n\n// PolyTree : PolyNode\n/**\n * @suppress {missingProperties}\n * @constructor\n */\nClipperLib.PolyTree = function ()\n{\n  this.m_AllPolys = [];\n  ClipperLib.PolyNode.call(this);\n};\n\nClipperLib.PolyTree.prototype.Clear = function ()\n{\n  for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)\n    this.m_AllPolys[i] = null;\n  this.m_AllPolys.length = 0;\n  this.m_Childs.length = 0;\n};\n\nClipperLib.PolyTree.prototype.GetFirst = function ()\n{\n  if (this.m_Childs.length > 0)\n    return this.m_Childs[0];\n  else\n    return null;\n};\n\nClipperLib.PolyTree.prototype.Total = function ()\n{\n  var result = this.m_AllPolys.length;\n  //with negative offsets, ignore the hidden outer polygon ...\n  if (result > 0 && this.m_Childs[0] !== this.m_AllPolys[0]) result--;\n  return result;\n};\n\nInherit(ClipperLib.PolyTree, ClipperLib.PolyNode);\n\n// PolyTree & PolyNode end\n\nClipperLib.Clear = function (a)\n{\n  a.length = 0;\n};\n\n//ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function\nClipperLib.PI = 3.141592653589793;\nClipperLib.PI2 = 2 * 3.141592653589793;\n/**\n* @constructor\n*/\nClipperLib.FPoint = function ()\n{\n  var a = arguments,\n    alen = a.length;\n  this[0] = 0;\n  this[1] = 0;\n  if (ClipperLib.use_xyz)\n  {\n    this.Z = 0;\n    if (alen === 3) // public FPoint(cInt x, cInt y, cInt z = 0)\n    {\n      this[0] = a[0];\n      this[1] = a[1];\n      this.Z = a[2];\n    }\n    else if (alen === 2) // public FPoint(cInt x, cInt y)\n    {\n      this[0] = a[0];\n      this[1] = a[1];\n      this.Z = 0;\n    }\n    else if (alen === 1)\n    {\n      if (a[0] instanceof ClipperLib.FPoint) // public FPoint(FPoint dp)\n      {\n        var dp = a[0];\n        this[0] = dp[0];\n        this[1] = dp[1];\n        this.Z = 0;\n      }\n      else // public FPoint(FPoint pt)\n      {\n        var pt = a[0];\n        if (typeof (pt.Z) === \"undefined\") pt.Z = 0;\n        this[0] = pt[0];\n        this[1] = pt[1];\n        this.Z = pt.Z;\n      }\n    }\n    else // public FPoint()\n    {\n      this[0] = 0;\n      this[1] = 0;\n      this.Z = 0;\n    }\n  }\n  else // if (!ClipperLib.use_xyz)\n  {\n    if (alen === 2) // public FPoint(cInt X, cInt Y)\n    {\n      this[0] = a[0];\n      this[1] = a[1];\n    }\n    else if (alen === 1)\n    {\n      if (a[0] instanceof ClipperLib.FPoint) // public FPoint(FPoint dp)\n      {\n        var dp = a[0];\n        this[0] = dp[0];\n        this[1] = dp[1];\n      }\n      else // public FPoint(FPoint pt)\n      {\n        var pt = a[0];\n        this[0] = pt[0];\n        this[1] = pt[1];\n      }\n    }\n    else // public FPoint(FPoint pt)\n    {\n      this[0] = 0;\n      this[1] = 0;\n    }\n  }\n};\n\nClipperLib.FPoint.op_Equality = function (a, b)\n{\n  //return a == b;\n  return a[0] === b[0] && a[1] === b[1];\n};\n\nClipperLib.FPoint.op_Inequality = function (a, b)\n{\n  //return a !== b;\n  return a[0] !== b[0] || a[1] !== b[1];\n};\n\n/*\nClipperLib.FPoint.prototype.Equals = function (obj)\n{\n  if (obj === null)\n      return false;\n  if (obj instanceof ClipperLib.FPoint)\n  {\n      var a = Cast(obj, ClipperLib.FPoint);\n      return (this[0] == a[0]) && (this[1] == a[1]);\n  }\n  else\n      return false;\n};\n\n*/\n\n/**\n* @constructor\n*/\nClipperLib.FPoint0 = function ()\n{\n  this[0] = 0;\n  this[1] = 0;\n  if (ClipperLib.use_xyz)\n    this.Z = 0;\n};\n\nClipperLib.FPoint0.prototype = ClipperLib.FPoint.prototype;\n\n/**\n* @constructor\n*/\nClipperLib.FPoint1 = function (pt)\n{\n  this[0] = pt[0];\n  this[1] = pt[1];\n  if (ClipperLib.use_xyz)\n  {\n    if (typeof pt.Z === \"undefined\") this.Z = 0;\n    else this.Z = pt.Z;\n  }\n};\n\nClipperLib.FPoint1.prototype = ClipperLib.FPoint.prototype;\n\n/**\n* @constructor\n*/\nClipperLib.FPoint1dp = function (dp)\n{\n  this[0] = dp[0];\n  this[1] = dp[1];\n  if (ClipperLib.use_xyz)\n    this.Z = 0;\n};\n\nClipperLib.FPoint1dp.prototype = ClipperLib.FPoint.prototype;\n\n/**\n* @constructor\n*/\nClipperLib.FPoint2 = function (x, y, z)\n{\n  this[0] = x;\n  this[1] = y;\n  if (ClipperLib.use_xyz)\n  {\n    if (typeof z === \"undefined\") this.Z = 0;\n    else this.Z = z;\n  }\n};\n\nClipperLib.FPoint2.prototype = ClipperLib.FPoint.prototype;\n\n/**\n* @constructor\n*/\nClipperLib.FRect = function ()\n{\n  var a = arguments,\n    alen = a.length;\n  if (alen === 4) // function (l, t, r, b)\n  {\n    this.left = a[0];\n    this.top = a[1];\n    this.right = a[2];\n    this.bottom = a[3];\n  }\n  else if (alen === 1) // function (ir)\n  {\n    var ir = a[0];\n    this.left = ir.left;\n    this.top = ir.top;\n    this.right = ir.right;\n    this.bottom = ir.bottom;\n  }\n  else // function ()\n  {\n    this.left = 0;\n    this.top = 0;\n    this.right = 0;\n    this.bottom = 0;\n  }\n};\n\n/**\n* @constructor\n*/\nClipperLib.FRect0 = function ()\n{\n  this.left = 0;\n  this.top = 0;\n  this.right = 0;\n  this.bottom = 0;\n};\n\nClipperLib.FRect0.prototype = ClipperLib.FRect.prototype;\n\n/**\n* @constructor\n*/\nClipperLib.FRect1 = function (ir)\n{\n  this.left = ir.left;\n  this.top = ir.top;\n  this.right = ir.right;\n  this.bottom = ir.bottom;\n};\n\nClipperLib.FRect1.prototype = ClipperLib.FRect.prototype;\n\n/**\n* @constructor\n*/\nClipperLib.FRect4 = function (l, t, r, b)\n{\n  this.left = l;\n  this.top = t;\n  this.right = r;\n  this.bottom = b;\n};\n\nClipperLib.FRect4.prototype = ClipperLib.FRect.prototype;\n\nClipperLib.ClipType = {\n  ctIntersection: 0,\n  ctUnion: 1,\n  ctDifference: 2,\n  ctXor: 3\n};\n\nClipperLib.PolyType = {\n  ptSubject: 0,\n  ptClip: 1\n};\n\nClipperLib.PolyFillType = {\n  pftEvenOdd: 0,\n  pftNonZero: 1,\n  pftPositive: 2,\n  pftNegative: 3\n};\n\nClipperLib.JoinType = {\n  jtSquare: 0,\n  jtRound: 1,\n  jtMiter: 2\n};\n\nClipperLib.EndType = {\n  etOpenSquare: 0,\n  etOpenRound: 1,\n  etOpenButt: 2,\n  etClosedLine: 3,\n  etClosedPolygon: 4\n};\n\nClipperLib.EdgeSide = {\n  esLeft: 0,\n  esRight: 1\n};\n\nClipperLib.Direction = {\n  dRightToLeft: 0,\n  dLeftToRight: 1\n};\n\n/**\n* @constructor\n*/\nClipperLib.TEdge = function ()\n{\n  this.Bot = new ClipperLib.FPoint0();\n  this.Curr = new ClipperLib.FPoint0(); //current (updated for every new scanbeam)\n  this.Top = new ClipperLib.FPoint0();\n  this.Delta = new ClipperLib.FPoint0();\n  this.Dx = 0;\n  this.PolyTyp = ClipperLib.PolyType.ptSubject;\n  this.Side = ClipperLib.EdgeSide.esLeft; //side only refers to current side of solution poly\n  this.WindDelta = 0; //1 or -1 depending on winding direction\n  this.WindCnt = 0;\n  this.WindCnt2 = 0; //winding count of the opposite polytype\n  this.OutIdx = 0;\n  this.Next = null;\n  this.Prev = null;\n  this.NextInLML = null;\n  this.NextInAEL = null;\n  this.PrevInAEL = null;\n  this.NextInSEL = null;\n  this.PrevInSEL = null;\n};\n\n/**\n* @constructor\n*/\nClipperLib.IntersectNode = function ()\n{\n  this.Edge1 = null;\n  this.Edge2 = null;\n  this.Pt = new ClipperLib.FPoint0();\n};\n\nClipperLib.MyIntersectNodeSort = function () {};\n\nClipperLib.MyIntersectNodeSort.Compare = function (node1, node2)\n{\n  var i = node2.Pt[1] - node1.Pt[1];\n  if (i > 0) return 1;\n  else if (i < 0) return -1;\n  else return 0;\n};\n\n/**\n* @constructor\n*/\nClipperLib.LocalMinima = function ()\n{\n  this[1] = 0;\n  this.LeftBound = null;\n  this.RightBound = null;\n  this.Next = null;\n};\n\n/**\n* @constructor\n*/\nClipperLib.Scanbeam = function ()\n{\n  this[1] = 0;\n  this.Next = null;\n};\n\n/**\n* @constructor\n*/\nClipperLib.Maxima = function ()\n{\n  this[0] = 0;\n  this.Next = null;\n  this.Prev = null;\n};\n\n//OutRec: contains a path in the clipping solution. Edges in the AEL will\n//carry a pointer to an OutRec when they are part of the clipping solution.\n/**\n* @constructor\n*/\nClipperLib.OutRec = function ()\n{\n  this.Idx = 0;\n  this.IsHole = false;\n  this.IsOpen = false;\n  this.FirstLeft = null; //see comments in clipper.pas\n  this.Pts = null;\n  this.BottomPt = null;\n  this.PolyNode = null;\n};\n\n/**\n* @constructor\n*/\nClipperLib.OutPt = function ()\n{\n  this.Idx = 0;\n  this.Pt = new ClipperLib.FPoint0();\n  this.Next = null;\n  this.Prev = null;\n};\n\n/**\n* @constructor\n*/\nClipperLib.Join = function ()\n{\n  this.OutPt1 = null;\n  this.OutPt2 = null;\n  this.OffPt = new ClipperLib.FPoint0();\n};\n\nClipperLib.ClipperBase = function ()\n{\n  this.m_MinimaList = null;\n  this.m_CurrentLM = null;\n  this.m_edges = new Array();\n  this.m_HasOpenPaths = false;\n  this.PreserveCollinear = false;\n  this.m_Scanbeam = null;\n  this.m_PolyOuts = null;\n  this.m_ActiveEdges = null;\n};\n\nClipperLib.ClipperBase.horizontal = -3.4E+38;\nClipperLib.ClipperBase.Skip = -2;\nClipperLib.ClipperBase.Unassigned = -1;\nClipperLib.ClipperBase.tolerance = 1E-20;\n\n// The MAX_VALUE property has a value of 1.7976931348623157e+308. Values larger than MAX_VALUE are represented as \"Infinity\".\n//MIN_VALUE has a value of 5e-324. Values smaller than MIN_VALUE (\"underflow values\") are converted to 0.\nClipperLib.ClipperBase.maxValue = Math.sqrt(Number.MAX_VALUE); // 1.3407807929942596e+154\nClipperLib.ClipperBase.minValue = Math.sqrt(Number.MIN_VALUE); // 2.2227587494850775e-162\n\nClipperLib.ClipperBase.near_zero = function (val)\n{\n  return (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);\n};\n\nClipperLib.ClipperBase.IsHorizontal = function (e)\n{\n  return e.Delta[1] === 0;\n};\n\nClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)\n{\n  var pp2 = pp;\n  do {\n    if (ClipperLib.FPoint.op_Equality(pp2.Pt, pt))\n      return true;\n    pp2 = pp2.Next;\n  }\n  while (pp2 !== pp)\n  return false;\n};\n\nClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2)\n{\n    return ((pt[0] === linePt1[0]) && (pt[1] === linePt1[1])) || ((pt[0] === linePt2[0]) && (pt[1] === linePt2[1])) || (((pt[0] > linePt1[0]) === (pt[0] < linePt2[0])) && ((pt[1] > linePt1[1]) === (pt[1] < linePt2[1])) && ((pt[0] - linePt1[0]) * (linePt2[1] - linePt1[1]) === (linePt2[0] - linePt1[0]) * (pt[1] - linePt1[1])));\n};\n\nClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp)\n{\n  var pp2 = pp;\n  while (true)\n  {\n    if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt))\n      return true;\n    pp2 = pp2.Next;\n    if (pp2 === pp)\n      break;\n  }\n  return false;\n};\n\nClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()\n{\n  var a = arguments,\n    alen = a.length;\n  var e1, e2, pt1, pt2, pt3, pt4;\n  if (alen === 2) // function (e1, e2)\n  {\n    e1 = a[0];\n    e2 = a[1];\n    return e1.Delta[1] * e2.Delta[0] === e1.Delta[0] * e2.Delta[1];\n  }\n  else if (alen === 3) // function (pt1, pt2, pt3)\n  {\n    pt1 = a[0];\n    pt2 = a[1];\n    pt3 = a[2];\n    return (pt1[1] - pt2[1]) * (pt2[0] - pt3[0]) - (pt1[0] - pt2[0]) * (pt2[1] - pt3[1]) === 0;\n  }\n  else // function (pt1, pt2, pt3, pt4)\n  {\n    pt1 = a[0];\n    pt2 = a[1];\n    pt3 = a[2];\n    pt4 = a[3];\n    return (pt1[1] - pt2[1]) * (pt3[0] - pt4[0]) - (pt1[0] - pt2[0]) * (pt3[1] - pt4[1]) === 0;\n  }\n};\n\nClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2)\n{\n  return e1.Delta[1] * e2.Delta[0] === e1.Delta[0] * e2.Delta[1];\n};\n\nClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3)\n{\n  return (pt1[1] - pt2[1]) * (pt2[0] - pt3[0]) - (pt1[0] - pt2[0]) * (pt2[1] - pt3[1]) === 0;\n};\n\nClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4)\n{\n  return (pt1[1] - pt2[1]) * (pt3[0] - pt4[0]) - (pt1[0] - pt2[0]) * (pt3[1] - pt4[1]) === 0;\n};\n\nClipperLib.ClipperBase.prototype.Clear = function ()\n{\n  this.DisposeLocalMinimaList();\n  for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i)\n  {\n    for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)\n      this.m_edges[i][j] = null;\n    ClipperLib.Clear(this.m_edges[i]);\n  }\n  ClipperLib.Clear(this.m_edges);\n  this.m_HasOpenPaths = false;\n};\n\nClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()\n{\n  while (this.m_MinimaList !== null)\n  {\n    var tmpLm = this.m_MinimaList.Next;\n    this.m_MinimaList = null;\n    this.m_MinimaList = tmpLm;\n  }\n  this.m_CurrentLM = null;\n};\n\nClipperLib.ClipperBase.prototype.RangeTest = function (pt)\n{\n  if(pt[0] > ClipperLib.ClipperBase.maxValue || pt[0] < -ClipperLib.ClipperBase.maxValue\n  || pt[1] > ClipperLib.ClipperBase.maxValue || pt[1] < -ClipperLib.ClipperBase.maxValue\n (pt[0] > 0 && pt[0] < ClipperLib.ClipperBase.minValue)\n (pt[1] > 0 && pt[1] < ClipperLib.ClipperBase.minValue)\n (pt[0] < 0 && pt[0] > -ClipperLib.ClipperBase.minValue)\n (pt[1] < 0 && pt[1] > -ClipperLib.ClipperBase.minValue))\n    ClipperLib.Error(\"Coordinate outside allowed range in RangeTest().\");\n};\n\nClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt)\n{\n  e.Next = eNext;\n  e.Prev = ePrev;\n  //e.Curr = pt;\n  e.Curr[0] = pt[0];\n  e.Curr[1] = pt[1];\n  if (ClipperLib.use_xyz) e.Curr.Z = pt.Z;\n  e.OutIdx = -1;\n};\n\nClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType)\n{\n  if (e.Curr[1] >= e.Next.Curr[1])\n  {\n    //e.Bot = e.Curr;\n    e.Bot[0] = e.Curr[0];\n    e.Bot[1] = e.Curr[1];\n    if (ClipperLib.use_xyz) e.Bot.Z = e.Curr.Z;\n    //e.Top = e.Next.Curr;\n    e.Top[0] = e.Next.Curr[0];\n    e.Top[1] = e.Next.Curr[1];\n    if (ClipperLib.use_xyz) e.Top.Z = e.Next.Curr.Z;\n  }\n  else\n  {\n    //e.Top = e.Curr;\n    e.Top[0] = e.Curr[0];\n    e.Top[1] = e.Curr[1];\n    if (ClipperLib.use_xyz) e.Top.Z = e.Curr.Z;\n    //e.Bot = e.Next.Curr;\n    e.Bot[0] = e.Next.Curr[0];\n    e.Bot[1] = e.Next.Curr[1];\n    if (ClipperLib.use_xyz) e.Bot.Z = e.Next.Curr.Z;\n  }\n  this.SetDx(e);\n  e.PolyTyp = polyType;\n};\n\nClipperLib.ClipperBase.prototype.FindNextLocMin = function (E)\n{\n  var E2;\n  for (;;)\n  {\n    while (ClipperLib.FPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.FPoint.op_Equality(E.Curr, E.Top))\n      E = E.Next;\n    if (E.Dx !== ClipperLib.ClipperBase.horizontal && E.Prev.Dx !== ClipperLib.ClipperBase.horizontal)\n      break;\n    while (E.Prev.Dx === ClipperLib.ClipperBase.horizontal)\n      E = E.Prev;\n    E2 = E;\n    while (E.Dx === ClipperLib.ClipperBase.horizontal)\n      E = E.Next;\n    if (E.Top[1] === E.Prev.Bot[1])\n      continue;\n    //ie just an intermediate horz.\n    if (E2.Prev.Bot[0] < E.Bot[0])\n      E = E2;\n    break;\n  }\n  return E;\n};\n\nClipperLib.ClipperBase.prototype.ProcessBound = function (E, LeftBoundIsForward)\n{\n  var EStart;\n  var Result = E;\n  var Horz;\n\n  if (Result.OutIdx === ClipperLib.ClipperBase.Skip)\n  {\n    //check if there are edges beyond the skip edge in the bound and if so\n    //create another LocMin and calling ProcessBound once more ...\n    E = Result;\n    if (LeftBoundIsForward)\n    {\n      while (E.Top[1] === E.Next.Bot[1]) E = E.Next;\n      while (E !== Result && E.Dx === ClipperLib.ClipperBase.horizontal) E = E.Prev;\n    }\n    else\n    {\n      while (E.Top[1] === E.Prev.Bot[1]) E = E.Prev;\n      while (E !== Result && E.Dx === ClipperLib.ClipperBase.horizontal) E = E.Next;\n    }\n    if (E === Result)\n    {\n      if (LeftBoundIsForward) Result = E.Next;\n      else Result = E.Prev;\n    }\n    else\n    {\n      //there are more edges in the bound beyond result starting with E\n      if (LeftBoundIsForward)\n        E = Result.Next;\n      else\n        E = Result.Prev;\n      var locMin = new ClipperLib.LocalMinima();\n      locMin.Next = null;\n      locMin[1] = E.Bot[1];\n      locMin.LeftBound = null;\n      locMin.RightBound = E;\n      E.WindDelta = 0;\n      Result = this.ProcessBound(E, LeftBoundIsForward);\n      this.InsertLocalMinima(locMin);\n    }\n    return Result;\n  }\n\n  if (E.Dx === ClipperLib.ClipperBase.horizontal)\n  {\n    //We need to be careful with open paths because this may not be a\n    //true local minima (ie E may be following a skip edge).\n    //Also, consecutive horz. edges may start heading left before going right.\n    if (LeftBoundIsForward) EStart = E.Prev;\n    else EStart = E.Next;\n\n    if (EStart.Dx === ClipperLib.ClipperBase.horizontal) //ie an adjoining horizontal skip edge\n    {\n      if (EStart.Bot[0] !== E.Bot[0] && EStart.Top[0] !== E.Bot[0])\n        this.ReverseHorizontal(E);\n    }\n    else if (EStart.Bot[0] !== E.Bot[0])\n      this.ReverseHorizontal(E);\n  }\n\n  EStart = E;\n  if (LeftBoundIsForward)\n  {\n    while (Result.Top[1] === Result.Next.Bot[1] && Result.Next.OutIdx !== ClipperLib.ClipperBase.Skip)\n      Result = Result.Next;\n    if (Result.Dx === ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx !== ClipperLib.ClipperBase.Skip)\n    {\n      //nb: at the top of a bound, horizontals are added to the bound\n      //only when the preceding edge attaches to the horizontal's left vertex\n      //unless a Skip edge is encountered when that becomes the top divide\n      Horz = Result;\n      while (Horz.Prev.Dx === ClipperLib.ClipperBase.horizontal)\n        Horz = Horz.Prev;\n      if (Horz.Prev.Top[0] > Result.Next.Top[0])\n        Result = Horz.Prev;\n    }\n    while (E !== Result)\n    {\n      E.NextInLML = E.Next;\n      if (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot[0] !== E.Prev.Top[0])\n        this.ReverseHorizontal(E);\n      E = E.Next;\n    }\n    if (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot[0] !== E.Prev.Top[0])\n      this.ReverseHorizontal(E);\n    Result = Result.Next;\n    //move to the edge just beyond current bound\n  }\n  else\n  {\n    while (Result.Top[1] === Result.Prev.Bot[1] && Result.Prev.OutIdx !== ClipperLib.ClipperBase.Skip)\n      Result = Result.Prev;\n    if (Result.Dx === ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx !== ClipperLib.ClipperBase.Skip)\n    {\n      Horz = Result;\n      while (Horz.Next.Dx === ClipperLib.ClipperBase.horizontal)\n        Horz = Horz.Next;\n      if (Horz.Next.Top[0] === Result.Prev.Top[0] || Horz.Next.Top[0] > Result.Prev.Top[0])\n      {\n        Result = Horz.Next;\n      }\n    }\n    while (E !== Result)\n    {\n      E.NextInLML = E.Prev;\n      if (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot[0] !== E.Next.Top[0])\n        this.ReverseHorizontal(E);\n      E = E.Prev;\n    }\n    if (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot[0] !== E.Next.Top[0])\n      this.ReverseHorizontal(E);\n    Result = Result.Prev;\n    //move to the edge just beyond current bound\n  }\n\n  return Result;\n};\n\nClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed)\n{\n  if (ClipperLib.use_lines)\n  {\n    if (!Closed && polyType === ClipperLib.PolyType.ptClip)\n      ClipperLib.Error(\"AddPath: Open paths must be subject.\");\n  }\n  else\n  {\n    if (!Closed)\n      ClipperLib.Error(\"AddPath: Open paths have been disabled.\");\n  }\n  var highI = pg.length - 1;\n  if (Closed)\n    while (highI > 0 && (ClipperLib.FPoint.op_Equality(pg[highI], pg[0])))\n      --highI;\n  while (highI > 0 && (ClipperLib.FPoint.op_Equality(pg[highI], pg[highI - 1])))\n    --highI;\n  if ((Closed && highI < 2) || (!Closed && highI < 1))\n    return false;\n  //create a new edge array ...\n  var edges = new Array();\n  for (var i = 0; i <= highI; i++)\n    edges.push(new ClipperLib.TEdge());\n  var IsFlat = true;\n  //1. Basic (first) edge initialization ...\n\n  //edges[1].Curr = pg[1];\n  edges[1].Curr[0] = pg[1][0];\n  edges[1].Curr[1] = pg[1][1];\n  if (ClipperLib.use_xyz) edges[1].Curr.Z = pg[1].Z;\n\n  this.RangeTest(pg[0]);\n\n  this.RangeTest(pg[highI]);\n\n  this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);\n  this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);\n  for (var i = highI - 1; i >= 1; --i)\n  {\n    this.RangeTest(pg[i]);\n\n    this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);\n  }\n\n  var eStart = edges[0];\n  //2. Remove duplicate vertices, and (when closed) collinear edges ...\n  var E = eStart,\n    eLoopStop = eStart;\n  for (;;)\n  {\n    //console.log(E.Next, eStart);\n    //nb: allows matching start and end points when not Closed ...\n    if (E.Curr === E.Next.Curr && (Closed || E.Next !== eStart))\n    {\n      if (E === E.Next)\n        break;\n      if (E === eStart)\n        eStart = E.Next;\n      E = this.RemoveEdge(E);\n      eLoopStop = E;\n      continue;\n    }\n    if (E.Prev === E.Next)\n      break;\n    else if (Closed && ClipperLib.ClipperBase.SlopesEqual4(E.Prev.Curr, E.Curr, E.Next.Curr) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr)))\n    {\n      //Collinear edges are allowed for open paths but in closed paths\n      //the default is to merge adjacent collinear edges into a single edge.\n      //However, if the PreserveCollinear property is enabled, only overlapping\n      //collinear edges (ie spikes) will be removed from closed paths.\n      if (E === eStart)\n        eStart = E.Next;\n      E = this.RemoveEdge(E);\n      E = E.Prev;\n      eLoopStop = E;\n      continue;\n    }\n    E = E.Next;\n    if ((E === eLoopStop) || (!Closed && E.Next === eStart)) break;\n  }\n  if ((!Closed && (E === E.Next)) || (Closed && (E.Prev === E.Next)))\n    return false;\n  if (!Closed)\n  {\n    this.m_HasOpenPaths = true;\n    eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n  }\n  //3. Do second stage of edge initialization ...\n  E = eStart;\n  do {\n    this.InitEdge2(E, polyType);\n    E = E.Next;\n    if (IsFlat && E.Curr[1] !== eStart.Curr[1])\n      IsFlat = false;\n  }\n  while (E !== eStart)\n  //4. Finally, add edge bounds to LocalMinima list ...\n  //Totally flat paths must be handled differently when adding them\n  //to LocalMinima list to avoid endless loops etc ...\n  if (IsFlat)\n  {\n    if (Closed)\n      return false;\n\n    E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n\n    var locMin = new ClipperLib.LocalMinima();\n    locMin.Next = null;\n    locMin[1] = E.Bot[1];\n    locMin.LeftBound = null;\n    locMin.RightBound = E;\n    locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n    locMin.RightBound.WindDelta = 0;\n\n    for (;;)\n    {\n      if (E.Bot[0] !== E.Prev.Top[0]) this.ReverseHorizontal(E);\n      if (E.Next.OutIdx === ClipperLib.ClipperBase.Skip) break;\n      E.NextInLML = E.Next;\n      E = E.Next;\n    }\n    this.InsertLocalMinima(locMin);\n    this.m_edges.push(edges);\n    return true;\n  }\n  this.m_edges.push(edges);\n  var leftBoundIsForward;\n  var EMin = null;\n\n  //workaround to avoid an endless loop in the while loop below when\n  //open paths have matching start and end points ...\n  if (ClipperLib.FPoint.op_Equality(E.Prev.Bot, E.Prev.Top))\n    E = E.Next;\n\n  for (;;)\n  {\n    E = this.FindNextLocMin(E);\n    if (E === EMin)\n      break;\n    else if (EMin === null)\n      EMin = E;\n    //E and E.Prev now share a local minima (left aligned if horizontal).\n    //Compare their slopes to find which starts which bound ...\n    var locMin = new ClipperLib.LocalMinima();\n    locMin.Next = null;\n    locMin[1] = E.Bot[1];\n    if (E.Dx < E.Prev.Dx)\n    {\n      locMin.LeftBound = E.Prev;\n      locMin.RightBound = E;\n      leftBoundIsForward = false;\n      //Q.nextInLML = Q.prev\n    }\n    else\n    {\n      locMin.LeftBound = E;\n      locMin.RightBound = E.Prev;\n      leftBoundIsForward = true;\n      //Q.nextInLML = Q.next\n    }\n    locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;\n    locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n    if (!Closed)\n      locMin.LeftBound.WindDelta = 0;\n    else if (locMin.LeftBound.Next === locMin.RightBound)\n      locMin.LeftBound.WindDelta = -1;\n    else\n      locMin.LeftBound.WindDelta = 1;\n    locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;\n    E = this.ProcessBound(locMin.LeftBound, leftBoundIsForward);\n    if (E.OutIdx === ClipperLib.ClipperBase.Skip)\n      E = this.ProcessBound(E, leftBoundIsForward);\n    var E2 = this.ProcessBound(locMin.RightBound, !leftBoundIsForward);\n    if (E2.OutIdx === ClipperLib.ClipperBase.Skip) E2 = this.ProcessBound(E2, !leftBoundIsForward);\n    if (locMin.LeftBound.OutIdx === ClipperLib.ClipperBase.Skip)\n      locMin.LeftBound = null;\n    else if (locMin.RightBound.OutIdx === ClipperLib.ClipperBase.Skip)\n      locMin.RightBound = null;\n    this.InsertLocalMinima(locMin);\n    if (!leftBoundIsForward)\n      E = E2;\n  }\n  return true;\n};\n\nClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed)\n{\n  //  console.log(\"-------------------------------------------\");\n  //  console.log(JSON.stringify(ppg));\n  var result = false;\n  for (var i = 0, ilen = ppg.length; i < ilen; ++i)\n    if (this.AddPath(ppg[i], polyType, closed))\n      result = true;\n  return result;\n};\n\nClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3)\n{\n  if ((ClipperLib.FPoint.op_Equality(pt1, pt3)) || (ClipperLib.FPoint.op_Equality(pt1, pt2)) || (ClipperLib.FPoint.op_Equality(pt3, pt2)))\n\n    //if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))\n    return false;\n\n  else if (pt1[0] !== pt3[0])\n    return (pt2[0] > pt1[0]) === (pt2[0] < pt3[0]);\n  else\n    return (pt2[1] > pt1[1]) === (pt2[1] < pt3[1]);\n};\n\nClipperLib.ClipperBase.prototype.RemoveEdge = function (e)\n{\n  //removes e from double_linked_list (but without removing from memory)\n  e.Prev.Next = e.Next;\n  e.Next.Prev = e.Prev;\n  var result = e.Next;\n  e.Prev = null; //flag as removed (see ClipperBase.Clear)\n  return result;\n};\n\nClipperLib.ClipperBase.prototype.SetDx = function (e)\n{\n  e.Delta[0] = (e.Top[0] - e.Bot[0]);\n  e.Delta[1] = (e.Top[1] - e.Bot[1]);\n  if (e.Delta[1] === 0) e.Dx = ClipperLib.ClipperBase.horizontal;\n  else e.Dx = (e.Delta[0]) / (e.Delta[1]);\n};\n\nClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)\n{\n  if (this.m_MinimaList === null)\n  {\n    this.m_MinimaList = newLm;\n  }\n  else if (newLm[1] >= this.m_MinimaList[1])\n  {\n    newLm.Next = this.m_MinimaList;\n    this.m_MinimaList = newLm;\n  }\n  else\n  {\n    var tmpLm = this.m_MinimaList;\n    while (tmpLm.Next !== null && (newLm[1] < tmpLm.Next[1]))\n      tmpLm = tmpLm.Next;\n    newLm.Next = tmpLm.Next;\n    tmpLm.Next = newLm;\n  }\n};\n\nClipperLib.ClipperBase.prototype.PopLocalMinima = function (Y, current)\n{\n  current.v = this.m_CurrentLM;\n  if (this.m_CurrentLM !== null && this.m_CurrentLM[1] === Y)\n  {\n    this.m_CurrentLM = this.m_CurrentLM.Next;\n    return true;\n  }\n  return false;\n};\n\nClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e)\n{\n  //swap horizontal edges' top and bottom x's so they follow the natural\n  //progression of the bounds - ie so their xbots will align with the\n  //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\n  var tmp = e.Top[0];\n  e.Top[0] = e.Bot[0];\n  e.Bot[0] = tmp;\n  if (ClipperLib.use_xyz)\n  {\n    tmp = e.Top.Z;\n    e.Top.Z = e.Bot.Z;\n    e.Bot.Z = tmp;\n  }\n};\n\nClipperLib.ClipperBase.prototype.Reset = function ()\n{\n  this.m_CurrentLM = this.m_MinimaList;\n  if (this.m_CurrentLM === null) //ie nothing to process\n    return;\n  //reset all edges ...\n  this.m_Scanbeam = null;\n  var lm = this.m_MinimaList;\n  while (lm !== null)\n  {\n    this.InsertScanbeam(lm[1]);\n    var e = lm.LeftBound;\n    if (e !== null)\n    {\n      //e.Curr = e.Bot;\n      e.Curr[0] = e.Bot[0];\n      e.Curr[1] = e.Bot[1];\n      if (ClipperLib.use_xyz) e.Curr.Z = e.Bot.Z;\n      e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n    }\n    e = lm.RightBound;\n    if (e !== null)\n    {\n      //e.Curr = e.Bot;\n      e.Curr[0] = e.Bot[0];\n      e.Curr[1] = e.Bot[1];\n      if (ClipperLib.use_xyz) e.Curr.Z = e.Bot.Z;\n      e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n    }\n    lm = lm.Next;\n  }\n  this.m_ActiveEdges = null;\n};\n\nClipperLib.ClipperBase.prototype.InsertScanbeam = function (Y)\n{\n  //single-linked list: sorted descending, ignoring dups.\n  if (this.m_Scanbeam === null)\n  {\n    this.m_Scanbeam = new ClipperLib.Scanbeam();\n    this.m_Scanbeam.Next = null;\n    this.m_Scanbeam[1] = Y;\n  }\n  else if (Y > this.m_Scanbeam[1])\n  {\n    var newSb = new ClipperLib.Scanbeam();\n    newSb[1] = Y;\n    newSb.Next = this.m_Scanbeam;\n    this.m_Scanbeam = newSb;\n  }\n  else\n  {\n    var sb2 = this.m_Scanbeam;\n    while (sb2.Next !== null && Y <= sb2.Next[1])\n    {\n      sb2 = sb2.Next;\n    }\n    if (Y === sb2[1])\n    {\n      return;\n    } //ie ignores duplicates\n    var newSb1 = new ClipperLib.Scanbeam();\n    newSb1[1] = Y;\n    newSb1.Next = sb2.Next;\n    sb2.Next = newSb1;\n  }\n};\n\nClipperLib.ClipperBase.prototype.PopScanbeam = function (Y)\n{\n  if (this.m_Scanbeam === null)\n  {\n    Y.v = 0;\n    return false;\n  }\n  Y.v = this.m_Scanbeam[1];\n  this.m_Scanbeam = this.m_Scanbeam.Next;\n  return true;\n};\n\nClipperLib.ClipperBase.prototype.LocalMinimaPending = function ()\n{\n  return (this.m_CurrentLM !== null);\n};\n\nClipperLib.ClipperBase.prototype.CreateOutRec = function ()\n{\n  var result = new ClipperLib.OutRec();\n  result.Idx = ClipperLib.ClipperBase.Unassigned;\n  result.IsHole = false;\n  result.IsOpen = false;\n  result.FirstLeft = null;\n  result.Pts = null;\n  result.BottomPt = null;\n  result.PolyNode = null;\n  this.m_PolyOuts.push(result);\n  result.Idx = this.m_PolyOuts.length - 1;\n  return result;\n};\n\nClipperLib.ClipperBase.prototype.DisposeOutRec = function (index)\n{\n  var outRec = this.m_PolyOuts[index];\n  outRec.Pts = null;\n  outRec = null;\n  this.m_PolyOuts[index] = null;\n};\n\nClipperLib.ClipperBase.prototype.UpdateEdgeIntoAEL = function (e)\n{\n  if (e.NextInLML === null)\n  {\n    ClipperLib.Error(\"UpdateEdgeIntoAEL: invalid call\");\n  }\n  var AelPrev = e.PrevInAEL;\n  var AelNext = e.NextInAEL;\n  e.NextInLML.OutIdx = e.OutIdx;\n  if (AelPrev !== null)\n  {\n    AelPrev.NextInAEL = e.NextInLML;\n  }\n  else\n  {\n    this.m_ActiveEdges = e.NextInLML;\n  }\n  if (AelNext !== null)\n  {\n    AelNext.PrevInAEL = e.NextInLML;\n  }\n  e.NextInLML.Side = e.Side;\n  e.NextInLML.WindDelta = e.WindDelta;\n  e.NextInLML.WindCnt = e.WindCnt;\n  e.NextInLML.WindCnt2 = e.WindCnt2;\n  e = e.NextInLML;\n  e.Curr[0] = e.Bot[0];\n  e.Curr[1] = e.Bot[1];\n  e.PrevInAEL = AelPrev;\n  e.NextInAEL = AelNext;\n  if (!ClipperLib.ClipperBase.IsHorizontal(e))\n  {\n    this.InsertScanbeam(e.Top[1]);\n  }\n  return e;\n};\n\nClipperLib.ClipperBase.prototype.SwapPositionsInAEL = function (edge1, edge2)\n{\n  //check that one or other edge hasn't already been removed from AEL ...\n  if (edge1.NextInAEL === edge1.PrevInAEL || edge2.NextInAEL === edge2.PrevInAEL)\n  {\n    return;\n  }\n\n  if (edge1.NextInAEL === edge2)\n  {\n    var next = edge2.NextInAEL;\n    if (next !== null)\n    {\n      next.PrevInAEL = edge1;\n    }\n    var prev = edge1.PrevInAEL;\n    if (prev !== null)\n    {\n      prev.NextInAEL = edge2;\n    }\n    edge2.PrevInAEL = prev;\n    edge2.NextInAEL = edge1;\n    edge1.PrevInAEL = edge2;\n    edge1.NextInAEL = next;\n  }\n  else if (edge2.NextInAEL === edge1)\n  {\n    var next1 = edge1.NextInAEL;\n    if (next1 !== null)\n    {\n      next1.PrevInAEL = edge2;\n    }\n    var prev1 = edge2.PrevInAEL;\n    if (prev1 !== null)\n    {\n      prev1.NextInAEL = edge1;\n    }\n    edge1.PrevInAEL = prev1;\n    edge1.NextInAEL = edge2;\n    edge2.PrevInAEL = edge1;\n    edge2.NextInAEL = next1;\n  }\n  else\n  {\n    var next2 = edge1.NextInAEL;\n    var prev2 = edge1.PrevInAEL;\n    edge1.NextInAEL = edge2.NextInAEL;\n    if (edge1.NextInAEL !== null)\n    {\n      edge1.NextInAEL.PrevInAEL = edge1;\n    }\n    edge1.PrevInAEL = edge2.PrevInAEL;\n    if (edge1.PrevInAEL !== null)\n    {\n      edge1.PrevInAEL.NextInAEL = edge1;\n    }\n    edge2.NextInAEL = next2;\n    if (edge2.NextInAEL !== null)\n    {\n      edge2.NextInAEL.PrevInAEL = edge2;\n    }\n    edge2.PrevInAEL = prev2;\n    if (edge2.PrevInAEL !== null)\n    {\n      edge2.PrevInAEL.NextInAEL = edge2;\n    }\n  }\n\n  if (edge1.PrevInAEL === null)\n  {\n    this.m_ActiveEdges = edge1;\n  }\n  else\n  {\n    if (edge2.PrevInAEL === null)\n    {\n      this.m_ActiveEdges = edge2;\n    }\n  }\n};\n\nClipperLib.ClipperBase.prototype.DeleteFromAEL = function (e)\n{\n  var AelPrev = e.PrevInAEL;\n  var AelNext = e.NextInAEL;\n  if (AelPrev === null && AelNext === null && e !== this.m_ActiveEdges)\n  {\n    return;\n  } //already deleted\n  if (AelPrev !== null)\n  {\n    AelPrev.NextInAEL = AelNext;\n  }\n  else\n  {\n    this.m_ActiveEdges = AelNext;\n  }\n  if (AelNext !== null)\n  {\n    AelNext.PrevInAEL = AelPrev;\n  }\n  e.NextInAEL = null;\n  e.PrevInAEL = null;\n}\n\n// public Clipper(int InitOptions = 0)\n/**\n * @suppress {missingProperties}\n */\nClipperLib.Clipper = function (InitOptions)\n{\n  if (typeof (InitOptions) === \"undefined\") InitOptions = 0;\n  this.m_PolyOuts = null;\n  this.m_ClipType = ClipperLib.ClipType.ctIntersection;\n  this.m_Scanbeam = null;\n  this.m_Maxima = null;\n  this.m_ActiveEdges = null;\n  this.m_SortedEdges = null;\n  this.m_IntersectList = null;\n  this.m_IntersectNodeComparer = null;\n  this.m_ExecuteLocked = false;\n  this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;\n  this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;\n  this.m_Joins = null;\n  this.m_GhostJoins = null;\n  this.m_UsingPolyTree = false;\n  this.ReverseSolution = false;\n  this.StrictlySimple = false;\n\n  ClipperLib.ClipperBase.call(this);\n\n  this.m_Scanbeam = null;\n  this.m_Maxima = null;\n  this.m_ActiveEdges = null;\n  this.m_SortedEdges = null;\n  this.m_IntersectList = new Array();\n  this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;\n  this.m_ExecuteLocked = false;\n  this.m_UsingPolyTree = false;\n  this.m_PolyOuts = new Array();\n  this.m_Joins = new Array();\n  this.m_GhostJoins = new Array();\n  this.ReverseSolution = (1 & InitOptions) !== 0;\n  this.StrictlySimple = (2 & InitOptions) !== 0;\n  this.PreserveCollinear = (4 & InitOptions) !== 0;\n  if (ClipperLib.use_xyz)\n  {\n    this.ZFillFunction = null; // function (FPoint bot1, FPoint top1, FPoint bot2, FPoint top2, ref FPoint intersectPt);\n  }\n};\n\nClipperLib.Clipper.ioReverseSolution = 1;\nClipperLib.Clipper.ioStrictlySimple = 2;\nClipperLib.Clipper.ioPreserveCollinear = 4;\n\nClipperLib.Clipper.prototype.Clear = function ()\n{\n  if (this.m_edges.length === 0)\n    return;\n  //avoids problems with ClipperBase destructor\n  this.DisposeAllPolyPts();\n  ClipperLib.ClipperBase.prototype.Clear.call(this);\n};\n\nClipperLib.Clipper.prototype.InsertMaxima = function (X)\n{\n  //double-linked list: sorted ascending, ignoring dups.\n  var newMax = new ClipperLib.Maxima();\n  newMax[0] = X;\n  if (this.m_Maxima === null)\n  {\n    this.m_Maxima = newMax;\n    this.m_Maxima.Next = null;\n    this.m_Maxima.Prev = null;\n  }\n  else if (X < this.m_Maxima[0])\n  {\n    newMax.Next = this.m_Maxima;\n    newMax.Prev = null;\n    this.m_Maxima = newMax;\n  }\n  else\n  {\n    var m = this.m_Maxima;\n    while (m.Next !== null && X >= m.Next[0])\n    {\n      m = m.Next;\n    }\n    if (X === m[0])\n    {\n      return;\n    } //ie ignores duplicates (& CG to clean up newMax)\n    //insert newMax between m and m.Next ...\n    newMax.Next = m.Next;\n    newMax.Prev = m;\n    if (m.Next !== null)\n    {\n      m.Next.Prev = newMax;\n    }\n    m.Next = newMax;\n  }\n};\n\n// ************************************\nClipperLib.Clipper.prototype.Execute = function ()\n{\n  var a = arguments,\n    alen = a.length,\n    ispolytree = a[1] instanceof ClipperLib.PolyTree;\n  if (alen === 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)\n  {\n    var clipType = a[0],\n      solution = a[1],\n      subjFillType = a[2],\n      clipFillType = a[3];\n    if (this.m_ExecuteLocked)\n      return false;\n    if (this.m_HasOpenPaths)\n      ClipperLib.Error(\"Error: PolyTree struct is needed for open path clipping.\");\n    this.m_ExecuteLocked = true;\n    ClipperLib.Clear(solution);\n    this.m_SubjFillType = subjFillType;\n    this.m_ClipFillType = clipFillType;\n    this.m_ClipType = clipType;\n    this.m_UsingPolyTree = false;\n    try\n    {\n      var succeeded = this.ExecuteInternal();\n      //build the return polygons ...\n      if (succeeded) this.BuildResult(solution);\n    }\n    finally\n    {\n      this.DisposeAllPolyPts();\n      this.m_ExecuteLocked = false;\n    }\n    return succeeded;\n  }\n  else if (alen === 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)\n  {\n    var clipType = a[0],\n      polytree = a[1],\n      subjFillType = a[2],\n      clipFillType = a[3];\n    if (this.m_ExecuteLocked)\n      return false;\n    this.m_ExecuteLocked = true;\n    this.m_SubjFillType = subjFillType;\n    this.m_ClipFillType = clipFillType;\n    this.m_ClipType = clipType;\n    this.m_UsingPolyTree = true;\n    try\n    {\n      var succeeded = this.ExecuteInternal();\n      //build the return polygons ...\n      if (succeeded) this.BuildResult2(polytree);\n    }\n    finally\n    {\n      this.DisposeAllPolyPts();\n      this.m_ExecuteLocked = false;\n    }\n    return succeeded;\n  }\n  else if (alen === 2 && !ispolytree) // function (clipType, solution)\n  {\n    var clipType = a[0],\n      solution = a[1];\n    return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n  }\n  else if (alen === 2 && ispolytree) // function (clipType, polytree)\n  {\n    var clipType = a[0],\n      polytree = a[1];\n    return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n  }\n};\n\nClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)\n{\n  //skip if an outermost polygon or\n  //already already points to the correct FirstLeft ...\n  if (outRec.FirstLeft === null || (outRec.IsHole !== outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))\n    return;\n  var orfl = outRec.FirstLeft;\n  while (orfl !== null && ((orfl.IsHole === outRec.IsHole) || orfl.Pts === null))\n    orfl = orfl.FirstLeft;\n  outRec.FirstLeft = orfl;\n};\n\nClipperLib.Clipper.prototype.ExecuteInternal = function ()\n{\n  try\n  {\n    this.Reset();\n    this.m_SortedEdges = null;\n    this.m_Maxima = null;\n\n    var botY = {},\n      topY = {};\n\n    if (!this.PopScanbeam(botY))\n    {\n      return false;\n    }\n    this.InsertLocalMinimaIntoAEL(botY.v);\n    while (this.PopScanbeam(topY) || this.LocalMinimaPending())\n    {\n      this.ProcessHorizontals();\n      this.m_GhostJoins.length = 0;\n      if (!this.ProcessIntersections(topY.v))\n      {\n        return false;\n      }\n      this.ProcessEdgesAtTopOfScanbeam(topY.v);\n      botY.v = topY.v;\n      this.InsertLocalMinimaIntoAEL(botY.v);\n    }\n\n    //fix orientations ...\n    var outRec, i, ilen;\n    //fix orientations ...\n    for (i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      outRec = this.m_PolyOuts[i];\n      if (outRec.Pts === null || outRec.IsOpen) continue;\n      if ((outRec.IsHole ^ this.ReverseSolution) == (this.Area$1(outRec) > 0))\n        this.ReversePolyPtLinks(outRec.Pts);\n    }\n\n    this.JoinCommonEdges();\n\n    for (i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      outRec = this.m_PolyOuts[i];\n      if (outRec.Pts === null)\n        continue;\n      else if (outRec.IsOpen)\n        this.FixupOutPolyline(outRec);\n      else\n        this.FixupOutPolygon(outRec);\n    }\n\n    if (this.StrictlySimple) this.DoSimplePolygons();\n    return true;\n  }\n  //catch { return false; }\n  finally\n  {\n    this.m_Joins.length = 0;\n    this.m_GhostJoins.length = 0;\n  }\n};\n\nClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()\n{\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)\n    this.DisposeOutRec(i);\n  ClipperLib.Clear(this.m_PolyOuts);\n};\n\nClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt)\n{\n  var j = new ClipperLib.Join();\n  j.OutPt1 = Op1;\n  j.OutPt2 = Op2;\n  //j.OffPt = OffPt;\n  j.OffPt[0] = OffPt[0];\n  j.OffPt[1] = OffPt[1];\n  if (ClipperLib.use_xyz) j.OffPt.Z = OffPt.Z;\n  this.m_Joins.push(j);\n};\n\nClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt)\n{\n  var j = new ClipperLib.Join();\n  j.OutPt1 = Op;\n  //j.OffPt = OffPt;\n  j.OffPt[0] = OffPt[0];\n  j.OffPt[1] = OffPt[1];\n  if (ClipperLib.use_xyz) j.OffPt.Z = OffPt.Z;\n  this.m_GhostJoins.push(j);\n};\n\n//if (ClipperLib.use_xyz)\n//{\nClipperLib.Clipper.prototype.SetZ = function (pt, e1, e2)\n{\n  if (this.ZFillFunction !== null)\n  {\n    if (pt.Z !== 0 || this.ZFillFunction === null) return;\n    else if (ClipperLib.FPoint.op_Equality(pt, e1.Bot)) pt.Z = e1.Bot.Z;\n    else if (ClipperLib.FPoint.op_Equality(pt, e1.Top)) pt.Z = e1.Top.Z;\n    else if (ClipperLib.FPoint.op_Equality(pt, e2.Bot)) pt.Z = e2.Bot.Z;\n    else if (ClipperLib.FPoint.op_Equality(pt, e2.Top)) pt.Z = e2.Top.Z;\n    else this.ZFillFunction(e1.Bot, e1.Top, e2.Bot, e2.Top, pt);\n  }\n};\n//}\n\nClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)\n{\n  var lm = {};\n\n  var lb;\n  var rb;\n  while (this.PopLocalMinima(botY, lm))\n  {\n    lb = lm.v.LeftBound;\n    rb = lm.v.RightBound;\n\n    var Op1 = null;\n    if (lb === null)\n    {\n      this.InsertEdgeIntoAEL(rb, null);\n      this.SetWindingCount(rb);\n      if (this.IsContributing(rb))\n        Op1 = this.AddOutPt(rb, rb.Bot);\n    }\n    else if (rb === null)\n    {\n      this.InsertEdgeIntoAEL(lb, null);\n      this.SetWindingCount(lb);\n      if (this.IsContributing(lb))\n        Op1 = this.AddOutPt(lb, lb.Bot);\n      this.InsertScanbeam(lb.Top[1]);\n    }\n    else\n    {\n      this.InsertEdgeIntoAEL(lb, null);\n      this.InsertEdgeIntoAEL(rb, lb);\n      this.SetWindingCount(lb);\n      rb.WindCnt = lb.WindCnt;\n      rb.WindCnt2 = lb.WindCnt2;\n      if (this.IsContributing(lb))\n        Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);\n      this.InsertScanbeam(lb.Top[1]);\n    }\n    if (rb !== null)\n    {\n      if (ClipperLib.ClipperBase.IsHorizontal(rb))\n      {\n        if (rb.NextInLML !== null)\n        {\n          this.InsertScanbeam(rb.NextInLML.Top[1]);\n        }\n        this.AddEdgeToSEL(rb);\n      }\n      else\n      {\n        this.InsertScanbeam(rb.Top[1]);\n      }\n    }\n    if (lb === null || rb === null) continue;\n    //if output polygons share an Edge with a horizontal rb, they'll need joining later ...\n    if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0)\n    {\n      for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++)\n      {\n        //if the horizontal Rb and a 'ghost' horizontal overlap, then convert\n        //the 'ghost' join to a real join ready for later ...\n        var j = this.m_GhostJoins[i];\n\n        if (this.HorzSegmentsOverlap(j.OutPt1.Pt[0], j.OffPt[0], rb.Bot[0], rb.Top[0]))\n          this.AddJoin(j.OutPt1, Op1, j.OffPt);\n      }\n    }\n\n    if (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&\n      lb.PrevInAEL.Curr[0] === lb.Bot[0] &&\n      lb.PrevInAEL.OutIdx >= 0 &&\n      ClipperLib.ClipperBase.SlopesEqual5(lb.PrevInAEL.Curr, lb.PrevInAEL.Top, lb.Curr, lb.Top) &&\n      lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0)\n    {\n      var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);\n      this.AddJoin(Op1, Op2, lb.Top);\n    }\n    if (lb.NextInAEL !== rb)\n    {\n      if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&\n        ClipperLib.ClipperBase.SlopesEqual5(rb.PrevInAEL.Curr, rb.PrevInAEL.Top, rb.Curr, rb.Top) &&\n        rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0)\n      {\n        var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);\n        this.AddJoin(Op1, Op2, rb.Top);\n      }\n      var e = lb.NextInAEL;\n      if (e !== null)\n        while (e !== rb)\n        {\n          //nb: For calculating winding counts etc, IntersectEdges() assumes\n          //that param1 will be to the right of param2 ABOVE the intersection ...\n          this.IntersectEdges(rb, e, lb.Curr);\n          //order important here\n          e = e.NextInAEL;\n        }\n    }\n  }\n};\n\nClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge)\n{\n  if (this.m_ActiveEdges === null)\n  {\n    edge.PrevInAEL = null;\n    edge.NextInAEL = null;\n    this.m_ActiveEdges = edge;\n  }\n  else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))\n  {\n    edge.PrevInAEL = null;\n    edge.NextInAEL = this.m_ActiveEdges;\n    this.m_ActiveEdges.PrevInAEL = edge;\n    this.m_ActiveEdges = edge;\n  }\n  else\n  {\n    if (startEdge === null)\n      startEdge = this.m_ActiveEdges;\n    while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))\n      startEdge = startEdge.NextInAEL;\n    edge.NextInAEL = startEdge.NextInAEL;\n    if (startEdge.NextInAEL !== null)\n      startEdge.NextInAEL.PrevInAEL = edge;\n    edge.PrevInAEL = startEdge;\n    startEdge.NextInAEL = edge;\n  }\n};\n\nClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)\n{\n  if (e2.Curr[0] === e1.Curr[0])\n  {\n    if (e2.Top[1] > e1.Top[1])\n      return e2.Top[0] < ClipperLib.Clipper.TopX(e1, e2.Top[1]);\n    else\n      return e1.Top[0] > ClipperLib.Clipper.TopX(e2, e1.Top[1]);\n  }\n  else\n    return e2.Curr[0] < e1.Curr[0];\n};\n\nClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)\n{\n  if (edge.PolyTyp === ClipperLib.PolyType.ptSubject)\n    return this.m_SubjFillType === ClipperLib.PolyFillType.pftEvenOdd;\n  else\n    return this.m_ClipFillType === ClipperLib.PolyFillType.pftEvenOdd;\n};\n\nClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)\n{\n  if (edge.PolyTyp === ClipperLib.PolyType.ptSubject)\n    return this.m_ClipFillType === ClipperLib.PolyFillType.pftEvenOdd;\n  else\n    return this.m_SubjFillType === ClipperLib.PolyFillType.pftEvenOdd;\n};\n\nClipperLib.Clipper.prototype.IsContributing = function (edge)\n{\n  var pft, pft2;\n  if (edge.PolyTyp === ClipperLib.PolyType.ptSubject)\n  {\n    pft = this.m_SubjFillType;\n    pft2 = this.m_ClipFillType;\n  }\n  else\n  {\n    pft = this.m_ClipFillType;\n    pft2 = this.m_SubjFillType;\n  }\n  switch (pft)\n  {\n  case ClipperLib.PolyFillType.pftEvenOdd:\n    if (edge.WindDelta === 0 && edge.WindCnt !== 1)\n      return false;\n    break;\n  case ClipperLib.PolyFillType.pftNonZero:\n    if (Math.abs(edge.WindCnt) !== 1)\n      return false;\n    break;\n  case ClipperLib.PolyFillType.pftPositive:\n    if (edge.WindCnt !== 1)\n      return false;\n    break;\n  default:\n    if (edge.WindCnt !== -1)\n      return false;\n    break;\n  }\n  switch (this.m_ClipType)\n  {\n  case ClipperLib.ClipType.ctIntersection:\n    switch (pft2)\n    {\n    case ClipperLib.PolyFillType.pftEvenOdd:\n    case ClipperLib.PolyFillType.pftNonZero:\n      return (edge.WindCnt2 !== 0);\n    case ClipperLib.PolyFillType.pftPositive:\n      return (edge.WindCnt2 > 0);\n    default:\n      return (edge.WindCnt2 < 0);\n    }\n  case ClipperLib.ClipType.ctUnion:\n    switch (pft2)\n    {\n    case ClipperLib.PolyFillType.pftEvenOdd:\n    case ClipperLib.PolyFillType.pftNonZero:\n      return (edge.WindCnt2 === 0);\n    case ClipperLib.PolyFillType.pftPositive:\n      return (edge.WindCnt2 <= 0);\n    default:\n      return (edge.WindCnt2 >= 0);\n    }\n  case ClipperLib.ClipType.ctDifference:\n    if (edge.PolyTyp === ClipperLib.PolyType.ptSubject)\n      switch (pft2)\n      {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n      case ClipperLib.PolyFillType.pftNonZero:\n        return (edge.WindCnt2 === 0);\n      case ClipperLib.PolyFillType.pftPositive:\n        return (edge.WindCnt2 <= 0);\n      default:\n        return (edge.WindCnt2 >= 0);\n      }\n    else\n      switch (pft2)\n      {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n      case ClipperLib.PolyFillType.pftNonZero:\n        return (edge.WindCnt2 !== 0);\n      case ClipperLib.PolyFillType.pftPositive:\n        return (edge.WindCnt2 > 0);\n      default:\n        return (edge.WindCnt2 < 0);\n      }\n  case ClipperLib.ClipType.ctXor:\n    if (edge.WindDelta === 0)\n      switch (pft2)\n      {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n      case ClipperLib.PolyFillType.pftNonZero:\n        return (edge.WindCnt2 === 0);\n      case ClipperLib.PolyFillType.pftPositive:\n        return (edge.WindCnt2 <= 0);\n      default:\n        return (edge.WindCnt2 >= 0);\n      }\n    else\n      return true;\n  }\n  return true;\n};\n\nClipperLib.Clipper.prototype.SetWindingCount = function (edge)\n{\n  var e = edge.PrevInAEL;\n  //find the edge of the same polytype that immediately preceeds 'edge' in AEL\n  while (e !== null && ((e.PolyTyp !== edge.PolyTyp) || (e.WindDelta === 0)))\n    e = e.PrevInAEL;\n  if (e === null)\n  {\n    var pft = (edge.PolyTyp === ClipperLib.PolyType.ptSubject ? this.m_SubjFillType : this.m_ClipFillType);\n    if (edge.WindDelta === 0)\n    {\n      edge.WindCnt = (pft === ClipperLib.PolyFillType.pftNegative ? -1 : 1);\n    }\n    else\n    {\n      edge.WindCnt = edge.WindDelta;\n    }\n    edge.WindCnt2 = 0;\n    e = this.m_ActiveEdges;\n    //ie get ready to calc WindCnt2\n  }\n  else if (edge.WindDelta === 0 && this.m_ClipType !== ClipperLib.ClipType.ctUnion)\n  {\n    edge.WindCnt = 1;\n    edge.WindCnt2 = e.WindCnt2;\n    e = e.NextInAEL;\n    //ie get ready to calc WindCnt2\n  }\n  else if (this.IsEvenOddFillType(edge))\n  {\n    //EvenOdd filling ...\n    if (edge.WindDelta === 0)\n    {\n      //are we inside a subj polygon ...\n      var Inside = true;\n      var e2 = e.PrevInAEL;\n      while (e2 !== null)\n      {\n        if (e2.PolyTyp === e.PolyTyp && e2.WindDelta !== 0)\n          Inside = !Inside;\n        e2 = e2.PrevInAEL;\n      }\n      edge.WindCnt = (Inside ? 0 : 1);\n    }\n    else\n    {\n      edge.WindCnt = edge.WindDelta;\n    }\n    edge.WindCnt2 = e.WindCnt2;\n    e = e.NextInAEL;\n    //ie get ready to calc WindCnt2\n  }\n  else\n  {\n    //nonZero, Positive or Negative filling ...\n    if (e.WindCnt * e.WindDelta < 0)\n    {\n      //prev edge is 'decreasing' WindCount (WC) toward zero\n      //so we're outside the previous polygon ...\n      if (Math.abs(e.WindCnt) > 1)\n      {\n        //outside prev poly but still inside another.\n        //when reversing direction of prev poly use the same WC\n        if (e.WindDelta * edge.WindDelta < 0)\n          edge.WindCnt = e.WindCnt;\n        else\n          edge.WindCnt = e.WindCnt + edge.WindDelta;\n      }\n      else\n        edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n    }\n    else\n    {\n      //prev edge is 'increasing' WindCount (WC) away from zero\n      //so we're inside the previous polygon ...\n      if (edge.WindDelta === 0)\n        edge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);\n      else if (e.WindDelta * edge.WindDelta < 0)\n        edge.WindCnt = e.WindCnt;\n      else\n        edge.WindCnt = e.WindCnt + edge.WindDelta;\n    }\n    edge.WindCnt2 = e.WindCnt2;\n    e = e.NextInAEL;\n    //ie get ready to calc WindCnt2\n  }\n  //update WindCnt2 ...\n  if (this.IsEvenOddAltFillType(edge))\n  {\n    //EvenOdd filling ...\n    while (e !== edge)\n    {\n      if (e.WindDelta !== 0)\n        edge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);\n      e = e.NextInAEL;\n    }\n  }\n  else\n  {\n    //nonZero, Positive or Negative filling ...\n    while (e !== edge)\n    {\n      edge.WindCnt2 += e.WindDelta;\n      e = e.NextInAEL;\n    }\n  }\n};\n\nClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)\n{\n  //SEL pointers in PEdge are use to build transient lists of horizontal edges.\n  //However, since we don't need to worry about processing order, all additions\n  //are made to the front of the list ...\n  if (this.m_SortedEdges === null)\n  {\n    this.m_SortedEdges = edge;\n    edge.PrevInSEL = null;\n    edge.NextInSEL = null;\n  }\n  else\n  {\n    edge.NextInSEL = this.m_SortedEdges;\n    edge.PrevInSEL = null;\n    this.m_SortedEdges.PrevInSEL = edge;\n    this.m_SortedEdges = edge;\n  }\n};\n\nClipperLib.Clipper.prototype.PopEdgeFromSEL = function (e)\n{\n  //Pop edge from front of SEL (ie SEL is a FILO list)\n  e.v = this.m_SortedEdges;\n  if (e.v === null)\n  {\n    return false;\n  }\n  var oldE = e.v;\n  this.m_SortedEdges = e.v.NextInSEL;\n  if (this.m_SortedEdges !== null)\n  {\n    this.m_SortedEdges.PrevInSEL = null;\n  }\n  oldE.NextInSEL = null;\n  oldE.PrevInSEL = null;\n  return true;\n};\n\nClipperLib.Clipper.prototype.CopyAELToSEL = function ()\n{\n  var e = this.m_ActiveEdges;\n  this.m_SortedEdges = e;\n  while (e !== null)\n  {\n    e.PrevInSEL = e.PrevInAEL;\n    e.NextInSEL = e.NextInAEL;\n    e = e.NextInAEL;\n  }\n};\n\nClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)\n{\n  if (edge1.NextInSEL === null && edge1.PrevInSEL === null)\n    return;\n  if (edge2.NextInSEL === null && edge2.PrevInSEL === null)\n    return;\n  if (edge1.NextInSEL === edge2)\n  {\n    var next = edge2.NextInSEL;\n    if (next !== null)\n      next.PrevInSEL = edge1;\n    var prev = edge1.PrevInSEL;\n    if (prev !== null)\n      prev.NextInSEL = edge2;\n    edge2.PrevInSEL = prev;\n    edge2.NextInSEL = edge1;\n    edge1.PrevInSEL = edge2;\n    edge1.NextInSEL = next;\n  }\n  else if (edge2.NextInSEL === edge1)\n  {\n    var next = edge1.NextInSEL;\n    if (next !== null)\n      next.PrevInSEL = edge2;\n    var prev = edge2.PrevInSEL;\n    if (prev !== null)\n      prev.NextInSEL = edge1;\n    edge1.PrevInSEL = prev;\n    edge1.NextInSEL = edge2;\n    edge2.PrevInSEL = edge1;\n    edge2.NextInSEL = next;\n  }\n  else\n  {\n    var next = edge1.NextInSEL;\n    var prev = edge1.PrevInSEL;\n    edge1.NextInSEL = edge2.NextInSEL;\n    if (edge1.NextInSEL !== null)\n      edge1.NextInSEL.PrevInSEL = edge1;\n    edge1.PrevInSEL = edge2.PrevInSEL;\n    if (edge1.PrevInSEL !== null)\n      edge1.PrevInSEL.NextInSEL = edge1;\n    edge2.NextInSEL = next;\n    if (edge2.NextInSEL !== null)\n      edge2.NextInSEL.PrevInSEL = edge2;\n    edge2.PrevInSEL = prev;\n    if (edge2.PrevInSEL !== null)\n      edge2.PrevInSEL.NextInSEL = edge2;\n  }\n  if (edge1.PrevInSEL === null)\n    this.m_SortedEdges = edge1;\n  else if (edge2.PrevInSEL === null)\n    this.m_SortedEdges = edge2;\n};\n\nClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)\n{\n  this.AddOutPt(e1, pt);\n  if (e2.WindDelta === 0) this.AddOutPt(e2, pt);\n  if (e1.OutIdx === e2.OutIdx)\n  {\n    e1.OutIdx = -1;\n    e2.OutIdx = -1;\n  }\n  else if (e1.OutIdx < e2.OutIdx)\n    this.AppendPolygon(e1, e2);\n  else\n    this.AppendPolygon(e2, e1);\n};\n\nClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)\n{\n  var result;\n  var e, prevE;\n  if (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx))\n  {\n    result = this.AddOutPt(e1, pt);\n    e2.OutIdx = e1.OutIdx;\n    e1.Side = ClipperLib.EdgeSide.esLeft;\n    e2.Side = ClipperLib.EdgeSide.esRight;\n    e = e1;\n    if (e.PrevInAEL === e2)\n      prevE = e2.PrevInAEL;\n    else\n      prevE = e.PrevInAEL;\n  }\n  else\n  {\n    result = this.AddOutPt(e2, pt);\n    e1.OutIdx = e2.OutIdx;\n    e1.Side = ClipperLib.EdgeSide.esRight;\n    e2.Side = ClipperLib.EdgeSide.esLeft;\n    e = e2;\n    if (e.PrevInAEL === e1)\n      prevE = e1.PrevInAEL;\n    else\n      prevE = e.PrevInAEL;\n  }\n\n  if (prevE !== null && prevE.OutIdx >= 0 && prevE.Top[1] < pt[1] && e.Top[1] < pt[1])\n  {\n    var xPrev = ClipperLib.Clipper.TopX(prevE, pt[1]);\n    var xE = ClipperLib.Clipper.TopX(e, pt[1]);\n    if ((xPrev === xE) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0) && ClipperLib.ClipperBase.SlopesEqual5(new ClipperLib.FPoint2(xPrev, pt[1]), prevE.Top, new ClipperLib.FPoint2(xE, pt[1]), e.Top))\n    {\n      var outPt = this.AddOutPt(prevE, pt);\n      this.AddJoin(result, outPt, e.Top);\n    }\n  }\n  return result;\n};\n\nClipperLib.Clipper.prototype.AddOutPt = function (e, pt)\n{\n  if (e.OutIdx < 0)\n  {\n    var outRec = this.CreateOutRec();\n    outRec.IsOpen = (e.WindDelta === 0);\n    var newOp = new ClipperLib.OutPt();\n    outRec.Pts = newOp;\n    newOp.Idx = outRec.Idx;\n    //newOp.Pt = pt;\n    newOp.Pt[0] = pt[0];\n    newOp.Pt[1] = pt[1];\n    if (ClipperLib.use_xyz) newOp.Pt.Z = pt.Z;\n    newOp.Next = newOp;\n    newOp.Prev = newOp;\n    if (!outRec.IsOpen)\n      this.SetHoleState(e, outRec);\n    e.OutIdx = outRec.Idx;\n    //nb: do this after SetZ !\n    return newOp;\n  }\n  else\n  {\n    var outRec = this.m_PolyOuts[e.OutIdx];\n    //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\n    var op = outRec.Pts;\n    var ToFront = (e.Side === ClipperLib.EdgeSide.esLeft);\n    if (ToFront && ClipperLib.FPoint.op_Equality(pt, op.Pt))\n      return op;\n    else if (!ToFront && ClipperLib.FPoint.op_Equality(pt, op.Prev.Pt))\n      return op.Prev;\n    var newOp = new ClipperLib.OutPt();\n    newOp.Idx = outRec.Idx;\n    //newOp.Pt = pt;\n    newOp.Pt[0] = pt[0];\n    newOp.Pt[1] = pt[1];\n    if (ClipperLib.use_xyz) newOp.Pt.Z = pt.Z;\n    newOp.Next = op;\n    newOp.Prev = op.Prev;\n    newOp.Prev.Next = newOp;\n    op.Prev = newOp;\n    if (ToFront)\n      outRec.Pts = newOp;\n    return newOp;\n  }\n};\n\nClipperLib.Clipper.prototype.GetLastOutPt = function (e)\n{\n  var outRec = this.m_PolyOuts[e.OutIdx];\n  if (e.Side === ClipperLib.EdgeSide.esLeft)\n  {\n    return outRec.Pts;\n  }\n  else\n  {\n    return outRec.Pts.Prev;\n  }\n};\n\nClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)\n{\n  var tmp = new ClipperLib.FPoint1(pt1.Value);\n  //pt1.Value = pt2.Value;\n  pt1.Value[0] = pt2.Value[0];\n  pt1.Value[1] = pt2.Value[1];\n  if (ClipperLib.use_xyz) pt1.Value.Z = pt2.Value.Z;\n  //pt2.Value = tmp;\n  pt2.Value[0] = tmp[0];\n  pt2.Value[1] = tmp[1];\n  if (ClipperLib.use_xyz) pt2.Value.Z = tmp.Z;\n};\n\nClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (seg1a, seg1b, seg2a, seg2b)\n{\n  var tmp;\n  if (seg1a > seg1b)\n  {\n    tmp = seg1a;\n    seg1a = seg1b;\n    seg1b = tmp;\n  }\n  if (seg2a > seg2b)\n  {\n    tmp = seg2a;\n    seg2a = seg2b;\n    seg2b = tmp;\n  }\n  return (seg1a < seg2b) && (seg2a < seg1b);\n}\n\nClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)\n{\n  var e2 = e.PrevInAEL;\n  var eTmp = null;\n  while (e2 !== null)\n  {\n    if (e2.OutIdx >= 0 && e2.WindDelta !== 0)\n    {\n      if (eTmp === null)\n        eTmp = e2;\n      else if (eTmp.OutIdx === e2.OutIdx)\n        eTmp = null; //paired\n    }\n    e2 = e2.PrevInAEL;\n  }\n\n  if (eTmp === null)\n  {\n    outRec.FirstLeft = null;\n    outRec.IsHole = false;\n  }\n  else\n  {\n    outRec.FirstLeft = this.m_PolyOuts[eTmp.OutIdx];\n    outRec.IsHole = !outRec.FirstLeft.IsHole;\n  }\n};\n\nClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)\n{\n  if (pt1[1] === pt2[1])\n    return ClipperLib.ClipperBase.horizontal;\n  else\n    return (pt2[0] - pt1[0]) / (pt2[1] - pt1[1]);\n};\n\nClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)\n{\n  var p = btmPt1.Prev;\n  while ((ClipperLib.FPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p !== btmPt1))\n    p = p.Prev;\n  var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n  p = btmPt1.Next;\n  while ((ClipperLib.FPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p !== btmPt1))\n    p = p.Next;\n  var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n  p = btmPt2.Prev;\n  while ((ClipperLib.FPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p !== btmPt2))\n    p = p.Prev;\n  var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n  p = btmPt2.Next;\n  while ((ClipperLib.FPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p !== btmPt2))\n    p = p.Next;\n  var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n\n  if (Math.max(dx1p, dx1n) === Math.max(dx2p, dx2n) && Math.min(dx1p, dx1n) === Math.min(dx2p, dx2n))\n  {\n    return this.Area(btmPt1) > 0; //if otherwise identical use orientation\n  }\n  else\n  {\n    return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);\n  }\n};\n\nClipperLib.Clipper.prototype.GetBottomPt = function (pp)\n{\n  var dups = null;\n  var p = pp.Next;\n  while (p !== pp)\n  {\n    if (p.Pt[1] > pp.Pt[1])\n    {\n      pp = p;\n      dups = null;\n    }\n    else if (p.Pt[1] === pp.Pt[1] && p.Pt[0] <= pp.Pt[0])\n    {\n      if (p.Pt[0] < pp.Pt[0])\n      {\n        dups = null;\n        pp = p;\n      }\n      else\n      {\n        if (p.Next !== pp && p.Prev !== pp)\n          dups = p;\n      }\n    }\n    p = p.Next;\n  }\n  if (dups !== null)\n  {\n    //there appears to be at least 2 vertices at bottomPt so ...\n    while (dups !== p)\n    {\n      if (!this.FirstIsBottomPt(p, dups))\n        pp = dups;\n      dups = dups.Next;\n      while (ClipperLib.FPoint.op_Inequality(dups.Pt, pp.Pt))\n        dups = dups.Next;\n    }\n  }\n  return pp;\n};\n\nClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)\n{\n  //work out which polygon fragment has the correct hole state ...\n  if (outRec1.BottomPt === null)\n    outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);\n  if (outRec2.BottomPt === null)\n    outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);\n  var bPt1 = outRec1.BottomPt;\n  var bPt2 = outRec2.BottomPt;\n  if (bPt1.Pt[1] > bPt2.Pt[1])\n    return outRec1;\n  else if (bPt1.Pt[1] < bPt2.Pt[1])\n    return outRec2;\n  else if (bPt1.Pt[0] < bPt2.Pt[0])\n    return outRec1;\n  else if (bPt1.Pt[0] > bPt2.Pt[0])\n    return outRec2;\n  else if (bPt1.Next === bPt1)\n    return outRec2;\n  else if (bPt2.Next === bPt2)\n    return outRec1;\n  else if (this.FirstIsBottomPt(bPt1, bPt2))\n    return outRec1;\n  else\n    return outRec2;\n};\n\nClipperLib.Clipper.prototype.OutRec1RightOfOutRec2 = function (outRec1, outRec2)\n{\n  do {\n    outRec1 = outRec1.FirstLeft;\n    if (outRec1 === outRec2)\n      return true;\n  }\n  while (outRec1 !== null)\n  return false;\n};\n\nClipperLib.Clipper.prototype.GetOutRec = function (idx)\n{\n  var outrec = this.m_PolyOuts[idx];\n  while (outrec !== this.m_PolyOuts[outrec.Idx])\n    outrec = this.m_PolyOuts[outrec.Idx];\n  return outrec;\n};\n\nClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)\n{\n  //get the start and ends of both output polygons ...\n  var outRec1 = this.m_PolyOuts[e1.OutIdx];\n  var outRec2 = this.m_PolyOuts[e2.OutIdx];\n  var holeStateRec;\n  if (this.OutRec1RightOfOutRec2(outRec1, outRec2))\n    holeStateRec = outRec2;\n  else if (this.OutRec1RightOfOutRec2(outRec2, outRec1))\n    holeStateRec = outRec1;\n  else\n    holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\n  //get the start and ends of both output polygons and\n  //join E2 poly onto E1 poly and delete pointers to E2 ...\n\n  var p1_lft = outRec1.Pts;\n  var p1_rt = p1_lft.Prev;\n  var p2_lft = outRec2.Pts;\n  var p2_rt = p2_lft.Prev;\n  //join e2 poly onto e1 poly and delete pointers to e2 ...\n  if (e1.Side === ClipperLib.EdgeSide.esLeft)\n  {\n    if (e2.Side === ClipperLib.EdgeSide.esLeft)\n    {\n      //z y x a b c\n      this.ReversePolyPtLinks(p2_lft);\n      p2_lft.Next = p1_lft;\n      p1_lft.Prev = p2_lft;\n      p1_rt.Next = p2_rt;\n      p2_rt.Prev = p1_rt;\n      outRec1.Pts = p2_rt;\n    }\n    else\n    {\n      //x y z a b c\n      p2_rt.Next = p1_lft;\n      p1_lft.Prev = p2_rt;\n      p2_lft.Prev = p1_rt;\n      p1_rt.Next = p2_lft;\n      outRec1.Pts = p2_lft;\n    }\n  }\n  else\n  {\n    if (e2.Side === ClipperLib.EdgeSide.esRight)\n    {\n      //a b c z y x\n      this.ReversePolyPtLinks(p2_lft);\n      p1_rt.Next = p2_rt;\n      p2_rt.Prev = p1_rt;\n      p2_lft.Next = p1_lft;\n      p1_lft.Prev = p2_lft;\n    }\n    else\n    {\n      //a b c x y z\n      p1_rt.Next = p2_lft;\n      p2_lft.Prev = p1_rt;\n      p1_lft.Prev = p2_rt;\n      p2_rt.Next = p1_lft;\n    }\n  }\n  outRec1.BottomPt = null;\n  if (holeStateRec === outRec2)\n  {\n    if (outRec2.FirstLeft !== outRec1)\n      outRec1.FirstLeft = outRec2.FirstLeft;\n    outRec1.IsHole = outRec2.IsHole;\n  }\n  outRec2.Pts = null;\n  outRec2.BottomPt = null;\n  outRec2.FirstLeft = outRec1;\n  var OKIdx = e1.OutIdx;\n  var ObsoleteIdx = e2.OutIdx;\n  e1.OutIdx = -1;\n  //nb: safe because we only get here via AddLocalMaxPoly\n  e2.OutIdx = -1;\n  var e = this.m_ActiveEdges;\n  while (e !== null)\n  {\n    if (e.OutIdx === ObsoleteIdx)\n    {\n      e.OutIdx = OKIdx;\n      e.Side = e1.Side;\n      break;\n    }\n    e = e.NextInAEL;\n  }\n  outRec2.Idx = outRec1.Idx;\n};\n\nClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)\n{\n  if (pp === null)\n    return;\n  var pp1;\n  var pp2;\n  pp1 = pp;\n  do {\n    pp2 = pp1.Next;\n    pp1.Next = pp1.Prev;\n    pp1.Prev = pp2;\n    pp1 = pp2;\n  }\n  while (pp1 !== pp)\n};\n\nClipperLib.Clipper.SwapSides = function (edge1, edge2)\n{\n  var side = edge1.Side;\n  edge1.Side = edge2.Side;\n  edge2.Side = side;\n};\n\nClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)\n{\n  var outIdx = edge1.OutIdx;\n  edge1.OutIdx = edge2.OutIdx;\n  edge2.OutIdx = outIdx;\n};\n\nClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt)\n{\n  //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before\n  //e2 in AEL except when e1 is being inserted at the intersection point ...\n  var e1Contributing = (e1.OutIdx >= 0);\n  var e2Contributing = (e2.OutIdx >= 0);\n\n  if (ClipperLib.use_xyz)\n    this.SetZ(pt, e1, e2);\n\n  if (ClipperLib.use_lines)\n  {\n    //if either edge is on an OPEN path ...\n    if (e1.WindDelta === 0 || e2.WindDelta === 0)\n    {\n      //ignore subject-subject open path intersections UNLESS they\n      //are both open paths, AND they are both 'contributing maximas' ...\n      if (e1.WindDelta === 0 && e2.WindDelta === 0) return;\n      //if intersecting a subj line with a subj poly ...\n      else if (e1.PolyTyp === e2.PolyTyp &&\n        e1.WindDelta !== e2.WindDelta && this.m_ClipType === ClipperLib.ClipType.ctUnion)\n      {\n        if (e1.WindDelta === 0)\n        {\n          if (e2Contributing)\n          {\n            this.AddOutPt(e1, pt);\n            if (e1Contributing)\n              e1.OutIdx = -1;\n          }\n        }\n        else\n        {\n          if (e1Contributing)\n          {\n            this.AddOutPt(e2, pt);\n            if (e2Contributing)\n              e2.OutIdx = -1;\n          }\n        }\n      }\n      else if (e1.PolyTyp !== e2.PolyTyp)\n      {\n        if ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) === 1 &&\n          (this.m_ClipType !== ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0))\n        {\n          this.AddOutPt(e1, pt);\n          if (e1Contributing)\n            e1.OutIdx = -1;\n        }\n        else if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) === 1) &&\n          (this.m_ClipType !== ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0))\n        {\n          this.AddOutPt(e2, pt);\n          if (e2Contributing)\n            e2.OutIdx = -1;\n        }\n      }\n      return;\n    }\n  }\n  //update winding counts...\n  //assumes that e1 will be to the Right of e2 ABOVE the intersection\n  if (e1.PolyTyp === e2.PolyTyp)\n  {\n    if (this.IsEvenOddFillType(e1))\n    {\n      var oldE1WindCnt = e1.WindCnt;\n      e1.WindCnt = e2.WindCnt;\n      e2.WindCnt = oldE1WindCnt;\n    }\n    else\n    {\n      if (e1.WindCnt + e2.WindDelta === 0)\n        e1.WindCnt = -e1.WindCnt;\n      else\n        e1.WindCnt += e2.WindDelta;\n      if (e2.WindCnt - e1.WindDelta === 0)\n        e2.WindCnt = -e2.WindCnt;\n      else\n        e2.WindCnt -= e1.WindDelta;\n    }\n  }\n  else\n  {\n    if (!this.IsEvenOddFillType(e2))\n      e1.WindCnt2 += e2.WindDelta;\n    else\n      e1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;\n    if (!this.IsEvenOddFillType(e1))\n      e2.WindCnt2 -= e1.WindDelta;\n    else\n      e2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;\n  }\n  var e1FillType, e2FillType, e1FillType2, e2FillType2;\n  if (e1.PolyTyp === ClipperLib.PolyType.ptSubject)\n  {\n    e1FillType = this.m_SubjFillType;\n    e1FillType2 = this.m_ClipFillType;\n  }\n  else\n  {\n    e1FillType = this.m_ClipFillType;\n    e1FillType2 = this.m_SubjFillType;\n  }\n  if (e2.PolyTyp === ClipperLib.PolyType.ptSubject)\n  {\n    e2FillType = this.m_SubjFillType;\n    e2FillType2 = this.m_ClipFillType;\n  }\n  else\n  {\n    e2FillType = this.m_ClipFillType;\n    e2FillType2 = this.m_SubjFillType;\n  }\n  var e1Wc, e2Wc;\n  switch (e1FillType)\n  {\n  case ClipperLib.PolyFillType.pftPositive:\n    e1Wc = e1.WindCnt;\n    break;\n  case ClipperLib.PolyFillType.pftNegative:\n    e1Wc = -e1.WindCnt;\n    break;\n  default:\n    e1Wc = Math.abs(e1.WindCnt);\n    break;\n  }\n  switch (e2FillType)\n  {\n  case ClipperLib.PolyFillType.pftPositive:\n    e2Wc = e2.WindCnt;\n    break;\n  case ClipperLib.PolyFillType.pftNegative:\n    e2Wc = -e2.WindCnt;\n    break;\n  default:\n    e2Wc = Math.abs(e2.WindCnt);\n    break;\n  }\n  if (e1Contributing && e2Contributing)\n  {\n    if ((e1Wc !== 0 && e1Wc !== 1) || (e2Wc !== 0 && e2Wc !== 1) ||\n      (e1.PolyTyp !== e2.PolyTyp && this.m_ClipType !== ClipperLib.ClipType.ctXor))\n    {\n      this.AddLocalMaxPoly(e1, e2, pt);\n    }\n    else\n    {\n      this.AddOutPt(e1, pt);\n      this.AddOutPt(e2, pt);\n      ClipperLib.Clipper.SwapSides(e1, e2);\n      ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n    }\n  }\n  else if (e1Contributing)\n  {\n    if (e2Wc === 0 || e2Wc === 1)\n    {\n      this.AddOutPt(e1, pt);\n      ClipperLib.Clipper.SwapSides(e1, e2);\n      ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n    }\n  }\n  else if (e2Contributing)\n  {\n    if (e1Wc === 0 || e1Wc === 1)\n    {\n      this.AddOutPt(e2, pt);\n      ClipperLib.Clipper.SwapSides(e1, e2);\n      ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n    }\n  }\n  else if ((e1Wc === 0 || e1Wc === 1) && (e2Wc === 0 || e2Wc === 1))\n  {\n    //neither edge is currently contributing ...\n    var e1Wc2, e2Wc2;\n    switch (e1FillType2)\n    {\n    case ClipperLib.PolyFillType.pftPositive:\n      e1Wc2 = e1.WindCnt2;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e1Wc2 = -e1.WindCnt2;\n      break;\n    default:\n      e1Wc2 = Math.abs(e1.WindCnt2);\n      break;\n    }\n    switch (e2FillType2)\n    {\n    case ClipperLib.PolyFillType.pftPositive:\n      e2Wc2 = e2.WindCnt2;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e2Wc2 = -e2.WindCnt2;\n      break;\n    default:\n      e2Wc2 = Math.abs(e2.WindCnt2);\n      break;\n    }\n    if (e1.PolyTyp !== e2.PolyTyp)\n    {\n      this.AddLocalMinPoly(e1, e2, pt);\n    }\n    else if (e1Wc === 1 && e2Wc === 1)\n      switch (this.m_ClipType)\n      {\n      case ClipperLib.ClipType.ctIntersection:\n        if (e1Wc2 > 0 && e2Wc2 > 0)\n          this.AddLocalMinPoly(e1, e2, pt);\n        break;\n      case ClipperLib.ClipType.ctUnion:\n        if (e1Wc2 <= 0 && e2Wc2 <= 0)\n          this.AddLocalMinPoly(e1, e2, pt);\n        break;\n      case ClipperLib.ClipType.ctDifference:\n        if (((e1.PolyTyp === ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\n          ((e1.PolyTyp === ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))\n          this.AddLocalMinPoly(e1, e2, pt);\n        break;\n      case ClipperLib.ClipType.ctXor:\n        this.AddLocalMinPoly(e1, e2, pt);\n        break;\n      }\n    else\n      ClipperLib.Clipper.SwapSides(e1, e2);\n  }\n};\n\nClipperLib.Clipper.prototype.DeleteFromSEL = function (e)\n{\n  var SelPrev = e.PrevInSEL;\n  var SelNext = e.NextInSEL;\n  if (SelPrev === null && SelNext === null && (e !== this.m_SortedEdges))\n    return;\n  //already deleted\n  if (SelPrev !== null)\n    SelPrev.NextInSEL = SelNext;\n  else\n    this.m_SortedEdges = SelNext;\n  if (SelNext !== null)\n    SelNext.PrevInSEL = SelPrev;\n  e.NextInSEL = null;\n  e.PrevInSEL = null;\n};\n\nClipperLib.Clipper.prototype.ProcessHorizontals = function ()\n{\n  var horzEdge = {}; //m_SortedEdges;\n  while (this.PopEdgeFromSEL(horzEdge))\n  {\n    this.ProcessHorizontal(horzEdge.v);\n  }\n};\n\nClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var)\n{\n  if (HorzEdge.Bot[0] < HorzEdge.Top[0])\n  {\n    $var.Left = HorzEdge.Bot[0];\n    $var.Right = HorzEdge.Top[0];\n    $var.Dir = ClipperLib.Direction.dLeftToRight;\n  }\n  else\n  {\n    $var.Left = HorzEdge.Top[0];\n    $var.Right = HorzEdge.Bot[0];\n    $var.Dir = ClipperLib.Direction.dRightToLeft;\n  }\n};\n\nClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge)\n{\n  var $var = {\n    Dir: null,\n    Left: null,\n    Right: null\n  };\n\n  this.GetHorzDirection(horzEdge, $var);\n  var dir = $var.Dir;\n  var horzLeft = $var.Left;\n  var horzRight = $var.Right;\n\n  var IsOpen = horzEdge.WindDelta === 0;\n\n  var eLastHorz = horzEdge,\n    eMaxPair = null;\n  while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))\n    eLastHorz = eLastHorz.NextInLML;\n  if (eLastHorz.NextInLML === null)\n    eMaxPair = this.GetMaximaPair(eLastHorz);\n\n  var currMax = this.m_Maxima;\n  if (currMax !== null)\n  {\n    //get the first maxima in range (X) ...\n    if (dir === ClipperLib.Direction.dLeftToRight)\n    {\n      while (currMax !== null && currMax[0] <= horzEdge.Bot[0])\n      {\n        currMax = currMax.Next;\n      }\n      if (currMax !== null && currMax[0] >= eLastHorz.Top[0])\n      {\n        currMax = null;\n      }\n    }\n    else\n    {\n      while (currMax.Next !== null && currMax.Next[0] < horzEdge.Bot[0])\n      {\n        currMax = currMax.Next;\n      }\n      if (currMax[0] <= eLastHorz.Top[0])\n      {\n        currMax = null;\n      }\n    }\n  }\n  var op1 = null;\n  for (;;) //loop through consec. horizontal edges\n  {\n    var IsLastHorz = (horzEdge === eLastHorz);\n    var e = this.GetNextInAEL(horzEdge, dir);\n    while (e !== null)\n    {\n      //this code block inserts extra coords into horizontal edges (in output\n      //polygons) whereever maxima touch these horizontal edges. This helps\n      //'simplifying' polygons (ie if the Simplify property is set).\n      if (currMax !== null)\n      {\n        if (dir === ClipperLib.Direction.dLeftToRight)\n        {\n          while (currMax !== null && currMax[0] < e.Curr[0])\n          {\n            if (horzEdge.OutIdx >= 0 && !IsOpen)\n            {\n              this.AddOutPt(horzEdge, new ClipperLib.FPoint2(currMax[0], horzEdge.Bot[1]));\n            }\n            currMax = currMax.Next;\n          }\n        }\n        else\n        {\n          while (currMax !== null && currMax[0] > e.Curr[0])\n          {\n            if (horzEdge.OutIdx >= 0 && !IsOpen)\n            {\n              this.AddOutPt(horzEdge, new ClipperLib.FPoint2(currMax[0], horzEdge.Bot[1]));\n            }\n            currMax = currMax.Prev;\n          }\n        }\n      }\n\n      if ((dir === ClipperLib.Direction.dLeftToRight && e.Curr[0] > horzRight) || (dir === ClipperLib.Direction.dRightToLeft && e.Curr[0] < horzLeft))\n      {\n        break;\n      }\n\n      //Also break if we've got to the end of an intermediate horizontal edge ...\n      //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\n      if (e.Curr[0] === horzEdge.Top[0] && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)\n        break;\n\n      if (horzEdge.OutIdx >= 0 && !IsOpen) //note: may be done multiple times\n      {\n        if (ClipperLib.use_xyz)\n        {\n          if (dir === ClipperLib.Direction.dLeftToRight)\n            this.SetZ(e.Curr, horzEdge, e);\n          else this.SetZ(e.Curr, e, horzEdge);\n        }\n\n        op1 = this.AddOutPt(horzEdge, e.Curr);\n        var eNextHorz = this.m_SortedEdges;\n        while (eNextHorz !== null)\n        {\n          if (eNextHorz.OutIdx >= 0 && this.HorzSegmentsOverlap(horzEdge.Bot[0], horzEdge.Top[0], eNextHorz.Bot[0], eNextHorz.Top[0]))\n          {\n            var op2 = this.GetLastOutPt(eNextHorz);\n            this.AddJoin(op2, op1, eNextHorz.Top);\n          }\n          eNextHorz = eNextHorz.NextInSEL;\n        }\n        this.AddGhostJoin(op1, horzEdge.Bot);\n      }\n\n      //OK, so far we're still in range of the horizontal Edge  but make sure\n      //we're at the last of consec. horizontals when matching with eMaxPair\n      if (e === eMaxPair && IsLastHorz)\n      {\n        if (horzEdge.OutIdx >= 0)\n        {\n          this.AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.Top);\n        }\n        this.DeleteFromAEL(horzEdge);\n        this.DeleteFromAEL(eMaxPair);\n        return;\n      }\n\n      if (dir === ClipperLib.Direction.dLeftToRight)\n      {\n        var Pt = new ClipperLib.FPoint2(e.Curr[0], horzEdge.Curr[1]);\n        this.IntersectEdges(horzEdge, e, Pt);\n      }\n      else\n      {\n        var Pt = new ClipperLib.FPoint2(e.Curr[0], horzEdge.Curr[1]);\n        this.IntersectEdges(e, horzEdge, Pt);\n      }\n      var eNext = this.GetNextInAEL(e, dir);\n      this.SwapPositionsInAEL(horzEdge, e);\n      e = eNext;\n    } //end while(e !== null)\n\n    //Break out of loop if HorzEdge.NextInLML is not also horizontal ...\n    if (horzEdge.NextInLML === null || !ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML))\n    {\n      break;\n    }\n\n    horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n    if (horzEdge.OutIdx >= 0)\n    {\n      this.AddOutPt(horzEdge, horzEdge.Bot);\n    }\n\n    $var = {\n      Dir: dir,\n      Left: horzLeft,\n      Right: horzRight\n    };\n\n    this.GetHorzDirection(horzEdge, $var);\n    dir = $var.Dir;\n    horzLeft = $var.Left;\n    horzRight = $var.Right;\n\n  } //end for (;;)\n\n  if (horzEdge.OutIdx >= 0 && op1 === null)\n  {\n    op1 = this.GetLastOutPt(horzEdge);\n    var eNextHorz = this.m_SortedEdges;\n    while (eNextHorz !== null)\n    {\n      if (eNextHorz.OutIdx >= 0 && this.HorzSegmentsOverlap(horzEdge.Bot[0], horzEdge.Top[0], eNextHorz.Bot[0], eNextHorz.Top[0]))\n      {\n        var op2 = this.GetLastOutPt(eNextHorz);\n        this.AddJoin(op2, op1, eNextHorz.Top);\n      }\n      eNextHorz = eNextHorz.NextInSEL;\n    }\n    this.AddGhostJoin(op1, horzEdge.Top);\n  }\n\n  if (horzEdge.NextInLML !== null)\n  {\n    if (horzEdge.OutIdx >= 0)\n    {\n      op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\n      horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n      if (horzEdge.WindDelta === 0)\n      {\n        return;\n      }\n      //nb: HorzEdge is no longer horizontal here\n      var ePrev = horzEdge.PrevInAEL;\n      var eNext = horzEdge.NextInAEL;\n      if (ePrev !== null && ePrev.Curr[0] === horzEdge.Bot[0] && ePrev.Curr[1] === horzEdge.Bot[1] && ePrev.WindDelta === 0 && (ePrev.OutIdx >= 0 && ePrev.Curr[1] > ePrev.Top[1] && ClipperLib.ClipperBase.SlopesEqual3(horzEdge, ePrev)))\n      {\n        var op2 = this.AddOutPt(ePrev, horzEdge.Bot);\n        this.AddJoin(op1, op2, horzEdge.Top);\n      }\n      else if (eNext !== null && eNext.Curr[0] === horzEdge.Bot[0] && eNext.Curr[1] === horzEdge.Bot[1] && eNext.WindDelta !== 0 && eNext.OutIdx >= 0 && eNext.Curr[1] > eNext.Top[1] && ClipperLib.ClipperBase.SlopesEqual3(horzEdge, eNext))\n      {\n        var op2 = this.AddOutPt(eNext, horzEdge.Bot);\n        this.AddJoin(op1, op2, horzEdge.Top);\n      }\n    }\n    else\n    {\n      horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n    }\n  }\n  else\n  {\n    if (horzEdge.OutIdx >= 0)\n    {\n      this.AddOutPt(horzEdge, horzEdge.Top);\n    }\n    this.DeleteFromAEL(horzEdge);\n  }\n};\n\nClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)\n{\n  return Direction === ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;\n};\n\nClipperLib.Clipper.prototype.IsMinima = function (e)\n{\n  return e !== null && (e.Prev.NextInLML !== e) && (e.Next.NextInLML !== e);\n};\n\nClipperLib.Clipper.prototype.IsMaxima = function (e, Y)\n{\n  return (e !== null && e.Top[1] === Y && e.NextInLML === null);\n};\n\nClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)\n{\n  return (e.Top[1] === Y && e.NextInLML !== null);\n};\n\nClipperLib.Clipper.prototype.GetMaximaPair = function (e)\n{\n  if ((ClipperLib.FPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null)\n  {\n    return e.Next;\n  }\n  else\n  {\n    if ((ClipperLib.FPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null)\n    {\n      return e.Prev;\n    }\n    else\n    {\n      return null;\n    }\n  }\n};\n\nClipperLib.Clipper.prototype.GetMaximaPairEx = function (e)\n{\n  //as above but returns null if MaxPair isn't in AEL (unless it's horizontal)\n  var result = this.GetMaximaPair(e);\n  if (result === null || result.OutIdx === ClipperLib.ClipperBase.Skip ||\n    ((result.NextInAEL === result.PrevInAEL) && !ClipperLib.ClipperBase.IsHorizontal(result)))\n  {\n    return null;\n  }\n  return result;\n};\n\nClipperLib.Clipper.prototype.ProcessIntersections = function (topY)\n{\n  if (this.m_ActiveEdges === null)\n    return true;\n  try\n  {\n    this.BuildIntersectList(topY);\n    if (this.m_IntersectList.length === 0)\n      return true;\n    if (this.m_IntersectList.length === 1 || this.FixupIntersectionOrder())\n      this.ProcessIntersectList();\n    else\n      return false;\n  }\n  catch ($$e2)\n  {\n    this.m_SortedEdges = null;\n    this.m_IntersectList.length = 0;\n    ClipperLib.Error(\"ProcessIntersections error\");\n  }\n  this.m_SortedEdges = null;\n  return true;\n};\n\nClipperLib.Clipper.prototype.BuildIntersectList = function (topY)\n{\n  if (this.m_ActiveEdges === null)\n    return;\n  //prepare for sorting ...\n  var e = this.m_ActiveEdges;\n  //console.log(JSON.stringify(JSON.decycle( e )));\n  this.m_SortedEdges = e;\n  while (e !== null)\n  {\n    e.PrevInSEL = e.PrevInAEL;\n    e.NextInSEL = e.NextInAEL;\n    e.Curr[0] = ClipperLib.Clipper.TopX(e, topY);\n    e = e.NextInAEL;\n  }\n  //bubblesort ...\n  var isModified = true;\n  while (isModified && this.m_SortedEdges !== null)\n  {\n    isModified = false;\n    e = this.m_SortedEdges;\n    while (e.NextInSEL !== null)\n    {\n      var eNext = e.NextInSEL;\n      var pt = new ClipperLib.FPoint0();\n      //console.log(\"e.Curr[0]: \" + e.Curr[0] + \" eNext.Curr[0]\" + eNext.Curr[0]);\n      if (e.Curr[0] > eNext.Curr[0])\n      {\n        this.IntersectPoint(e, eNext, pt);\n        if (pt[1] < topY)\n        {\n          pt = new ClipperLib.FPoint2(ClipperLib.Clipper.TopX(e, topY), topY);\n        }\n        var newNode = new ClipperLib.IntersectNode();\n        newNode.Edge1 = e;\n        newNode.Edge2 = eNext;\n        //newNode.Pt = pt;\n        newNode.Pt[0] = pt[0];\n        newNode.Pt[1] = pt[1];\n        if (ClipperLib.use_xyz) newNode.Pt.Z = pt.Z;\n        this.m_IntersectList.push(newNode);\n        this.SwapPositionsInSEL(e, eNext);\n        isModified = true;\n      }\n      else\n        e = eNext;\n    }\n    if (e.PrevInSEL !== null)\n      e.PrevInSEL.NextInSEL = null;\n    else\n      break;\n  }\n  this.m_SortedEdges = null;\n};\n\nClipperLib.Clipper.prototype.EdgesAdjacent = function (inode)\n{\n  return (inode.Edge1.NextInSEL === inode.Edge2) || (inode.Edge1.PrevInSEL === inode.Edge2);\n};\n\nClipperLib.Clipper.IntersectNodeSort = function (node1, node2)\n{\n  //the following typecast is safe because the differences in Pt[1] will\n  //be limited to the height of the scanbeam.\n  return (node2.Pt[1] - node1.Pt[1]);\n};\n\nClipperLib.Clipper.prototype.FixupIntersectionOrder = function ()\n{\n  //pre-condition: intersections are sorted bottom-most first.\n  //Now it's crucial that intersections are made only between adjacent edges,\n  //so to ensure this the order of intersections may need adjusting ...\n  this.m_IntersectList.sort(this.m_IntersectNodeComparer);\n  this.CopyAELToSEL();\n  var cnt = this.m_IntersectList.length;\n  for (var i = 0; i < cnt; i++)\n  {\n    if (!this.EdgesAdjacent(this.m_IntersectList[i]))\n    {\n      var j = i + 1;\n      while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))\n        j++;\n      if (j === cnt)\n        return false;\n      var tmp = this.m_IntersectList[i];\n      this.m_IntersectList[i] = this.m_IntersectList[j];\n      this.m_IntersectList[j] = tmp;\n    }\n    this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);\n  }\n  return true;\n};\n\nClipperLib.Clipper.prototype.ProcessIntersectList = function ()\n{\n  for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++)\n  {\n    var iNode = this.m_IntersectList[i];\n    this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt);\n    this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);\n  }\n  this.m_IntersectList.length = 0;\n};\n\nClipperLib.Clipper.TopX = function (edge, currentY)\n{\n  //if (edge.Bot == edge.Curr) alert (\"edge.Bot = edge.Curr\");\n  //if (edge.Bot == edge.Top) alert (\"edge.Bot = edge.Top\");\n  if (currentY === edge.Top[1])\n    return edge.Top[0];\n  return edge.Bot[0] + edge.Dx * (currentY - edge.Bot[1]);\n};\n\nClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)\n{\n  ip[0] = 0;\n  ip[1] = 0;\n  var b1, b2;\n  //nb: with very large coordinate values, it's possible for SlopesEqual() to\n  //return false but for the edge.Dx value be equal due to double precision rounding.\n  if (edge1.Dx === edge2.Dx)\n  {\n    ip[1] = edge1.Curr[1];\n    ip[0] = ClipperLib.Clipper.TopX(edge1, ip[1]);\n    return;\n  }\n  if (edge1.Delta[0] === 0)\n  {\n    ip[0] = edge1.Bot[0];\n    if (ClipperLib.ClipperBase.IsHorizontal(edge2))\n    {\n      ip[1] = edge2.Bot[1];\n    }\n    else\n    {\n      b2 = edge2.Bot[1] - (edge2.Bot[0] / edge2.Dx);\n      ip[1] = ip[0] / edge2.Dx + b2;\n    }\n  }\n  else if (edge2.Delta[0] === 0)\n  {\n    ip[0] = edge2.Bot[0];\n    if (ClipperLib.ClipperBase.IsHorizontal(edge1))\n    {\n      ip[1] = edge1.Bot[1];\n    }\n    else\n    {\n      b1 = edge1.Bot[1] - (edge1.Bot[0] / edge1.Dx);\n      ip[1] = ip[0] / edge1.Dx + b1;\n    }\n  }\n  else\n  {\n    b1 = edge1.Bot[0] - edge1.Bot[1] * edge1.Dx;\n    b2 = edge2.Bot[0] - edge2.Bot[1] * edge2.Dx;\n    var q = (b2 - b1) / (edge1.Dx - edge2.Dx);\n    ip[1] = q;\n    if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n      ip[0] = edge1.Dx * q + b1;\n    else\n      ip[0] = edge2.Dx * q + b2;\n  }\n  if (ip[1] < edge1.Top[1] || ip[1] < edge2.Top[1])\n  {\n    if (edge1.Top[1] > edge2.Top[1])\n    {\n      ip[1] = edge1.Top[1];\n      ip[0] = ClipperLib.Clipper.TopX(edge2, edge1.Top[1]);\n      return ip[0] < edge1.Top[0];\n    }\n    else\n      ip[1] = edge2.Top[1];\n    if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n      ip[0] = ClipperLib.Clipper.TopX(edge1, ip[1]);\n    else\n      ip[0] = ClipperLib.Clipper.TopX(edge2, ip[1]);\n  }\n  //finally, don't allow 'ip' to be BELOW curr[1] (ie bottom of scanbeam) ...\n  if (ip[1] > edge1.Curr[1])\n  {\n    ip[1] = edge1.Curr[1];\n    //better to use the more vertical edge to derive X ...\n    if (Math.abs(edge1.Dx) > Math.abs(edge2.Dx))\n      ip[0] = ClipperLib.Clipper.TopX(edge2, ip[1]);\n    else\n      ip[0] = ClipperLib.Clipper.TopX(edge1, ip[1]);\n  }\n};\n\nClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)\n{\n  var e = this.m_ActiveEdges;\n\n  while (e !== null)\n  {\n    //1. process maxima, treating them as if they're 'bent' horizontal edges,\n    //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\n    var IsMaximaEdge = this.IsMaxima(e, topY);\n    if (IsMaximaEdge)\n    {\n      var eMaxPair = this.GetMaximaPairEx(e);\n      IsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));\n    }\n    if (IsMaximaEdge)\n    {\n      if (this.StrictlySimple)\n      {\n        this.InsertMaxima(e.Top[0]);\n      }\n      var ePrev = e.PrevInAEL;\n      this.DoMaxima(e);\n      if (ePrev === null)\n        e = this.m_ActiveEdges;\n      else\n        e = ePrev.NextInAEL;\n    }\n    else\n    {\n      //2. promote horizontal edges, otherwise update Curr[0] and Curr[1] ...\n      if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML))\n      {\n        e = this.UpdateEdgeIntoAEL(e);\n        if (e.OutIdx >= 0)\n          this.AddOutPt(e, e.Bot);\n        this.AddEdgeToSEL(e);\n      }\n      else\n      {\n        e.Curr[0] = ClipperLib.Clipper.TopX(e, topY);\n        e.Curr[1] = topY;\n      }\n\n      if (ClipperLib.use_xyz)\n      {\n        if (e.Top[1] === topY) e.Curr.Z = e.Top.Z;\n        else if (e.Bot[1] === topY) e.Curr.Z = e.Bot.Z;\n        else e.Curr.Z = 0;\n      }\n\n      //When StrictlySimple and 'e' is being touched by another edge, then\n      //make sure both edges have a vertex here ...\n      if (this.StrictlySimple)\n      {\n        var ePrev = e.PrevInAEL;\n        if ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&\n          (ePrev.OutIdx >= 0) && (ePrev.Curr[0] === e.Curr[0]) &&\n          (ePrev.WindDelta !== 0))\n        {\n          var ip = new ClipperLib.FPoint1(e.Curr);\n\n          if (ClipperLib.use_xyz)\n          {\n            this.SetZ(ip, ePrev, e);\n          }\n\n          var op = this.AddOutPt(ePrev, ip);\n          var op2 = this.AddOutPt(e, ip);\n          this.AddJoin(op, op2, ip); //StrictlySimple (type-3) join\n        }\n      }\n      e = e.NextInAEL;\n    }\n  }\n  //3. Process horizontals at the Top of the scanbeam ...\n  this.ProcessHorizontals();\n  this.m_Maxima = null;\n  //4. Promote intermediate vertices ...\n  e = this.m_ActiveEdges;\n  while (e !== null)\n  {\n    if (this.IsIntermediate(e, topY))\n    {\n      var op = null;\n      if (e.OutIdx >= 0)\n        op = this.AddOutPt(e, e.Top);\n      e = this.UpdateEdgeIntoAEL(e);\n      //if output polygons share an edge, they'll need joining later ...\n      var ePrev = e.PrevInAEL;\n      var eNext = e.NextInAEL;\n\n      if (ePrev !== null && ePrev.Curr[0] === e.Bot[0] && ePrev.Curr[1] === e.Bot[1] && op !== null && ePrev.OutIdx >= 0 && ePrev.Curr[1] === ePrev.Top[1] && ClipperLib.ClipperBase.SlopesEqual5(e.Curr, e.Top, ePrev.Curr, ePrev.Top) && (e.WindDelta !== 0) && (ePrev.WindDelta !== 0))\n      {\n        var op2 = this.AddOutPt(ePrev2, e.Bot);\n        this.AddJoin(op, op2, e.Top);\n      }\n      else if (eNext !== null && eNext.Curr[0] === e.Bot[0] && eNext.Curr[1] === e.Bot[1] && op !== null && eNext.OutIdx >= 0 && eNext.Curr[1] === eNext.Top[1] && ClipperLib.ClipperBase.SlopesEqual5(e.Curr, e.Top, eNext.Curr, eNext.Top) && (e.WindDelta !== 0) && (eNext.WindDelta !== 0))\n      {\n        var op2 = this.AddOutPt(eNext, e.Bot);\n        this.AddJoin(op, op2, e.Top);\n      }\n    }\n    e = e.NextInAEL;\n  }\n};\n\nClipperLib.Clipper.prototype.DoMaxima = function (e)\n{\n  var eMaxPair = this.GetMaximaPairEx(e);\n  if (eMaxPair === null)\n  {\n    if (e.OutIdx >= 0)\n      this.AddOutPt(e, e.Top);\n    this.DeleteFromAEL(e);\n    return;\n  }\n  var eNext = e.NextInAEL;\n  while (eNext !== null && eNext !== eMaxPair)\n  {\n    this.IntersectEdges(e, eNext, e.Top);\n    this.SwapPositionsInAEL(e, eNext);\n    eNext = e.NextInAEL;\n  }\n  if (e.OutIdx === -1 && eMaxPair.OutIdx === -1)\n  {\n    this.DeleteFromAEL(e);\n    this.DeleteFromAEL(eMaxPair);\n  }\n  else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0)\n  {\n    if (e.OutIdx >= 0) this.AddLocalMaxPoly(e, eMaxPair, e.Top);\n    this.DeleteFromAEL(e);\n    this.DeleteFromAEL(eMaxPair);\n  }\n  else if (ClipperLib.use_lines && e.WindDelta === 0)\n  {\n    if (e.OutIdx >= 0)\n    {\n      this.AddOutPt(e, e.Top);\n      e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n    }\n    this.DeleteFromAEL(e);\n    if (eMaxPair.OutIdx >= 0)\n    {\n      this.AddOutPt(eMaxPair, e.Top);\n      eMaxPair.OutIdx = ClipperLib.ClipperBase.Unassigned;\n    }\n    this.DeleteFromAEL(eMaxPair);\n  }\n  else\n    ClipperLib.Error(\"DoMaxima error\");\n};\n\nClipperLib.Clipper.ReversePaths = function (polys)\n{\n  for (var i = 0, len = polys.length; i < len; i++)\n    polys[i].reverse();\n};\n\nClipperLib.Clipper.Orientation = function (poly)\n{\n  return ClipperLib.Clipper.Area(poly) >= 0;\n};\n\nClipperLib.Clipper.prototype.PointCount = function (pts)\n{\n  if (pts === null)\n    return 0;\n  var result = 0;\n  var p = pts;\n  do {\n    result++;\n    p = p.Next;\n  }\n  while (p !== pts)\n  return result;\n};\n\nClipperLib.Clipper.prototype.BuildResult = function (polyg)\n{\n  ClipperLib.Clear(polyg);\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n  {\n    var outRec = this.m_PolyOuts[i];\n    if (outRec.Pts === null)\n      continue;\n    var p = outRec.Pts.Prev;\n    var cnt = this.PointCount(p);\n    if (cnt < 2)\n      continue;\n    var pg = new Array(cnt);\n    for (var j = 0; j < cnt; j++)\n    {\n      pg[j] = p.Pt;\n      p = p.Prev;\n    }\n    polyg.push(pg);\n  }\n};\n\nClipperLib.Clipper.prototype.BuildResult2 = function (polytree)\n{\n  polytree.Clear();\n  //add each output polygon/contour to polytree ...\n  //polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n  {\n    var outRec = this.m_PolyOuts[i];\n    var cnt = this.PointCount(outRec.Pts);\n    if ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))\n      continue;\n    this.FixHoleLinkage(outRec);\n    var pn = new ClipperLib.PolyNode();\n    polytree.m_AllPolys.push(pn);\n    outRec.PolyNode = pn;\n    pn.m_polygon.length = cnt;\n    var op = outRec.Pts.Prev;\n    for (var j = 0; j < cnt; j++)\n    {\n      pn.m_polygon[j] = op.Pt;\n      op = op.Prev;\n    }\n  }\n  //fixup PolyNode links etc ...\n  //polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n  {\n    var outRec = this.m_PolyOuts[i];\n    if (outRec.PolyNode === null)\n      continue;\n    else if (outRec.IsOpen)\n    {\n      outRec.PolyNode.IsOpen = true;\n      polytree.AddChild(outRec.PolyNode);\n    }\n    else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode !== null)\n      outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);\n    else\n      polytree.AddChild(outRec.PolyNode);\n  }\n};\n\nClipperLib.Clipper.prototype.FixupOutPolyline = function (outRec)\n{\n  var pp = outRec.Pts;\n  var lastPP = pp.Prev;\n  while (pp !== lastPP)\n  {\n    pp = pp.Next;\n    if (ClipperLib.FPoint.op_Equality(pp.Pt, pp.Prev.Pt))\n    {\n      if (pp === lastPP)\n      {\n        lastPP = pp.Prev;\n      }\n      var tmpPP = pp.Prev;\n      tmpPP.Next = pp.Next;\n      pp.Next.Prev = tmpPP;\n      pp = tmpPP;\n    }\n  }\n  if (pp === pp.Prev)\n  {\n    outRec.Pts = null;\n  }\n};\n\nClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)\n{\n  //FixupOutPolygon() - removes duplicate points and simplifies consecutive\n  //parallel edges by removing the middle vertex.\n  var lastOK = null;\n  outRec.BottomPt = null;\n  var pp = outRec.Pts;\n  var preserveCol = this.PreserveCollinear || this.StrictlySimple;\n  for (;;)\n  {\n    if (pp.Prev === pp || pp.Prev === pp.Next)\n    {\n      outRec.Pts = null;\n      return;\n    }\n\n    //test for duplicate points and collinear edges ...\n    if ((ClipperLib.FPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.FPoint.op_Equality(pp.Pt, pp.Prev.Pt)) || (ClipperLib.ClipperBase.SlopesEqual4(pp.Prev.Pt, pp.Pt, pp.Next.Pt) && (!preserveCol || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))))\n    {\n      lastOK = null;\n      pp.Prev.Next = pp.Next;\n      pp.Next.Prev = pp.Prev;\n      pp = pp.Prev;\n    }\n    else if (pp === lastOK)\n      break;\n    else\n    {\n      if (lastOK === null)\n        lastOK = pp;\n      pp = pp.Next;\n    }\n  }\n  outRec.Pts = pp;\n};\n\nClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter)\n{\n  var result = new ClipperLib.OutPt();\n  //result.Pt = outPt.Pt;\n  result.Pt[0] = outPt.Pt[0];\n  result.Pt[1] = outPt.Pt[1];\n  if (ClipperLib.use_xyz) result.Pt.Z = outPt.Pt.Z;\n  result.Idx = outPt.Idx;\n  if (InsertAfter)\n  {\n    result.Next = outPt.Next;\n    result.Prev = outPt;\n    outPt.Next.Prev = result;\n    outPt.Next = result;\n  }\n  else\n  {\n    result.Prev = outPt.Prev;\n    result.Next = outPt;\n    outPt.Prev.Next = result;\n    outPt.Prev = result;\n  }\n  return result;\n};\n\nClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val)\n{\n  if (a1 < a2)\n  {\n    if (b1 < b2)\n    {\n      $val.Left = Math.max(a1, b1);\n      $val.Right = Math.min(a2, b2);\n    }\n    else\n    {\n      $val.Left = Math.max(a1, b2);\n      $val.Right = Math.min(a2, b1);\n    }\n  }\n  else\n  {\n    if (b1 < b2)\n    {\n      $val.Left = Math.max(a2, b1);\n      $val.Right = Math.min(a1, b2);\n    }\n    else\n    {\n      $val.Left = Math.max(a2, b2);\n      $val.Right = Math.min(a1, b1);\n    }\n  }\n  return $val.Left < $val.Right;\n};\n\nClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft)\n{\n  var Dir1 = (op1.Pt[0] > op1b.Pt[0] ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n  var Dir2 = (op2.Pt[0] > op2b.Pt[0] ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n  if (Dir1 === Dir2)\n    return false;\n  //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\n  //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\n  //So, to facilitate this while inserting Op1b and Op2b ...\n  //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\n  //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\n  if (Dir1 === ClipperLib.Direction.dLeftToRight)\n  {\n    while (op1.Next.Pt[0] <= Pt[0] &&\n      op1.Next.Pt[0] >= op1.Pt[0] && op1.Next.Pt[1] === Pt[1])\n      op1 = op1.Next;\n    if (DiscardLeft && (op1.Pt[0] !== Pt[0]))\n      op1 = op1.Next;\n    op1b = this.DupOutPt(op1, !DiscardLeft);\n    if (ClipperLib.FPoint.op_Inequality(op1b.Pt, Pt))\n    {\n      op1 = op1b;\n      //op1.Pt = Pt;\n      op1.Pt[0] = Pt[0];\n      op1.Pt[1] = Pt[1];\n      if (ClipperLib.use_xyz) op1.Pt.Z = Pt.Z;\n      op1b = this.DupOutPt(op1, !DiscardLeft);\n    }\n  }\n  else\n  {\n    while (op1.Next.Pt[0] >= Pt[0] &&\n      op1.Next.Pt[0] <= op1.Pt[0] && op1.Next.Pt[1] === Pt[1])\n      op1 = op1.Next;\n    if (!DiscardLeft && (op1.Pt[0] !== Pt[0]))\n      op1 = op1.Next;\n    op1b = this.DupOutPt(op1, DiscardLeft);\n    if (ClipperLib.FPoint.op_Inequality(op1b.Pt, Pt))\n    {\n      op1 = op1b;\n      //op1.Pt = Pt;\n      op1.Pt[0] = Pt[0];\n      op1.Pt[1] = Pt[1];\n      if (ClipperLib.use_xyz) op1.Pt.Z = Pt.Z;\n      op1b = this.DupOutPt(op1, DiscardLeft);\n    }\n  }\n  if (Dir2 === ClipperLib.Direction.dLeftToRight)\n  {\n    while (op2.Next.Pt[0] <= Pt[0] &&\n      op2.Next.Pt[0] >= op2.Pt[0] && op2.Next.Pt[1] === Pt[1])\n      op2 = op2.Next;\n    if (DiscardLeft && (op2.Pt[0] !== Pt[0]))\n      op2 = op2.Next;\n    op2b = this.DupOutPt(op2, !DiscardLeft);\n    if (ClipperLib.FPoint.op_Inequality(op2b.Pt, Pt))\n    {\n      op2 = op2b;\n      //op2.Pt = Pt;\n      op2.Pt[0] = Pt[0];\n      op2.Pt[1] = Pt[1];\n      if (ClipperLib.use_xyz) op2.Pt.Z = Pt.Z;\n      op2b = this.DupOutPt(op2, !DiscardLeft);\n    }\n  }\n  else\n  {\n    while (op2.Next.Pt[0] >= Pt[0] &&\n      op2.Next.Pt[0] <= op2.Pt[0] && op2.Next.Pt[1] === Pt[1])\n      op2 = op2.Next;\n    if (!DiscardLeft && (op2.Pt[0] !== Pt[0]))\n      op2 = op2.Next;\n    op2b = this.DupOutPt(op2, DiscardLeft);\n    if (ClipperLib.FPoint.op_Inequality(op2b.Pt, Pt))\n    {\n      op2 = op2b;\n      //op2.Pt = Pt;\n      op2.Pt[0] = Pt[0];\n      op2.Pt[1] = Pt[1];\n      if (ClipperLib.use_xyz) op2.Pt.Z = Pt.Z;\n      op2b = this.DupOutPt(op2, DiscardLeft);\n    }\n  }\n  if ((Dir1 === ClipperLib.Direction.dLeftToRight) === DiscardLeft)\n  {\n    op1.Prev = op2;\n    op2.Next = op1;\n    op1b.Next = op2b;\n    op2b.Prev = op1b;\n  }\n  else\n  {\n    op1.Next = op2;\n    op2.Prev = op1;\n    op1b.Prev = op2b;\n    op2b.Next = op1b;\n  }\n  return true;\n};\n\nClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2)\n{\n  var op1 = j.OutPt1,\n    op1b = new ClipperLib.OutPt();\n  var op2 = j.OutPt2,\n    op2b = new ClipperLib.OutPt();\n  //There are 3 kinds of joins for output polygons ...\n  //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are vertices anywhere\n  //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\n  //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\n  //location at the Bottom of the overlapping segment (& Join.OffPt is above).\n  //3. StrictlySimple joins where edges touch but are not collinear and where\n  //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\n  var isHorizontal = (j.OutPt1.Pt[1] === j.OffPt[1]);\n  if (isHorizontal && (ClipperLib.FPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.FPoint.op_Equality(j.OffPt, j.OutPt2.Pt)))\n  {\n    //Strictly Simple join ...\n    if (outRec1 !== outRec2) return false;\n\n    op1b = j.OutPt1.Next;\n    while (op1b !== op1 && (ClipperLib.FPoint.op_Equality(op1b.Pt, j.OffPt)))\n      op1b = op1b.Next;\n    var reverse1 = (op1b.Pt[1] > j.OffPt[1]);\n    op2b = j.OutPt2.Next;\n    while (op2b !== op2 && (ClipperLib.FPoint.op_Equality(op2b.Pt, j.OffPt)))\n      op2b = op2b.Next;\n    var reverse2 = (op2b.Pt[1] > j.OffPt[1]);\n    if (reverse1 === reverse2)\n      return false;\n    if (reverse1)\n    {\n      op1b = this.DupOutPt(op1, false);\n      op2b = this.DupOutPt(op2, true);\n      op1.Prev = op2;\n      op2.Next = op1;\n      op1b.Next = op2b;\n      op2b.Prev = op1b;\n      j.OutPt1 = op1;\n      j.OutPt2 = op1b;\n      return true;\n    }\n    else\n    {\n      op1b = this.DupOutPt(op1, true);\n      op2b = this.DupOutPt(op2, false);\n      op1.Next = op2;\n      op2.Prev = op1;\n      op1b.Prev = op2b;\n      op2b.Next = op1b;\n      j.OutPt1 = op1;\n      j.OutPt2 = op1b;\n      return true;\n    }\n  }\n  else if (isHorizontal)\n  {\n    //treat horizontal joins differently to non-horizontal joins since with\n    //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\n    //may be anywhere along the horizontal edge.\n    op1b = op1;\n    while (op1.Prev.Pt[1] === op1.Pt[1] && op1.Prev !== op1b && op1.Prev !== op2)\n      op1 = op1.Prev;\n    while (op1b.Next.Pt[1] === op1b.Pt[1] && op1b.Next !== op1 && op1b.Next !== op2)\n      op1b = op1b.Next;\n    if (op1b.Next === op1 || op1b.Next === op2)\n      return false;\n    //a flat 'polygon'\n    op2b = op2;\n    while (op2.Prev.Pt[1] === op2.Pt[1] && op2.Prev !== op2b && op2.Prev !== op1b)\n      op2 = op2.Prev;\n    while (op2b.Next.Pt[1] === op2b.Pt[1] && op2b.Next !== op2 && op2b.Next !== op1)\n      op2b = op2b.Next;\n    if (op2b.Next === op2 || op2b.Next === op1)\n      return false;\n    //a flat 'polygon'\n    //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges\n\n    var $val = {\n      Left: null,\n      Right: null\n    };\n\n    if (!this.GetOverlap(op1.Pt[0], op1b.Pt[0], op2.Pt[0], op2b.Pt[0], $val))\n      return false;\n    var Left = $val.Left;\n    var Right = $val.Right;\n\n    //DiscardLeftSide: when overlapping edges are joined, a spike will created\n    //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\n    //on the discard Side as either may still be needed for other joins ...\n    var Pt = new ClipperLib.FPoint0();\n    var DiscardLeftSide;\n    if (op1.Pt[0] >= Left && op1.Pt[0] <= Right)\n    {\n      //Pt = op1.Pt;\n      Pt[0] = op1.Pt[0];\n      Pt[1] = op1.Pt[1];\n      if (ClipperLib.use_xyz) Pt.Z = op1.Pt.Z;\n      DiscardLeftSide = (op1.Pt[0] > op1b.Pt[0]);\n    }\n    else if (op2.Pt[0] >= Left && op2.Pt[0] <= Right)\n    {\n      //Pt = op2.Pt;\n      Pt[0] = op2.Pt[0];\n      Pt[1] = op2.Pt[1];\n      if (ClipperLib.use_xyz) Pt.Z = op2.Pt.Z;\n      DiscardLeftSide = (op2.Pt[0] > op2b.Pt[0]);\n    }\n    else if (op1b.Pt[0] >= Left && op1b.Pt[0] <= Right)\n    {\n      //Pt = op1b.Pt;\n      Pt[0] = op1b.Pt[0];\n      Pt[1] = op1b.Pt[1];\n      if (ClipperLib.use_xyz) Pt.Z = op1b.Pt.Z;\n      DiscardLeftSide = op1b.Pt[0] > op1.Pt[0];\n    }\n    else\n    {\n      //Pt = op2b.Pt;\n      Pt[0] = op2b.Pt[0];\n      Pt[1] = op2b.Pt[1];\n      if (ClipperLib.use_xyz) Pt.Z = op2b.Pt.Z;\n      DiscardLeftSide = (op2b.Pt[0] > op2.Pt[0]);\n    }\n    j.OutPt1 = op1;\n    j.OutPt2 = op2;\n    return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\n  }\n  else\n  {\n    //nb: For non-horizontal joins ...\n    //    1. Jr.OutPt1.Pt[1] == Jr.OutPt2.Pt[1]\n    //    2. Jr.OutPt1.Pt > Jr.OffPt[1]\n    //make sure the polygons are correctly oriented ...\n    op1b = op1.Next;\n    while ((ClipperLib.FPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b !== op1))\n      op1b = op1b.Next;\n    var Reverse1 = ((op1b.Pt[1] > op1.Pt[1]) || !ClipperLib.ClipperBase.SlopesEqual4(op1.Pt, op1b.Pt, j.OffPt));\n    if (Reverse1)\n    {\n      op1b = op1.Prev;\n      while ((ClipperLib.FPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b !== op1))\n        op1b = op1b.Prev;\n\n      if ((op1b.Pt[1] > op1.Pt[1]) || !ClipperLib.ClipperBase.SlopesEqual4(op1.Pt, op1b.Pt, j.OffPt))\n        return false;\n    }\n    op2b = op2.Next;\n    while ((ClipperLib.FPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b !== op2))\n      op2b = op2b.Next;\n\n    var Reverse2 = ((op2b.Pt[1] > op2.Pt[1]) || !ClipperLib.ClipperBase.SlopesEqual4(op2.Pt, op2b.Pt, j.OffPt));\n    if (Reverse2)\n    {\n      op2b = op2.Prev;\n      while ((ClipperLib.FPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b !== op2))\n        op2b = op2b.Prev;\n\n      if ((op2b.Pt[1] > op2.Pt[1]) || !ClipperLib.ClipperBase.SlopesEqual4(op2.Pt, op2b.Pt, j.OffPt))\n        return false;\n    }\n    if ((op1b === op1) || (op2b === op2) || (op1b === op2b) ||\n      ((outRec1 === outRec2) && (Reverse1 === Reverse2)))\n      return false;\n    if (Reverse1)\n    {\n      op1b = this.DupOutPt(op1, false);\n      op2b = this.DupOutPt(op2, true);\n      op1.Prev = op2;\n      op2.Next = op1;\n      op1b.Next = op2b;\n      op2b.Prev = op1b;\n      j.OutPt1 = op1;\n      j.OutPt2 = op1b;\n      return true;\n    }\n    else\n    {\n      op1b = this.DupOutPt(op1, true);\n      op2b = this.DupOutPt(op2, false);\n      op1.Next = op2;\n      op2.Prev = op1;\n      op1b.Prev = op2b;\n      op2b.Next = op1b;\n      j.OutPt1 = op1;\n      j.OutPt2 = op1b;\n      return true;\n    }\n  }\n};\n\nClipperLib.Clipper.GetBounds = function (paths)\n{\n  var i = 0,\n    cnt = paths.length;\n  while (i < cnt && paths[i].length === 0) i++;\n  if (i === cnt) return new ClipperLib.FRect(0, 0, 0, 0);\n  var result = new ClipperLib.FRect();\n  result.left = paths[i][0][0];\n  result.right = result.left;\n  result.top = paths[i][0][1];\n  result.bottom = result.top;\n  for (; i < cnt; i++)\n    for (var j = 0, jlen = paths[i].length; j < jlen; j++)\n    {\n      if (paths[i][j][0] < result.left) result.left = paths[i][j][0];\n      else if (paths[i][j][0] > result.right) result.right = paths[i][j][0];\n      if (paths[i][j][1] < result.top) result.top = paths[i][j][1];\n      else if (paths[i][j][1] > result.bottom) result.bottom = paths[i][j][1];\n    }\n  return result;\n}\nClipperLib.Clipper.prototype.GetBounds2 = function (ops)\n{\n  var opStart = ops;\n  var result = new ClipperLib.FRect();\n  result.left = ops.Pt[0];\n  result.right = ops.Pt[0];\n  result.top = ops.Pt[1];\n  result.bottom = ops.Pt[1];\n  ops = ops.Next;\n  while (ops !== opStart)\n  {\n    if (ops.Pt[0] < result.left)\n      result.left = ops.Pt[0];\n    if (ops.Pt[0] > result.right)\n      result.right = ops.Pt[0];\n    if (ops.Pt[1] < result.top)\n      result.top = ops.Pt[1];\n    if (ops.Pt[1] > result.bottom)\n      result.bottom = ops.Pt[1];\n    ops = ops.Next;\n  }\n  return result;\n};\n\nClipperLib.Clipper.PointInPolygon = function (pt, path)\n{\n  //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n  //See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n  //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n  var result = 0,\n    cnt = path.length;\n  if (cnt < 3)\n    return 0;\n  var ip = path[0];\n  for (var i = 1; i <= cnt; ++i)\n  {\n    var ipNext = (i === cnt ? path[0] : path[i]);\n    if (ipNext[1] === pt[1])\n    {\n      if ((ipNext[0] === pt[0]) || (ip[1] === pt[1] && ((ipNext[0] > pt[0]) === (ip[0] < pt[0]))))\n        return -1;\n    }\n    if ((ip[1] < pt[1]) !== (ipNext[1] < pt[1]))\n    {\n      if (ip[0] >= pt[0])\n      {\n        if (ipNext[0] > pt[0])\n          result = 1 - result;\n        else\n        {\n          var d = (ip[0] - pt[0]) * (ipNext[1] - pt[1]) - (ipNext[0] - pt[0]) * (ip[1] - pt[1]);\n          if (d === 0)\n            return -1;\n          else if ((d > 0) === (ipNext[1] > ip[1]))\n            result = 1 - result;\n        }\n      }\n      else\n      {\n        if (ipNext[0] > pt[0])\n        {\n          var d = (ip[0] - pt[0]) * (ipNext[1] - pt[1]) - (ipNext[0] - pt[0]) * (ip[1] - pt[1]);\n          if (d === 0)\n            return -1;\n          else if ((d > 0) === (ipNext[1] > ip[1]))\n            result = 1 - result;\n        }\n      }\n    }\n    ip = ipNext;\n  }\n  return result;\n};\n\nClipperLib.Clipper.prototype.PointInPolygon = function (pt, op)\n{\n  //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n  var result = 0;\n  var startOp = op;\n  var ptx = pt[0],\n    pty = pt[1];\n  var poly0x = op.Pt[0],\n    poly0y = op.Pt[1];\n  do {\n    op = op.Next;\n    var poly1x = op.Pt[0],\n      poly1y = op.Pt[1];\n    if (poly1y === pty)\n    {\n      if ((poly1x === ptx) || (poly0y === pty && ((poly1x > ptx) === (poly0x < ptx))))\n        return -1;\n    }\n    if ((poly0y < pty) !== (poly1y < pty))\n    {\n      if (poly0x >= ptx)\n      {\n        if (poly1x > ptx)\n          result = 1 - result;\n        else\n        {\n          var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n          if (d === 0)\n            return -1;\n          if ((d > 0) === (poly1y > poly0y))\n            result = 1 - result;\n        }\n      }\n      else\n      {\n        if (poly1x > ptx)\n        {\n          var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n          if (d === 0)\n            return -1;\n          if ((d > 0) === (poly1y > poly0y))\n            result = 1 - result;\n        }\n      }\n    }\n    poly0x = poly1x;\n    poly0y = poly1y;\n  } while (startOp !== op);\n\n  return result;\n};\n\nClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2)\n{\n  var op = outPt1;\n  do {\n    //nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon\n    var res = this.PointInPolygon(op.Pt, outPt2);\n    if (res >= 0)\n      return res > 0;\n    op = op.Next;\n  }\n  while (op !== outPt1)\n  return true;\n};\n\nClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec)\n{\n  var outRec, firstLeft;\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n  {\n    outRec = this.m_PolyOuts[i];\n    firstLeft = ClipperLib.Clipper.ParseFirstLeft(outRec.FirstLeft);\n    if (outRec.Pts !== null && firstLeft === OldOutRec)\n    {\n      if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))\n        outRec.FirstLeft = NewOutRec;\n    }\n  }\n}\n\nClipperLib.Clipper.prototype.FixupFirstLefts2 = function (innerOutRec, outerOutRec)\n{\n  //A polygon has split into two such that one is now the inner of the other.\n  //It's possible that these polygons now wrap around other polygons, so check\n  //every polygon that's also contained by OuterOutRec's FirstLeft container\n  //(including nil) to see if they've become inner to the new inner polygon ...\n  var orfl = outerOutRec.FirstLeft;\n  var outRec, firstLeft;\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n  {\n    outRec = this.m_PolyOuts[i];\n    if (outRec.Pts === null || outRec === outerOutRec || outRec === innerOutRec)\n      continue;\n    firstLeft = ClipperLib.Clipper.ParseFirstLeft(outRec.FirstLeft);\n    if (firstLeft !== orfl && firstLeft !== innerOutRec && firstLeft !== outerOutRec)\n      continue;\n    if (this.Poly2ContainsPoly1(outRec.Pts, innerOutRec.Pts))\n      outRec.FirstLeft = innerOutRec;\n    else if (this.Poly2ContainsPoly1(outRec.Pts, outerOutRec.Pts))\n      outRec.FirstLeft = outerOutRec;\n    else if (outRec.FirstLeft === innerOutRec || outRec.FirstLeft === outerOutRec)\n      outRec.FirstLeft = orfl;\n  }\n}\n\nClipperLib.Clipper.prototype.FixupFirstLefts3 = function (OldOutRec, NewOutRec)\n{\n  //same as FixupFirstLefts1 but doesn't call Poly2ContainsPoly1()\n  var outRec;\n  var firstLeft;\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n  {\n    outRec = this.m_PolyOuts[i];\n    firstLeft = ClipperLib.Clipper.ParseFirstLeft(outRec.FirstLeft);\n    if (outRec.Pts !== null && firstLeft === OldOutRec)\n      outRec.FirstLeft = NewOutRec;\n  }\n}\n\nClipperLib.Clipper.ParseFirstLeft = function (FirstLeft)\n{\n  while (FirstLeft !== null && FirstLeft.Pts === null)\n    FirstLeft = FirstLeft.FirstLeft;\n  return FirstLeft;\n};\n\nClipperLib.Clipper.prototype.JoinCommonEdges = function ()\n{\n  for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++)\n  {\n    var join = this.m_Joins[i];\n    var outRec1 = this.GetOutRec(join.OutPt1.Idx);\n    var outRec2 = this.GetOutRec(join.OutPt2.Idx);\n    if (outRec1.Pts === null || outRec2.Pts === null)\n      continue;\n\n    if (outRec1.IsOpen || outRec2.IsOpen)\n    {\n      continue;\n    }\n\n    //get the polygon fragment with the correct hole state (FirstLeft)\n    //before calling JoinPoints() ...\n    var holeStateRec;\n    if (outRec1 === outRec2)\n      holeStateRec = outRec1;\n    else if (this.OutRec1RightOfOutRec2(outRec1, outRec2))\n      holeStateRec = outRec2;\n    else if (this.OutRec1RightOfOutRec2(outRec2, outRec1))\n      holeStateRec = outRec1;\n    else\n      holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\n    if (!this.JoinPoints(join, outRec1, outRec2)) continue;\n\n    if (outRec1 === outRec2)\n    {\n      //instead of joining two polygons, we've just created a new one by\n      //splitting one polygon into two.\n      outRec1.Pts = join.OutPt1;\n      outRec1.BottomPt = null;\n      outRec2 = this.CreateOutRec();\n      outRec2.Pts = join.OutPt2;\n      //update all OutRec2.Pts Idx's ...\n      this.UpdateOutPtIdxs(outRec2);\n\n      if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts))\n      {\n        //outRec1 contains outRec2 ...\n        outRec2.IsHole = !outRec1.IsHole;\n        outRec2.FirstLeft = outRec1;\n        if (this.m_UsingPolyTree)\n          this.FixupFirstLefts2(outRec2, outRec1);\n        if ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area$1(outRec2) > 0))\n          this.ReversePolyPtLinks(outRec2.Pts);\n      }\n      else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts))\n      {\n        //outRec2 contains outRec1 ...\n        outRec2.IsHole = outRec1.IsHole;\n        outRec1.IsHole = !outRec2.IsHole;\n        outRec2.FirstLeft = outRec1.FirstLeft;\n        outRec1.FirstLeft = outRec2;\n        if (this.m_UsingPolyTree)\n          this.FixupFirstLefts2(outRec1, outRec2);\n\n        if ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area$1(outRec1) > 0))\n          this.ReversePolyPtLinks(outRec1.Pts);\n      }\n      else\n      {\n        //the 2 polygons are completely separate ...\n        outRec2.IsHole = outRec1.IsHole;\n        outRec2.FirstLeft = outRec1.FirstLeft;\n        //fixup FirstLeft pointers that may need reassigning to OutRec2\n        if (this.m_UsingPolyTree)\n          this.FixupFirstLefts1(outRec1, outRec2);\n      }\n    }\n    else\n    {\n      //joined 2 polygons together ...\n      outRec2.Pts = null;\n      outRec2.BottomPt = null;\n      outRec2.Idx = outRec1.Idx;\n      outRec1.IsHole = holeStateRec.IsHole;\n      if (holeStateRec === outRec2)\n        outRec1.FirstLeft = outRec2.FirstLeft;\n      outRec2.FirstLeft = outRec1;\n      //fixup FirstLeft pointers that may need reassigning to OutRec1\n      if (this.m_UsingPolyTree)\n        this.FixupFirstLefts3(outRec2, outRec1);\n    }\n  }\n};\n\nClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec)\n{\n  var op = outrec.Pts;\n  do {\n    op.Idx = outrec.Idx;\n    op = op.Prev;\n  }\n  while (op !== outrec.Pts)\n};\n\nClipperLib.Clipper.prototype.DoSimplePolygons = function ()\n{\n  var i = 0;\n  while (i < this.m_PolyOuts.length)\n  {\n    var outrec = this.m_PolyOuts[i++];\n    var op = outrec.Pts;\n    if (op === null || outrec.IsOpen)\n      continue;\n    do //for each Pt in Polygon until duplicate found do ...\n    {\n      var op2 = op.Next;\n      while (op2 !== outrec.Pts)\n      {\n        if ((ClipperLib.FPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next !== op && op2.Prev !== op)\n        {\n          //split the polygon into two ...\n          var op3 = op.Prev;\n          var op4 = op2.Prev;\n          op.Prev = op4;\n          op4.Next = op;\n          op2.Prev = op3;\n          op3.Next = op2;\n          outrec.Pts = op;\n          var outrec2 = this.CreateOutRec();\n          outrec2.Pts = op2;\n          this.UpdateOutPtIdxs(outrec2);\n          if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts))\n          {\n            //OutRec2 is contained by OutRec1 ...\n            outrec2.IsHole = !outrec.IsHole;\n            outrec2.FirstLeft = outrec;\n            if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec2, outrec);\n\n          }\n          else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts))\n          {\n            //OutRec1 is contained by OutRec2 ...\n            outrec2.IsHole = outrec.IsHole;\n            outrec.IsHole = !outrec2.IsHole;\n            outrec2.FirstLeft = outrec.FirstLeft;\n            outrec.FirstLeft = outrec2;\n            if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec, outrec2);\n          }\n          else\n          {\n            //the 2 polygons are separate ...\n            outrec2.IsHole = outrec.IsHole;\n            outrec2.FirstLeft = outrec.FirstLeft;\n            if (this.m_UsingPolyTree) this.FixupFirstLefts1(outrec, outrec2);\n          }\n          op2 = op;\n          //ie get ready for the next iteration\n        }\n        op2 = op2.Next;\n      }\n      op = op.Next;\n    }\n    while (op !== outrec.Pts)\n  }\n};\n\nClipperLib.Clipper.Area = function (poly)\n{\n  if (!Array.isArray(poly))\n    return 0;\n  var cnt = poly.length;\n  if (cnt < 3)\n    return 0;\n  var a = 0;\n  for (var i = 0, j = cnt - 1; i < cnt; ++i)\n  {\n    a += (poly[j][0] + poly[i][0]) * (poly[j][1] - poly[i][1]);\n    j = i;\n  }\n  return -a * 0.5;\n};\n\nClipperLib.Clipper.prototype.Area = function (op)\n{\n  var opFirst = op;\n  if (op === null) return 0;\n  var a = 0;\n  do {\n    a = a + (op.Prev.Pt[0] + op.Pt[0]) * (op.Prev.Pt[1] - op.Pt[1]);\n    op = op.Next;\n  } while (op !== opFirst); // && typeof op !== 'undefined');\n  return a * 0.5;\n}\n\nClipperLib.Clipper.prototype.Area$1 = function (outRec)\n{\n  return this.Area(outRec.Pts);\n};\n\nClipperLib.Clipper.SimplifyPolygon = function (poly, fillType)\n{\n  var result = new Array();\n  var c = new ClipperLib.Clipper(0);\n  c.StrictlySimple = true;\n  c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);\n  c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n  return result;\n};\n\nClipperLib.Clipper.SimplifyPolygons = function (polys, fillType)\n{\n  if (typeof (fillType) === \"undefined\") fillType = ClipperLib.PolyFillType.pftEvenOdd;\n  var result = new Array();\n  var c = new ClipperLib.Clipper(0);\n  c.StrictlySimple = true;\n  c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);\n  c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n  return result;\n};\n\nClipperLib.Clipper.DistanceSqrd = function (pt1, pt2)\n{\n  var dx = (pt1[0] - pt2[0]);\n  var dy = (pt1[1] - pt2[1]);\n  return (dx * dx + dy * dy);\n};\n\nClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2)\n{\n  //The equation of a line in general form (Ax + By + C = 0)\n  //given 2 points (x,y) & (x,y) is ...\n  //(y - y)x + (x - x)y + (y - y)x - (x - x)y = 0\n  //A = (y - y); B = (x - x); C = (y - y)x - (x - x)y\n  //perpendicular distance of point (x,y) = (Ax + By + C)/Sqrt(A + B)\n  //see http://en.wikipedia.org/wiki/Perpendicular_distance\n  var A = ln1[1] - ln2[1];\n  var B = ln2[0] - ln1[0];\n  var C = A * ln1[0] + B * ln1[1];\n  C = A * pt[0] + B * pt[1] - C;\n  return (C * C) / (A * A + B * B);\n};\n\nClipperLib.Clipper.SlopesNearCollinear = function (pt1, pt2, pt3, distSqrd)\n{\n  //this function is more accurate when the point that's GEOMETRICALLY\n  //between the other 2 points is the one that's tested for distance.\n  //nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts\n  if (Math.abs(pt1[0] - pt2[0]) > Math.abs(pt1[1] - pt2[1]))\n  {\n    if ((pt1[0] > pt2[0]) === (pt1[0] < pt3[0]))\n      return ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n    else if ((pt2[0] > pt1[0]) === (pt2[0] < pt3[0]))\n      return ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n    else\n      return ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n  }\n  else\n  {\n    if ((pt1[1] > pt2[1]) === (pt1[1] < pt3[1]))\n      return ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n    else if ((pt2[1] > pt1[1]) === (pt2[1] < pt3[1]))\n      return ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n    else\n      return ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n  }\n}\n\nClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd)\n{\n  var dx = pt1[0] - pt2[0];\n  var dy = pt1[1] - pt2[1];\n  return ((dx * dx) + (dy * dy) <= distSqrd);\n};\n\nClipperLib.Clipper.ExcludeOp = function (op)\n{\n  var result = op.Prev;\n  result.Next = op.Next;\n  op.Next.Prev = result;\n  result.Idx = 0;\n  return result;\n};\n\nClipperLib.Clipper.CleanPolygon = function (path, distance)\n{\n  if (typeof (distance) === \"undefined\") distance = 1.415;\n  //distance = proximity in units/pixels below which vertices will be stripped.\n  //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have\n  //both x & y coords within 1 unit, then the second vertex will be stripped.\n  var cnt = path.length;\n  if (cnt === 0)\n    return new Array();\n  var outPts = new Array(cnt);\n  for (var i = 0; i < cnt; ++i)\n    outPts[i] = new ClipperLib.OutPt();\n  for (var i = 0; i < cnt; ++i)\n  {\n    outPts[i].Pt = path[i];\n    outPts[i].Next = outPts[(i + 1) % cnt];\n    outPts[i].Next.Prev = outPts[i];\n    outPts[i].Idx = 0;\n  }\n  var distSqrd = distance * distance;\n  var op = outPts[0];\n  while (op.Idx === 0 && op.Next !== op.Prev)\n  {\n    if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd))\n    {\n      op = ClipperLib.Clipper.ExcludeOp(op);\n      cnt--;\n    }\n    else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd))\n    {\n      ClipperLib.Clipper.ExcludeOp(op.Next);\n      op = ClipperLib.Clipper.ExcludeOp(op);\n      cnt -= 2;\n    }\n    else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd))\n    {\n      op = ClipperLib.Clipper.ExcludeOp(op);\n      cnt--;\n    }\n    else\n    {\n      op.Idx = 1;\n      op = op.Next;\n    }\n  }\n  if (cnt < 3)\n    cnt = 0;\n  var result = new Array(cnt);\n  for (var i = 0; i < cnt; ++i)\n  {\n    result[i] = new ClipperLib.FPoint1(op.Pt);\n    op = op.Next;\n  }\n  outPts = null;\n  return result;\n};\n\nClipperLib.Clipper.CleanPolygons = function (polys, distance)\n{\n  var result = new Array(polys.length);\n  for (var i = 0, ilen = polys.length; i < ilen; i++)\n    result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);\n  return result;\n};\n\nClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed)\n{\n  var delta = (IsClosed ? 1 : 0);\n  var polyCnt = pattern.length;\n  var pathCnt = path.length;\n  var result = new Array();\n  if (IsSum)\n    for (var i = 0; i < pathCnt; i++)\n    {\n      var p = new Array(polyCnt);\n      for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n        p[j] = new ClipperLib.FPoint2(path[i][0] + ip[0], path[i][1] + ip[1]);\n      result.push(p);\n    }\n  else\n    for (var i = 0; i < pathCnt; i++)\n    {\n      var p = new Array(polyCnt);\n      for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n        p[j] = new ClipperLib.FPoint2(path[i][0] - ip[0], path[i][1] - ip[1]);\n      result.push(p);\n    }\n  var quads = new Array();\n  for (var i = 0; i < pathCnt - 1 + delta; i++)\n    for (var j = 0; j < polyCnt; j++)\n    {\n      var quad = new Array();\n      quad.push(result[i % pathCnt][j % polyCnt]);\n      quad.push(result[(i + 1) % pathCnt][j % polyCnt]);\n      quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);\n      quad.push(result[i % pathCnt][(j + 1) % polyCnt]);\n      if (!ClipperLib.Clipper.Orientation(quad))\n        quad.reverse();\n      quads.push(quad);\n    }\n  return quads;\n};\n\nClipperLib.Clipper.MinkowskiSum = function (pattern, path_or_paths, pathIsClosed)\n{\n  if (!(path_or_paths[0] instanceof Array))\n  {\n    var path = path_or_paths;\n    var paths = ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);\n    var c = new ClipperLib.Clipper();\n    c.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n    c.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n    return paths;\n  }\n  else\n  {\n    var paths = path_or_paths;\n    var solution = new ClipperLib.Paths();\n    var c = new ClipperLib.Clipper();\n    for (var i = 0; i < paths.length; ++i)\n    {\n      var tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);\n      c.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);\n      if (pathIsClosed)\n      {\n        var path = ClipperLib.Clipper.TranslatePath(paths[i], pattern[0]);\n        c.AddPath(path, ClipperLib.PolyType.ptClip, true);\n      }\n    }\n    c.Execute(ClipperLib.ClipType.ctUnion, solution,\n      ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n    return solution;\n  }\n}\n\nClipperLib.Clipper.TranslatePath = function (path, delta)\n{\n  var outPath = new ClipperLib.Path();\n  for (var i = 0; i < path.length; i++)\n    outPath.push(new ClipperLib.FPoint2(path[i][0] + delta[0], path[i][1] + delta[1]));\n  return outPath;\n}\n\nClipperLib.Clipper.MinkowskiDiff = function (poly1, poly2)\n{\n  var paths = ClipperLib.Clipper.Minkowski(poly1, poly2, false, true);\n  var c = new ClipperLib.Clipper();\n  c.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n  c.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n  return paths;\n}\n\nClipperLib.Clipper.PolyTreeToPaths = function (polytree)\n{\n  var result = new Array();\n  //result.set_Capacity(polytree.get_Total());\n  ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);\n  return result;\n};\n\nClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths)\n{\n  var match = true;\n  switch (nt)\n  {\n    case ClipperLib.Clipper.NodeType.ntOpen:\n      return;\n    case ClipperLib.Clipper.NodeType.ntClosed:\n      match = !polynode.IsOpen;\n      break;\n    default:\n      break;\n  }\n  if (polynode.m_polygon.length > 0 && match)\n    paths.push(polynode.m_polygon);\n  for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])\n    ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);\n};\n\nClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree)\n{\n  var result = new ClipperLib.Paths();\n  //result.set_Capacity(polytree.ChildCount());\n  for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)\n    if (polytree.Childs()[i].IsOpen)\n      result.push(polytree.Childs()[i].m_polygon);\n  return result;\n};\n\nClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree)\n{\n  var result = new ClipperLib.Paths();\n  //result.set_Capacity(polytree.Total());\n  ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);\n  return result;\n};\n\nInherit(ClipperLib.Clipper, ClipperLib.ClipperBase);\nClipperLib.Clipper.NodeType = {\n  ntAny: 0,\n  ntOpen: 1,\n  ntClosed: 2\n};\n\n/**\n* @constructor\n*/\nClipperLib.ClipperOffset = function (miterLimit, arcTolerance)\n{\n  if (typeof (miterLimit) === \"undefined\") miterLimit = 2;\n  if (typeof (arcTolerance) === \"undefined\") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;\n  this.m_destPolys = new ClipperLib.Paths();\n  this.m_srcPoly = new ClipperLib.Path();\n  this.m_destPoly = new ClipperLib.Path();\n  this.m_normals = new Array();\n  this.m_delta = 0;\n  this.m_sinA = 0;\n  this.m_sin = 0;\n  this.m_cos = 0;\n  this.m_miterLim = 0;\n  this.m_StepsPerRad = 0;\n  this.m_lowest = new ClipperLib.FPoint0();\n  this.m_polyNodes = new ClipperLib.PolyNode();\n  this.MiterLimit = miterLimit;\n  this.ArcTolerance = arcTolerance;\n  this.m_lowest[0] = -1;\n};\n\nClipperLib.ClipperOffset.two_pi = 6.28318530717959;\nClipperLib.ClipperOffset.def_arc_tolerance = 0.25;\nClipperLib.ClipperOffset.prototype.Clear = function ()\n{\n  ClipperLib.Clear(this.m_polyNodes.Childs());\n  this.m_lowest[0] = -1;\n};\n\nClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType)\n{\n  var highI = path.length - 1;\n  if (highI < 0)\n    return;\n  var newNode = new ClipperLib.PolyNode();\n  newNode.m_jointype = joinType;\n  newNode.m_endtype = endType;\n  //strip duplicate points from path and also get index to the lowest point ...\n  if (endType === ClipperLib.EndType.etClosedLine || endType === ClipperLib.EndType.etClosedPolygon)\n    while (highI > 0 && ClipperLib.FPoint.op_Equality(path[0], path[highI]))\n      highI--;\n  //newNode.m_polygon.set_Capacity(highI + 1);\n  newNode.m_polygon.push(path[0]);\n  var j = 0,\n    k = 0;\n  for (var i = 1; i <= highI; i++)\n    if (ClipperLib.FPoint.op_Inequality(newNode.m_polygon[j], path[i]))\n    {\n      j++;\n      newNode.m_polygon.push(path[i]);\n      if (path[i][1] > newNode.m_polygon[k][1] || (path[i][1] === newNode.m_polygon[k][1] && path[i][0] < newNode.m_polygon[k][0]))\n        k = j;\n    }\n  if (endType === ClipperLib.EndType.etClosedPolygon && j < 2) return;\n\n  this.m_polyNodes.AddChild(newNode);\n  //if this path's lowest pt is lower than all the others then update m_lowest\n  if (endType !== ClipperLib.EndType.etClosedPolygon)\n    return;\n  if (this.m_lowest[0] < 0)\n    this.m_lowest = new ClipperLib.FPoint2(this.m_polyNodes.ChildCount() - 1, k);\n  else\n  {\n    var ip = this.m_polyNodes.Childs()[this.m_lowest[0]].m_polygon[this.m_lowest[1]];\n    if (newNode.m_polygon[k][1] > ip[1] || (newNode.m_polygon[k][1] === ip[1] && newNode.m_polygon[k][0] < ip[0]))\n      this.m_lowest = new ClipperLib.FPoint2(this.m_polyNodes.ChildCount() - 1, k);\n  }\n};\n\nClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType)\n{\n  for (var i = 0, ilen = paths.length; i < ilen; i++)\n    this.AddPath(paths[i], joinType, endType);\n};\n\nClipperLib.ClipperOffset.prototype.FixOrientations = function ()\n{\n  //fixup orientations of all closed paths if the orientation of the\n  //closed path with the lowermost vertex is wrong ...\n  if (this.m_lowest[0] >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest[0]].m_polygon))\n  {\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n    {\n      var node = this.m_polyNodes.Childs()[i];\n      if (node.m_endtype === ClipperLib.EndType.etClosedPolygon || (node.m_endtype === ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))\n        node.m_polygon.reverse();\n    }\n  }\n  else\n  {\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n    {\n      var node = this.m_polyNodes.Childs()[i];\n      if (node.m_endtype === ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))\n        node.m_polygon.reverse();\n    }\n  }\n};\n\nClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2)\n{\n  var dx = (pt2[0] - pt1[0]);\n  var dy = (pt2[1] - pt1[1]);\n  if ((dx === 0) && (dy === 0))\n    return new ClipperLib.FPoint2(0, 0);\n  var f = 1 / Math.sqrt(dx * dx + dy * dy);\n  dx *= f;\n  dy *= f;\n  return new ClipperLib.FPoint2(dy, -dx);\n};\n\nClipperLib.ClipperOffset.prototype.DoOffset = function (delta)\n{\n  this.m_destPolys = new Array();\n  this.m_delta = delta;\n  //if Zero offset, just copy any CLOSED polygons to m_p and return ...\n  if (ClipperLib.ClipperBase.near_zero(delta))\n  {\n    //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n    {\n      var node = this.m_polyNodes.Childs()[i];\n      if (node.m_endtype === ClipperLib.EndType.etClosedPolygon)\n        this.m_destPolys.push(node.m_polygon);\n    }\n    return;\n  }\n  //see offset_triginometry3.svg in the documentation folder ...\n  if (this.MiterLimit > 2)\n    this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);\n  else\n    this.m_miterLim = 0.5;\n  var y;\n  if (this.ArcTolerance <= 0)\n    y = ClipperLib.ClipperOffset.def_arc_tolerance;\n  else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)\n    y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;\n  else\n    y = this.ArcTolerance;\n  //see offset_triginometry2.svg in the documentation folder ...\n  var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));\n  this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);\n  this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);\n  this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;\n  if (delta < 0)\n    this.m_sin = -this.m_sin;\n  //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);\n  for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n  {\n    var node = this.m_polyNodes.Childs()[i];\n    this.m_srcPoly = node.m_polygon;\n    var len = this.m_srcPoly.length;\n    if (len === 0 || (delta <= 0 && (len < 3 || node.m_endtype !== ClipperLib.EndType.etClosedPolygon)))\n      continue;\n    this.m_destPoly = new Array();\n    if (len === 1)\n    {\n      if (node.m_jointype === ClipperLib.JoinType.jtRound)\n      {\n        var X = 1,\n          Y = 0;\n        for (var j = 1; j <= steps; j++)\n        {\n          this.m_destPoly.push(new ClipperLib.FPoint2(this.m_srcPoly[0][0] + X * delta, this.m_srcPoly[0][1] + Y * delta));\n          var X2 = X;\n          X = X * this.m_cos - this.m_sin * Y;\n          Y = X2 * this.m_sin + Y * this.m_cos;\n        }\n      }\n      else\n      {\n        var X = -1,\n          Y = -1;\n        for (var j = 0; j < 4; ++j)\n        {\n          this.m_destPoly.push(new ClipperLib.FPoint2(this.m_srcPoly[0][0] + X * delta, this.m_srcPoly[0][1] + Y * delta));\n          if (X < 0)\n            X = 1;\n          else if (Y < 0)\n            Y = 1;\n          else\n            X = -1;\n        }\n      }\n      this.m_destPolys.push(this.m_destPoly);\n      continue;\n    }\n    //build m_normals ...\n    this.m_normals.length = 0;\n    //this.m_normals.set_Capacity(len);\n    for (var j = 0; j < len - 1; j++)\n      this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));\n    if (node.m_endtype === ClipperLib.EndType.etClosedLine || node.m_endtype === ClipperLib.EndType.etClosedPolygon)\n      this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));\n    else\n      this.m_normals.push(new ClipperLib.FPoint1(this.m_normals[len - 2]));\n    if (node.m_endtype === ClipperLib.EndType.etClosedPolygon)\n    {\n      var k = len - 1;\n      for (var j = 0; j < len; j++)\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      this.m_destPolys.push(this.m_destPoly);\n    }\n    else if (node.m_endtype === ClipperLib.EndType.etClosedLine)\n    {\n      var k = len - 1;\n      for (var j = 0; j < len; j++)\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      this.m_destPolys.push(this.m_destPoly);\n      this.m_destPoly = new Array();\n      //re-build m_normals ...\n      var n = this.m_normals[len - 1];\n      for (var j = len - 1; j > 0; j--)\n        this.m_normals[j] = new ClipperLib.FPoint2(-this.m_normals[j - 1][0], -this.m_normals[j - 1][1]);\n      this.m_normals[0] = new ClipperLib.FPoint2(-n[0], -n[1]);\n      k = 0;\n      for (var j = len - 1; j >= 0; j--)\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      this.m_destPolys.push(this.m_destPoly);\n    }\n    else\n    {\n      var k = 0;\n      for (var j = 1; j < len - 1; ++j)\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      var pt1;\n      if (node.m_endtype === ClipperLib.EndType.etOpenButt)\n      {\n        var j = len - 1;\n        pt1 = new ClipperLib.FPoint2(this.m_srcPoly[j][0] + this.m_normals[j][0] * delta, this.m_srcPoly[j][1] + this.m_normals[j][1] * delta);\n        this.m_destPoly.push(pt1);\n        pt1 = new ClipperLib.FPoint2(this.m_srcPoly[j][0] - this.m_normals[j][0] * delta, this.m_srcPoly[j][1] - this.m_normals[j][1] * delta);\n        this.m_destPoly.push(pt1);\n      }\n      else\n      {\n        var j = len - 1;\n        k = len - 2;\n        this.m_sinA = 0;\n        this.m_normals[j] = new ClipperLib.FPoint2(-this.m_normals[j][0], -this.m_normals[j][1]);\n        if (node.m_endtype === ClipperLib.EndType.etOpenSquare)\n          this.DoSquare(j, k);\n        else\n          this.DoRound(j, k);\n      }\n      //re-build m_normals ...\n      for (var j = len - 1; j > 0; j--)\n        this.m_normals[j] = new ClipperLib.FPoint2(-this.m_normals[j - 1][0], -this.m_normals[j - 1][1]);\n      this.m_normals[0] = new ClipperLib.FPoint2(-this.m_normals[1][0], -this.m_normals[1][1]);\n      k = len - 1;\n      for (var j = k - 1; j > 0; --j)\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      if (node.m_endtype === ClipperLib.EndType.etOpenButt)\n      {\n        pt1 = new ClipperLib.FPoint2(this.m_srcPoly[0][0] - this.m_normals[0][0] * delta, this.m_srcPoly[0][1] - this.m_normals[0][1] * delta);\n        this.m_destPoly.push(pt1);\n        pt1 = new ClipperLib.FPoint2(this.m_srcPoly[0][0] + this.m_normals[0][0] * delta, this.m_srcPoly[0][1] + this.m_normals[0][1] * delta);\n        this.m_destPoly.push(pt1);\n      }\n      else\n      {\n        k = 1;\n        this.m_sinA = 0;\n        if (node.m_endtype === ClipperLib.EndType.etOpenSquare)\n          this.DoSquare(0, 1);\n        else\n          this.DoRound(0, 1);\n      }\n      this.m_destPolys.push(this.m_destPoly);\n    }\n  }\n};\n\nClipperLib.ClipperOffset.prototype.Execute = function ()\n{\n  var a = arguments,\n    ispolytree = a[0] instanceof ClipperLib.PolyTree;\n  if (!ispolytree) // function (solution, delta)\n  {\n    var solution = a[0],\n      delta = a[1];\n    ClipperLib.Clear(solution);\n    this.FixOrientations();\n    this.DoOffset(delta);\n    //now clean up 'corners' ...\n    var clpr = new ClipperLib.Clipper(0);\n    clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n    if (delta > 0)\n    {\n      clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n    }\n    else\n    {\n      var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n      var outer = new ClipperLib.Path();\n      outer.push(new ClipperLib.FPoint2(r.left - 10, r.bottom + 10));\n      outer.push(new ClipperLib.FPoint2(r.right + 10, r.bottom + 10));\n      outer.push(new ClipperLib.FPoint2(r.right + 10, r.top - 10));\n      outer.push(new ClipperLib.FPoint2(r.left - 10, r.top - 10));\n      clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n      clpr.ReverseSolution = true;\n      clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n      if (solution.length > 0)\n        solution.splice(0, 1);\n    }\n    //console.log(JSON.stringify(solution));\n  }\n  else // function (polytree, delta)\n  {\n    var solution = a[0],\n      delta = a[1];\n    solution.Clear();\n    this.FixOrientations();\n    this.DoOffset(delta);\n    //now clean up 'corners' ...\n    var clpr = new ClipperLib.Clipper(0);\n    clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n    if (delta > 0)\n    {\n      clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n    }\n    else\n    {\n      var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n      var outer = new ClipperLib.Path();\n      outer.push(new ClipperLib.FPoint2(r.left - 10, r.bottom + 10));\n      outer.push(new ClipperLib.FPoint2(r.right + 10, r.bottom + 10));\n      outer.push(new ClipperLib.FPoint2(r.right + 10, r.top - 10));\n      outer.push(new ClipperLib.FPoint2(r.left - 10, r.top - 10));\n      clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n      clpr.ReverseSolution = true;\n      clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n      //remove the outer PolyNode rectangle ...\n      if (solution.ChildCount() === 1 && solution.Childs()[0].ChildCount() > 0)\n      {\n        var outerNode = solution.Childs()[0];\n        //solution.Childs.set_Capacity(outerNode.ChildCount);\n        solution.Childs()[0] = outerNode.Childs()[0];\n        solution.Childs()[0].m_Parent = solution;\n        for (var i = 1; i < outerNode.ChildCount(); i++)\n          solution.AddChild(outerNode.Childs()[i]);\n      }\n      else\n        solution.Clear();\n    }\n  }\n};\n\nClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype)\n{\n  //cross product ...\n  this.m_sinA = (this.m_normals[k][0] * this.m_normals[j][1] - this.m_normals[j][0] * this.m_normals[k][1]);\n\n  if (this.m_sinA === 0)\n  {\n    return k;\n  }\n\n\n  else if (this.m_sinA < 0.00005 && this.m_sinA > -0.00005)\n\n    console.log(this.m_sinA);\n    return k;\n\n\n\n  if (Math.abs(this.m_sinA * this.m_delta) < 1.0)\n  {\n    //dot product ...\n    var cosA = (this.m_normals[k][0] * this.m_normals[j][0] + this.m_normals[j][1] * this.m_normals[k][1]);\n    if (cosA > 0) // angle ==> 0 degrees\n    {\n      this.m_destPoly.push(new ClipperLib.FPoint2(this.m_srcPoly[j][0] + this.m_normals[k][0] * this.m_delta,\n        this.m_srcPoly[j][1] + this.m_normals[k][1] * this.m_delta));\n      return k;\n    }\n    //else angle ==> 180 degrees\n  }\n\n  else if (this.m_sinA > 1)\n    this.m_sinA = 1.0;\n  else if (this.m_sinA < -1)\n    this.m_sinA = -1.0;\n  if (this.m_sinA * this.m_delta < 0)\n  {\n    this.m_destPoly.push(new ClipperLib.FPoint2(this.m_srcPoly[j][0] + this.m_normals[k][0] * this.m_delta,\n      this.m_srcPoly[j][1] + this.m_normals[k][1] * this.m_delta));\n    this.m_destPoly.push(new ClipperLib.FPoint1(this.m_srcPoly[j]));\n    this.m_destPoly.push(new ClipperLib.FPoint2(this.m_srcPoly[j][0] + this.m_normals[j][0] * this.m_delta,\n      this.m_srcPoly[j][1] + this.m_normals[j][1] * this.m_delta));\n  }\n  else\n    switch (jointype)\n    {\n    case ClipperLib.JoinType.jtMiter:\n      {\n        var r = 1 + (this.m_normals[j][0] * this.m_normals[k][0] + this.m_normals[j][1] * this.m_normals[k][1]);\n        if (r >= this.m_miterLim)\n          this.DoMiter(j, k, r);\n        else\n          this.DoSquare(j, k);\n        break;\n      }\n    case ClipperLib.JoinType.jtSquare:\n      this.DoSquare(j, k);\n      break;\n    case ClipperLib.JoinType.jtRound:\n      this.DoRound(j, k);\n      break;\n    }\n  k = j;\n  return k;\n};\n\nClipperLib.ClipperOffset.prototype.DoSquare = function (j, k)\n{\n  var dx = Math.tan(Math.atan2(this.m_sinA,\n    this.m_normals[k][0] * this.m_normals[j][0] + this.m_normals[k][1] * this.m_normals[j][1]) / 4);\n  this.m_destPoly.push(new ClipperLib.FPoint2(\n    this.m_srcPoly[j][0] + this.m_delta * (this.m_normals[k][0] - this.m_normals[k][1] * dx),\n    this.m_srcPoly[j][1] + this.m_delta * (this.m_normals[k][1] + this.m_normals[k][0] * dx)));\n  this.m_destPoly.push(new ClipperLib.FPoint2(\n    this.m_srcPoly[j][0] + this.m_delta * (this.m_normals[j][0] + this.m_normals[j][1] * dx),\n    this.m_srcPoly[j][1] + this.m_delta * (this.m_normals[j][1] - this.m_normals[j][0] * dx)));\n};\n\nClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r)\n{\n  var q = this.m_delta / r;\n  this.m_destPoly.push(new ClipperLib.FPoint2(\n    this.m_srcPoly[j][0] + (this.m_normals[k][0] + this.m_normals[j][0]) * q,\n    this.m_srcPoly[j][1] + (this.m_normals[k][1] + this.m_normals[j][1]) * q));\n};\n\nClipperLib.ClipperOffset.prototype.DoRound = function (j, k)\n{\n  var a = Math.atan2(this.m_sinA,\n    this.m_normals[k][0] * this.m_normals[j][0] + this.m_normals[k][1] * this.m_normals[j][1]);\n\n  var steps = Math.max(Math.round(this.m_StepsPerRad * Math.abs(a)), 1);\n\n  var X = this.m_normals[k][0],\n    Y = this.m_normals[k][1],\n    X2;\n  for (var i = 0; i < steps; ++i)\n  {\n    this.m_destPoly.push(new ClipperLib.FPoint2(\n      this.m_srcPoly[j][0] + X * this.m_delta,\n      this.m_srcPoly[j][1] + Y * this.m_delta));\n    X2 = X;\n    X = X * this.m_cos - this.m_sin * Y;\n    Y = X2 * this.m_sin + Y * this.m_cos;\n  }\n  this.m_destPoly.push(new ClipperLib.FPoint2(\n    this.m_srcPoly[j][0] + this.m_normals[j][0] * this.m_delta,\n    this.m_srcPoly[j][1] + this.m_normals[j][1] * this.m_delta));\n};\n\nClipperLib.Error = function (message)\n{\n  try\n  {\n    throw new Error(message);\n  }\n  catch (err)\n  {\n    alert(err.message);\n  }\n};\n\n// ---------------------------------------------\n\n// JS extension by Timo 2013\nClipperLib.JS = {};\n\nClipperLib.JS.AreaOfPolygon = function (poly)\n{\n  return ClipperLib.Clipper.Area(poly);\n};\n\nClipperLib.JS.AreaOfPolygons = function (poly)\n{\n  var area = 0;\n  for (var i = 0; i < poly.length; i++)\n  {\n    area += ClipperLib.Clipper.Area(poly[i]);\n  }\n  return area;\n};\n\nClipperLib.JS.BoundsOfPath = function (path)\n{\n  return ClipperLib.JS.BoundsOfPaths([path]);\n};\n\nClipperLib.JS.BoundsOfPaths = function (paths)\n{\n  var bounds = ClipperLib.Clipper.GetBounds(paths);\n  return bounds;\n};\n\n// Clean() joins vertices that are too near each other\n// and causes distortion to offsetted polygons without cleaning\nClipperLib.JS.Clean = function (polygon, delta)\n{\n  if (!(polygon instanceof Array)) return [];\n  var isPolygons = polygon[0] instanceof Array;\n  var polygon = ClipperLib.JS.Clone(polygon);\n  if (typeof delta !== \"number\" || delta === null)\n  {\n    ClipperLib.Error(\"Delta is not a number in Clean().\");\n    return polygon;\n  }\n  if (polygon.length === 0 || (polygon.length === 1 && polygon[0].length === 0) || delta < 0) return polygon;\n  if (!isPolygons) polygon = [polygon];\n  var k_length = polygon.length;\n  var len, poly, result, d, p, j, i;\n  var results = [];\n  for (var k = 0; k < k_length; k++)\n  {\n    poly = polygon[k];\n    len = poly.length;\n    if (len === 0) continue;\n    else if (len < 3)\n    {\n      result = poly;\n      results.push(result);\n      continue;\n    }\n    result = poly;\n    d = delta * delta;\n    //d = Math.floor(c_delta * c_delta);\n    p = poly[0];\n    j = 1;\n    for (i = 1; i < len; i++)\n    {\n      if ((poly[i][0] - p[0]) * (poly[i][0] - p[0]) +\n        (poly[i][1] - p[1]) * (poly[i][1] - p[1]) <= d)\n        continue;\n      result[j] = poly[i];\n      p = poly[i];\n      j++;\n    }\n    p = poly[j - 1];\n    if ((poly[0][0] - p[0]) * (poly[0][0] - p[0]) +\n      (poly[0][1] - p[1]) * (poly[0][1] - p[1]) <= d)\n      j--;\n    if (j < len)\n      result.splice(j, len - j);\n    if (result.length) results.push(result);\n  }\n  if (!isPolygons && results.length) results = results[0];\n  else if (!isPolygons && results.length === 0) results = [];\n  else if (isPolygons && results.length === 0) results = [\n    []\n  ];\n  return results;\n}\n// Make deep copy of Polygons or Polygon\n// so that also FPoint objects are cloned and not only referenced\n// This should be the fastest way\nClipperLib.JS.Clone = function (polygon)\n{\n  if (!(polygon instanceof Array)) return [];\n  if (polygon.length === 0) return [];\n  else if (polygon.length === 1 && polygon[0].length === 0) return [\n    []\n  ];\n  var isPolygons = polygon[0] instanceof Array;\n  if (!isPolygons) polygon = [polygon];\n  var len = polygon.length,\n    plen, i, j, result;\n  var results = new Array(len);\n  for (i = 0; i < len; i++)\n  {\n    plen = polygon[i].length;\n    result = new Array(plen);\n    for (j = 0; j < plen; j++)\n    {\n      result[j] = {\n        X: polygon[i][j][0],\n        Y: polygon[i][j][1]\n      };\n\n    }\n    results[i] = result;\n  }\n  if (!isPolygons) results = results[0];\n  return results;\n};\n\n// Removes points that doesn't affect much to the visual appearance.\n// If middle point is at or under certain distance (tolerance) of the line segment between\n// start and end point, the middle point is removed.\nClipperLib.JS.Lighten = function (polygon, tolerance)\n{\n  if (!(polygon instanceof Array)) return [];\n  if (typeof tolerance !== \"number\" || tolerance === null)\n  {\n    ClipperLib.Error(\"Tolerance is not a number in Lighten().\")\n    return ClipperLib.JS.Clone(polygon);\n  }\n  if (polygon.length === 0 || (polygon.length === 1 && polygon[0].length === 0) || tolerance < 0)\n  {\n    return ClipperLib.JS.Clone(polygon);\n  }\n  var isPolygons = polygon[0] instanceof Array;\n  if (!isPolygons) polygon = [polygon];\n  var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;\n  var bxax, byay, l, ax, ay;\n  var len = polygon.length;\n  var toleranceSq = tolerance * tolerance;\n  var results = [];\n  for (i = 0; i < len; i++)\n  {\n    poly = polygon[i];\n    plen = poly.length;\n    if (plen === 0) continue;\n    for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count\n    {\n      poly2 = [];\n      plen = poly.length;\n      // the first have to added to the end, if first and last are not the same\n      // this way we ensure that also the actual last point can be removed if needed\n      if (poly[plen - 1][0] !== poly[0][0] || poly[plen - 1][1] !== poly[0][1])\n      {\n        addlast = 1;\n        poly.push(\n        {\n          X: poly[0][0],\n          Y: poly[0][1]\n        });\n        plen = poly.length;\n      }\n      else addlast = 0;\n      rem = []; // Indexes of removed points\n      for (j = 0; j < plen - 2; j++)\n      {\n        A = poly[j]; // Start point of line segment\n        P = poly[j + 1]; // Middle point. This is the one to be removed.\n        B = poly[j + 2]; // End point of line segment\n        ax = A[0];\n        ay = A[1];\n        bxax = B[0] - ax;\n        byay = B[1] - ay;\n        if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.\n        {\n          l = ((P[0] - ax) * bxax + (P[1] - ay) * byay) / (bxax * bxax + byay * byay);\n          if (l > 1)\n          {\n            ax = B[0];\n            ay = B[1];\n          }\n          else if (l > 0)\n          {\n            ax += bxax * l;\n            ay += byay * l;\n          }\n        }\n        bxax = P[0] - ax;\n        byay = P[1] - ay;\n        d = bxax * bxax + byay * byay;\n        if (d <= toleranceSq)\n        {\n          rem[j + 1] = 1;\n          j++; // when removed, transfer the pointer to the next one\n        }\n      }\n      // add all unremoved points to poly2\n      poly2.push(\n      {\n        X: poly[0][0],\n        Y: poly[0][1]\n      });\n      for (j = 1; j < plen - 1; j++)\n        if (!rem[j]) poly2.push(\n        {\n          X: poly[j][0],\n          Y: poly[j][1]\n        });\n      poly2.push(\n      {\n        X: poly[plen - 1][0],\n        Y: poly[plen - 1][1]\n      });\n      // if the first point was added to the end, remove it\n      if (addlast) poly.pop();\n      // break, if there was not anymore removed points\n      if (!rem.length) break;\n      // else continue looping using poly2, to check if there are points to remove\n      else poly = poly2;\n    }\n    plen = poly2.length;\n    // remove duplicate from end, if needed\n    if (poly2[plen - 1][0] === poly2[0][0] && poly2[plen - 1][1] === poly2[0][1])\n    {\n      poly2.pop();\n    }\n    if (poly2.length > 2) // to avoid two-point-polygons\n      results.push(poly2);\n  }\n  if (!isPolygons)\n  {\n    results = results[0];\n  }\n  if (typeof (results) === \"undefined\")\n  {\n    results = [];\n  }\n  return results;\n}\n\nClipperLib.JS.PerimeterOfPath = function (path, closed)\n{\n  if (typeof (path) === \"undefined\") return 0;\n  var sqrt = Math.sqrt;\n  var perimeter = 0.0;\n  var p1, p2, p1x = 0.0,\n    p1y = 0.0,\n    p2x = 0.0,\n    p2y = 0.0;\n  var j = path.length;\n  if (j < 2) return 0;\n  if (closed)\n  {\n    path[j] = path[0];\n    j++;\n  }\n  while (--j)\n  {\n    p1 = path[j];\n    p1x = p1[0];\n    p1y = p1[1];\n    p2 = path[j - 1];\n    p2x = p2[0];\n    p2y = p2[1];\n    perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));\n  }\n  if (closed) path.pop();\n  return perimeter;\n};\n\nClipperLib.JS.PerimeterOfPaths = function (paths, closed)\n{\n  var perimeter = 0;\n  for (var i = 0; i < paths.length; i++)\n  {\n    perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed);\n  }\n  return perimeter;\n};\n\n/**\n* @constructor\n*/\nClipperLib.ExPolygons = function ()\n{\n  return [];\n}\n/**\n* @constructor\n*/\nClipperLib.ExPolygon = function ()\n{\n  this.outer = null;\n  this.holes = null;\n};\n\nClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons)\n{\n  var ep = new ClipperLib.ExPolygon();\n  ep.outer = polynode.Contour();\n  var childs = polynode.Childs();\n  var ilen = childs.length;\n  ep.holes = new Array(ilen);\n  var node, n, i, j, childs2, jlen;\n  for (i = 0; i < ilen; i++)\n  {\n    node = childs[i];\n    ep.holes[i] = node.Contour();\n    //Add outer polygons contained by (nested within) holes ...\n    for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++)\n    {\n      n = childs2[j];\n      ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);\n    }\n  }\n  expolygons.push(ep);\n};\n\nClipperLib.JS.ExPolygonsToPaths = function (expolygons)\n{\n  var a, i, alen, ilen;\n  var paths = new ClipperLib.Paths();\n  for (a = 0, alen = expolygons.length; a < alen; a++)\n  {\n    paths.push(expolygons[a].outer);\n    for (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++)\n    {\n      paths.push(expolygons[a].holes[i]);\n    }\n  }\n  return paths;\n}\nClipperLib.JS.PolyTreeToExPolygons = function (polytree)\n{\n  var expolygons = new ClipperLib.ExPolygons();\n  var node, i, childs, ilen;\n  for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++)\n  {\n    node = childs[i];\n    ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);\n  }\n  return expolygons;\n};\n\nmodule.exports = ClipperLib;\n"],"names":["ClipperLib","version","use_lines","use_xyz","Inherit","ce","ce2","p","Object","getOwnPropertyNames","prototype","$baseCtor","props","i","length","getOwnPropertyDescriptor","defineProperty","Path","push","Array","Paths","PolyNode","this","m_Parent","m_polygon","m_Index","m_jointype","m_endtype","m_Childs","IsOpen","IsHoleNode","result","node","ChildCount","Contour","AddChild","Child","cnt","GetNext","GetNextSiblingUp","Childs","Parent","IsHole","PolyTree","m_AllPolys","call","Clear","ilen","GetFirst","Total","a","PI","PI2","FPoint","arguments","alen","Z","dp","pt","op_Equality","b","op_Inequality","FPoint0","FPoint1","FPoint1dp","FPoint2","x","y","z","FRect","left","top","right","bottom","ir","FRect0","FRect1","FRect4","l","t","r","ClipType","ctIntersection","ctUnion","ctDifference","ctXor","PolyType","ptSubject","ptClip","PolyFillType","pftEvenOdd","pftNonZero","pftPositive","pftNegative","JoinType","jtSquare","jtRound","jtMiter","EndType","etOpenSquare","etOpenRound","etOpenButt","etClosedLine","etClosedPolygon","EdgeSide","esLeft","esRight","Direction","dRightToLeft","dLeftToRight","TEdge","Bot","Curr","Top","Delta","Dx","PolyTyp","Side","WindDelta","WindCnt","WindCnt2","OutIdx","Next","Prev","NextInLML","NextInAEL","PrevInAEL","NextInSEL","PrevInSEL","IntersectNode","Edge1","Edge2","Pt","MyIntersectNodeSort","Compare","node1","node2","LocalMinima","LeftBound","RightBound","Scanbeam","Maxima","OutRec","Idx","FirstLeft","Pts","BottomPt","OutPt","Join","OutPt1","OutPt2","OffPt","ClipperBase","m_MinimaList","m_CurrentLM","m_edges","m_HasOpenPaths","PreserveCollinear","m_Scanbeam","m_PolyOuts","m_ActiveEdges","horizontal","Skip","Unassigned","tolerance","maxValue","Math","sqrt","Number","MAX_VALUE","minValue","MIN_VALUE","near_zero","val","IsHorizontal","e","PointIsVertex","pp","pp2","PointOnLineSegment","linePt1","linePt2","PointOnPolygon","SlopesEqual","e1","e2","pt1","pt2","pt3","pt4","SlopesEqual3","SlopesEqual4","SlopesEqual5","DisposeLocalMinimaList","j","jlen","tmpLm","RangeTest","Error","InitEdge","eNext","ePrev","InitEdge2","polyType","SetDx","FindNextLocMin","E","E2","ProcessBound","LeftBoundIsForward","EStart","Horz","Result","locMin","InsertLocalMinima","ReverseHorizontal","AddPath","pg","Closed","highI","edges","IsFlat","leftBoundIsForward","eStart","eLoopStop","Pt2IsBetweenPt1AndPt3","RemoveEdge","EMin","AddPaths","ppg","closed","newLm","PopLocalMinima","Y","current","v","tmp","Reset","lm","InsertScanbeam","newSb","sb2","newSb1","PopScanbeam","LocalMinimaPending","CreateOutRec","DisposeOutRec","index","outRec","UpdateEdgeIntoAEL","AelPrev","AelNext","SwapPositionsInAEL","edge1","edge2","next","prev","next1","prev1","next2","prev2","DeleteFromAEL","Clipper","InitOptions","m_ClipType","m_Maxima","m_SortedEdges","m_IntersectList","m_IntersectNodeComparer","m_ExecuteLocked","m_ClipFillType","m_SubjFillType","m_Joins","m_GhostJoins","m_UsingPolyTree","ReverseSolution","StrictlySimple","ZFillFunction","ioReverseSolution","ioStrictlySimple","ioPreserveCollinear","DisposeAllPolyPts","InsertMaxima","X","newMax","m","Execute","ispolytree","clipType","solution","subjFillType","clipFillType","succeeded","ExecuteInternal","BuildResult","polytree","BuildResult2","FixHoleLinkage","orfl","botY","topY","InsertLocalMinimaIntoAEL","ProcessHorizontals","ProcessIntersections","ProcessEdgesAtTopOfScanbeam","Area$1","ReversePolyPtLinks","JoinCommonEdges","FixupOutPolyline","FixupOutPolygon","DoSimplePolygons","AddJoin","Op1","Op2","AddGhostJoin","Op","SetZ","lb","rb","InsertEdgeIntoAEL","SetWindingCount","IsContributing","AddOutPt","AddLocalMinPoly","AddEdgeToSEL","HorzSegmentsOverlap","IntersectEdges","edge","startEdge","E2InsertsBeforeE1","TopX","IsEvenOddFillType","IsEvenOddAltFillType","pft","pft2","abs","Inside","PopEdgeFromSEL","oldE","CopyAELToSEL","SwapPositionsInSEL","AddLocalMaxPoly","AppendPolygon","prevE","xPrev","xE","outPt","newOp","SetHoleState","op","ToFront","GetLastOutPt","SwapPoints","Value","seg1a","seg1b","seg2a","seg2b","eTmp","GetDx","FirstIsBottomPt","btmPt1","btmPt2","dx1p","dx1n","dx2p","dx2n","max","min","Area","GetBottomPt","dups","GetLowermostRec","outRec1","outRec2","bPt1","bPt2","OutRec1RightOfOutRec2","GetOutRec","idx","outrec","holeStateRec","p1_lft","p1_rt","p2_lft","p2_rt","OKIdx","ObsoleteIdx","pp1","SwapSides","side","SwapPolyIndexes","outIdx","e1Contributing","e2Contributing","oldE1WindCnt","e1FillType","e2FillType","e1FillType2","e2FillType2","e1Wc","e2Wc","e1Wc2","e2Wc2","DeleteFromSEL","SelPrev","SelNext","horzEdge","ProcessHorizontal","GetHorzDirection","HorzEdge","$var","Left","Right","Dir","dir","horzLeft","horzRight","eLastHorz","eMaxPair","GetMaximaPair","currMax","op1","IsLastHorz","GetNextInAEL","eNextHorz","op2","IsMinima","IsMaxima","IsIntermediate","GetMaximaPairEx","BuildIntersectList","FixupIntersectionOrder","ProcessIntersectList","$$e2","isModified","IntersectPoint","newNode","EdgesAdjacent","inode","IntersectNodeSort","sort","iNode","currentY","ip","b1","b2","q","IsMaximaEdge","DoMaxima","ePrev2","ReversePaths","polys","len","reverse","Orientation","poly","PointCount","pts","polyg","pn","lastPP","tmpPP","lastOK","preserveCol","DupOutPt","InsertAfter","GetOverlap","a1","a2","$val","JoinHorz","op1b","op2b","DiscardLeft","Dir1","Dir2","JoinPoints","isHorizontal","reverse1","DiscardLeftSide","Reverse1","Reverse2","GetBounds","paths","GetBounds2","ops","opStart","PointInPolygon","path","ipNext","d","startOp","ptx","pty","poly0x","poly0y","poly1x","poly1y","Poly2ContainsPoly1","outPt1","outPt2","res","FixupFirstLefts1","OldOutRec","NewOutRec","firstLeft","ParseFirstLeft","FixupFirstLefts2","innerOutRec","outerOutRec","FixupFirstLefts3","join","UpdateOutPtIdxs","op3","op4","outrec2","isArray","opFirst","SimplifyPolygon","fillType","c","SimplifyPolygons","DistanceSqrd","dx","dy","DistanceFromLineSqrd","ln1","ln2","A","B","C","SlopesNearCollinear","distSqrd","PointsAreClose","ExcludeOp","CleanPolygon","distance","outPts","CleanPolygons","Minkowski","pattern","IsSum","IsClosed","delta","polyCnt","pathCnt","quads","quad","MinkowskiSum","path_or_paths","pathIsClosed","TranslatePath","outPath","MinkowskiDiff","poly1","poly2","PolyTreeToPaths","AddPolyNodeToPaths","NodeType","ntAny","polynode","nt","match","ntOpen","ntClosed","$i3","$t3","$l3","OpenPathsFromPolyTree","ClosedPathsFromPolyTree","ClipperOffset","miterLimit","arcTolerance","def_arc_tolerance","m_destPolys","m_srcPoly","m_destPoly","m_normals","m_delta","m_sinA","m_sin","m_cos","m_miterLim","m_StepsPerRad","m_lowest","m_polyNodes","MiterLimit","ArcTolerance","two_pi","joinType","endType","k","FixOrientations","GetUnitNormal","f","DoOffset","steps","acos","sin","cos","OffsetPoint","n","DoSquare","DoRound","X2","clpr","outer","outerNode","splice","jointype","console","log","tan","atan2","DoMiter","round","message","err","alert","JS","AreaOfPolygon","AreaOfPolygons","area","BoundsOfPath","BoundsOfPaths","Clean","polygon","isPolygons","Clone","k_length","results","plen","Lighten","P","rem","addlast","bxax","byay","ax","ay","toleranceSq","pop","PerimeterOfPath","p1","p2","perimeter","p1x","p1y","p2x","p2y","PerimeterOfPaths","ExPolygons","ExPolygon","holes","AddOuterPolyNodeToExPolygons","expolygons","ep","childs2","childs","ExPolygonsToPaths","PolyTreeToExPolygons","module","exports"],"mappings":"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"}