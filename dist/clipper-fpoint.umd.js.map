{"version":3,"file":"clipper-fpoint.umd.js","sources":["../src/clipper_unminified.js"],"sourcesContent":["/*******************************************************************************\n *                                                                              *\n * Author    :  Angus Johnson                                                   *\n * Version   :  6.4.2                                                           *\n * Date      :  27 February 2017                                                *\n * Website   :  http://www.angusj.com                                           *\n * Copyright :  Angus Johnson 2010-2017                                         *\n *                                                                              *\n * License:                                                                     *\n * Use, modification & distribution is subject to Boost Software License Ver 1. *\n * http://www.boost.org/LICENSE_1_0.txt                                         *\n *                                                                              *\n * Attributions:                                                                *\n * The code in this library is an extension of Bala Vatti's clipping algorithm: *\n * \"A generic solution to polygon clipping\"                                     *\n * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n * http://portal.acm.org/citation.cfm?id=129906                                 *\n *                                                                              *\n * Computer graphics and geometric modeling: implementation and algorithms      *\n * By Max K. Agoston                                                            *\n * Springer; 1 edition (January 4, 2005)                                        *\n * http://books.google.com/books?q=vatti+clipping+agoston                       *\n *                                                                              *\n * See also:                                                                    *\n * \"Polygon Offsetting by Computing Winding Numbers\"                            *\n * Paper no. DETC2005-85513 pp. 565-575                                         *\n * ASME 2005 International Design Engineering Technical Conferences             *\n * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n * September 24-28, 2005 , Long Beach, California, USA                          *\n * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Author    :  Timo                                                            *\n * Version   :  6.4.2.2 (FPoint)                                                *\n * Date      :  8 September 2017                                                *\n *                                                                              *\n * This is a translation of the C# Clipper library to Javascript.               *\n *                                                                              *\n *******************************************************************************/\n\nvar ClipperLib = {};\nClipperLib.version = '6.4.2.2';\n\n//UseLines: Enables open path clipping. Adds a very minor cost to performance.\nClipperLib.use_lines = false;\n\n// Here starts the actual Clipper library:\n// Helper function to support Inheritance in Javascript\nvar Inherit = function (ce, ce2) {\n  var p;\n  if (typeof (Object.getOwnPropertyNames) === 'undefined') {\n    for (p in ce2.prototype)\n      if (typeof (ce.prototype[p]) === 'undefined' || ce.prototype[p] === Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];\n    for (p in ce2)\n      if (typeof (ce[p]) === 'undefined') ce[p] = ce2[p];\n    ce.$baseCtor = ce2;\n  } else {\n    var props = Object.getOwnPropertyNames(ce2.prototype);\n    for (var i = 0; i < props.length; i++)\n      if (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) === 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));\n    for (p in ce2)\n      if (typeof (ce[p]) === 'undefined') ce[p] = ce2[p];\n    ce.$baseCtor = ce2;\n  }\n};\n\n/**\n * @constructor\n */\nClipperLib.Path = function () {\n  return [];\n};\n\nClipperLib.Path.prototype.push = Array.prototype.push;\n\n/**\n * @constructor\n */\nClipperLib.Paths = function () {\n  return []; // Was previously [[]], but caused problems when pushed\n};\n\nClipperLib.Paths.prototype.push = Array.prototype.push;\n\n// PolyTree & PolyNode start\n/**\n * @suppress {missingProperties}\n */\nClipperLib.PolyNode = function () {\n  this.m_Parent = null;\n  this.m_polygon = new ClipperLib.Path();\n  this.m_Index = 0;\n  this.m_jointype = 0;\n  this.m_endtype = 0;\n  this.m_Childs = [];\n  this.IsOpen = false;\n};\n\nClipperLib.PolyNode.prototype.IsHoleNode = function () {\n  var result = true;\n  var node = this.m_Parent;\n  while (node !== null) {\n    result = !result;\n    node = node.m_Parent;\n  }\n  return result;\n};\n\nClipperLib.PolyNode.prototype.ChildCount = function () {\n  return this.m_Childs.length;\n};\n\nClipperLib.PolyNode.prototype.Contour = function () {\n  return this.m_polygon;\n};\n\nClipperLib.PolyNode.prototype.AddChild = function (Child) {\n  var cnt = this.m_Childs.length;\n  this.m_Childs.push(Child);\n  Child.m_Parent = this;\n  Child.m_Index = cnt;\n};\n\nClipperLib.PolyNode.prototype.GetNext = function () {\n  if (this.m_Childs.length > 0)\n    return this.m_Childs[0];\n  else\n    return this.GetNextSiblingUp();\n};\n\nClipperLib.PolyNode.prototype.GetNextSiblingUp = function () {\n  if (this.m_Parent === null)\n    return null;\n  else if (this.m_Index === this.m_Parent.m_Childs.length - 1)\n    return this.m_Parent.GetNextSiblingUp();\n  else\n    return this.m_Parent.m_Childs[this.m_Index + 1];\n};\n\nClipperLib.PolyNode.prototype.Childs = function () {\n  return this.m_Childs;\n};\n\nClipperLib.PolyNode.prototype.Parent = function () {\n  return this.m_Parent;\n};\n\nClipperLib.PolyNode.prototype.IsHole = function () {\n  return this.IsHoleNode();\n};\n\n// PolyTree : PolyNode\n/**\n * @suppress {missingProperties}\n * @constructor\n */\nClipperLib.PolyTree = function () {\n  this.m_AllPolys = [];\n  ClipperLib.PolyNode.call(this);\n};\n\nClipperLib.PolyTree.prototype.Clear = function () {\n  for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)\n    this.m_AllPolys[i] = null;\n  this.m_AllPolys.length = 0;\n  this.m_Childs.length = 0;\n};\n\nClipperLib.PolyTree.prototype.GetFirst = function () {\n  if (this.m_Childs.length > 0)\n    return this.m_Childs[0];\n  else\n    return null;\n};\n\nClipperLib.PolyTree.prototype.Total = function () {\n  var result = this.m_AllPolys.length;\n  //with negative offsets, ignore the hidden outer polygon ...\n  if (result > 0 && this.m_Childs[0] !== this.m_AllPolys[0]) result--;\n  return result;\n};\n\nInherit(ClipperLib.PolyTree, ClipperLib.PolyNode);\n\n// PolyTree & PolyNode end\n\nClipperLib.Clear = function (a) {\n  a.length = 0;\n};\n\n//ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function\nClipperLib.PI = 3.141592653589793;\nClipperLib.PI2 = 2 * 3.141592653589793;\n/**\n * @constructor\n */\nClipperLib.FPoint_op_Equality = function (a, b) {\n  //return a == b;\n  return a[0] === b[0] && a[1] === b[1];\n};\n\nClipperLib.FPoint_op_Inequality = function (a, b) {\n  //return a !== b;\n  return a[0] !== b[0] || a[1] !== b[1];\n};\n\n/**\n * @constructor\n */\nClipperLib.FRect = function () {\n  var a = arguments,\n    alen = a.length;\n  if (alen === 4) // function (l, t, r, b)\n  {\n    this.left = a[0];\n    this.top = a[1];\n    this.right = a[2];\n    this.bottom = a[3];\n  } else if (alen === 1) // function (ir)\n  {\n    var ir = a[0];\n    this.left = ir.left;\n    this.top = ir.top;\n    this.right = ir.right;\n    this.bottom = ir.bottom;\n  } else // function ()\n  {\n    this.left = 0;\n    this.top = 0;\n    this.right = 0;\n    this.bottom = 0;\n  }\n};\n\n/**\n * @constructor\n */\nClipperLib.FRect0 = function () {\n  this.left = 0;\n  this.top = 0;\n  this.right = 0;\n  this.bottom = 0;\n};\n\nClipperLib.FRect0.prototype = ClipperLib.FRect.prototype;\n\n/**\n * @constructor\n */\nClipperLib.FRect1 = function (ir) {\n  this.left = ir.left;\n  this.top = ir.top;\n  this.right = ir.right;\n  this.bottom = ir.bottom;\n};\n\nClipperLib.FRect1.prototype = ClipperLib.FRect.prototype;\n\n/**\n * @constructor\n */\nClipperLib.FRect4 = function (l, t, r, b) {\n  this.left = l;\n  this.top = t;\n  this.right = r;\n  this.bottom = b;\n};\n\nClipperLib.FRect4.prototype = ClipperLib.FRect.prototype;\n\nClipperLib.ClipType = {\n  ctIntersection: 0,\n  ctUnion: 1,\n  ctDifference: 2,\n  ctXor: 3\n};\n\nClipperLib.PolyType = {\n  ptSubject: 0,\n  ptClip: 1\n};\n\nClipperLib.PolyFillType = {\n  pftEvenOdd: 0,\n  pftNonZero: 1,\n  pftPositive: 2,\n  pftNegative: 3\n};\n\nClipperLib.JoinType = {\n  jtSquare: 0,\n  jtRound: 1,\n  jtMiter: 2\n};\n\nClipperLib.EndType = {\n  etOpenSquare: 0,\n  etOpenRound: 1,\n  etOpenButt: 2,\n  etClosedLine: 3,\n  etClosedPolygon: 4\n};\n\nClipperLib.EdgeSide = {\n  esLeft: 0,\n  esRight: 1\n};\n\nClipperLib.Direction = {\n  dRightToLeft: 0,\n  dLeftToRight: 1\n};\n\n/**\n * @constructor\n */\nClipperLib.TEdge = function () {\n  this.Bot = [0, 0];\n  this.Curr = [0, 0]; //current (updated for every new scanbeam)\n  this.Top = [0, 0];\n  this.Delta = [0, 0];\n  this.Dx = 0;\n  this.PolyTyp = ClipperLib.PolyType.ptSubject;\n  this.Side = ClipperLib.EdgeSide.esLeft; //side only refers to current side of solution poly\n  this.WindDelta = 0; //1 or -1 depending on winding direction\n  this.WindCnt = 0;\n  this.WindCnt2 = 0; //winding count of the opposite polytype\n  this.OutIdx = 0;\n  this.Next = null;\n  this.Prev = null;\n  this.NextInLML = null;\n  this.NextInAEL = null;\n  this.PrevInAEL = null;\n  this.NextInSEL = null;\n  this.PrevInSEL = null;\n};\n\n/**\n * @constructor\n */\nClipperLib.IntersectNode = function () {\n  this.Edge1 = null;\n  this.Edge2 = null;\n  this.Pt = [0, 0];\n};\n\nClipperLib.MyIntersectNodeSort = function () {};\n\nClipperLib.MyIntersectNodeSort.Compare = function (node1, node2) {\n  var i = node2.Pt[1] - node1.Pt[1];\n  if (i > 0) return 1;\n  else if (i < 0) return -1;\n  else return 0;\n};\n\n/**\n * @constructor\n */\nClipperLib.LocalMinima = function () {\n  this[1] = 0;\n  this.LeftBound = null;\n  this.RightBound = null;\n  this.Next = null;\n};\n\n/**\n * @constructor\n */\nClipperLib.Scanbeam = function () {\n  this[1] = 0;\n  this.Next = null;\n};\n\n/**\n * @constructor\n */\nClipperLib.Maxima = function () {\n  this[0] = 0;\n  this.Next = null;\n  this.Prev = null;\n};\n\n//OutRec: contains a path in the clipping solution. Edges in the AEL will\n//carry a pointer to an OutRec when they are part of the clipping solution.\n/**\n * @constructor\n */\nClipperLib.OutRec = function () {\n  this.Idx = 0;\n  this.IsHole = false;\n  this.IsOpen = false;\n  this.FirstLeft = null; //see comments in clipper.pas\n  this.Pts = null;\n  this.BottomPt = null;\n  this.PolyNode = null;\n};\n\n/**\n * @constructor\n */\nClipperLib.OutPt = function () {\n  this.Idx = 0;\n  this.Pt = [0, 0];\n  this.Next = null;\n  this.Prev = null;\n};\n\n/**\n * @constructor\n */\nClipperLib.Join = function () {\n  this.OutPt1 = null;\n  this.OutPt2 = null;\n  this.OffPt = [0, 0];\n};\n\nClipperLib.ClipperBase = function () {\n  this.m_MinimaList = null;\n  this.m_CurrentLM = null;\n  this.m_edges = new Array();\n  this.m_HasOpenPaths = false;\n  this.PreserveCollinear = false;\n  this.m_Scanbeam = null;\n  this.m_PolyOuts = null;\n  this.m_ActiveEdges = null;\n};\n\nClipperLib.ClipperBase.horizontal = -3.4E+38;\nClipperLib.ClipperBase.Skip = -2;\nClipperLib.ClipperBase.Unassigned = -1;\nClipperLib.ClipperBase.tolerance = 1E-20;\n\n// The MAX_VALUE property has a value of 1.7976931348623157e+308. Values larger than MAX_VALUE are represented as \"Infinity\".\n//MIN_VALUE has a value of 5e-324. Values smaller than MIN_VALUE (\"underflow values\") are converted to 0.\nClipperLib.ClipperBase.maxValue = Math.sqrt(Number.MAX_VALUE); // 1.3407807929942596e+154\nClipperLib.ClipperBase.minValue = Math.sqrt(Number.MIN_VALUE); // 2.2227587494850775e-162\n\nClipperLib.ClipperBase.near_zero = function (val) {\n  return (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);\n};\n\nClipperLib.ClipperBase.IsHorizontal = function (e) {\n  return e.Delta[1] === 0;\n};\n\nClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp) {\n  var pp2 = pp;\n  do {\n    if (ClipperLib.FPoint_op_Equality(pp2.Pt, pt))\n      return true;\n    pp2 = pp2.Next;\n  }\n  while (pp2 !== pp)\n  return false;\n};\n\nClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2) {\n  return ((pt[0] === linePt1[0]) && (pt[1] === linePt1[1])) || ((pt[0] === linePt2[0]) && (pt[1] === linePt2[1])) || (((pt[0] > linePt1[0]) === (pt[0] < linePt2[0])) && ((pt[1] > linePt1[1]) === (pt[1] < linePt2[1])) && ((pt[0] - linePt1[0]) * (linePt2[1] - linePt1[1]) === (linePt2[0] - linePt1[0]) * (pt[1] - linePt1[1])));\n};\n\nClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp) {\n  var pp2 = pp;\n  while (true) {\n    if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt))\n      return true;\n    pp2 = pp2.Next;\n    if (pp2 === pp)\n      break;\n  }\n  return false;\n};\n\nClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function () {\n  var a = arguments,\n    alen = a.length;\n  var e1, e2, pt1, pt2, pt3, pt4;\n  if (alen === 2) // function (e1, e2)\n  {\n    e1 = a[0];\n    e2 = a[1];\n    return e1.Delta[1] * e2.Delta[0] === e1.Delta[0] * e2.Delta[1];\n  } else if (alen === 3) // function (pt1, pt2, pt3)\n  {\n    pt1 = a[0];\n    pt2 = a[1];\n    pt3 = a[2];\n    return (pt1[1] - pt2[1]) * (pt2[0] - pt3[0]) - (pt1[0] - pt2[0]) * (pt2[1] - pt3[1]) === 0;\n  } else // function (pt1, pt2, pt3, pt4)\n  {\n    pt1 = a[0];\n    pt2 = a[1];\n    pt3 = a[2];\n    pt4 = a[3];\n    return (pt1[1] - pt2[1]) * (pt3[0] - pt4[0]) - (pt1[0] - pt2[0]) * (pt3[1] - pt4[1]) === 0;\n  }\n};\n\nClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2) {\n  return e1.Delta[1] * e2.Delta[0] === e1.Delta[0] * e2.Delta[1];\n};\n\nClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3) {\n  return (pt1[1] - pt2[1]) * (pt2[0] - pt3[0]) - (pt1[0] - pt2[0]) * (pt2[1] - pt3[1]) === 0;\n};\n\nClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4) {\n  return (pt1[1] - pt2[1]) * (pt3[0] - pt4[0]) - (pt1[0] - pt2[0]) * (pt3[1] - pt4[1]) === 0;\n};\n\nClipperLib.ClipperBase.prototype.Clear = function () {\n  this.DisposeLocalMinimaList();\n  for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i) {\n    for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)\n      this.m_edges[i][j] = null;\n    ClipperLib.Clear(this.m_edges[i]);\n  }\n  ClipperLib.Clear(this.m_edges);\n  this.m_HasOpenPaths = false;\n};\n\nClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function () {\n  while (this.m_MinimaList !== null) {\n    var tmpLm = this.m_MinimaList.Next;\n    this.m_MinimaList = null;\n    this.m_MinimaList = tmpLm;\n  }\n  this.m_CurrentLM = null;\n};\n\nClipperLib.ClipperBase.prototype.RangeTest = function (pt) {\n  if (pt[0] > ClipperLib.ClipperBase.maxValue || pt[0] < -ClipperLib.ClipperBase.maxValue ||\n    pt[1] > ClipperLib.ClipperBase.maxValue || pt[1] < -ClipperLib.ClipperBase.maxValue ||\n    (pt[0] > 0 && pt[0] < ClipperLib.ClipperBase.minValue) ||\n    (pt[1] > 0 && pt[1] < ClipperLib.ClipperBase.minValue) ||\n    (pt[0] < 0 && pt[0] > -ClipperLib.ClipperBase.minValue) ||\n    (pt[1] < 0 && pt[1] > -ClipperLib.ClipperBase.minValue))\n    ClipperLib.Error(\"Coordinate outside allowed range in RangeTest().\");\n};\n\nClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt) {\n  e.Next = eNext;\n  e.Prev = ePrev;\n  //e.Curr = pt;\n  e.Curr[0] = pt[0];\n  e.Curr[1] = pt[1];\n  e.OutIdx = -1;\n};\n\nClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType) {\n  if (e.Curr[1] >= e.Next.Curr[1]) {\n    //e.Bot = e.Curr;\n    e.Bot[0] = e.Curr[0];\n    e.Bot[1] = e.Curr[1];\n    //e.Top = e.Next.Curr;\n    e.Top[0] = e.Next.Curr[0];\n    e.Top[1] = e.Next.Curr[1];\n  } else {\n    //e.Top = e.Curr;\n    e.Top[0] = e.Curr[0];\n    e.Top[1] = e.Curr[1];\n    //e.Bot = e.Next.Curr;\n    e.Bot[0] = e.Next.Curr[0];\n    e.Bot[1] = e.Next.Curr[1];\n  }\n  this.SetDx(e);\n  e.PolyTyp = polyType;\n};\n\nClipperLib.ClipperBase.prototype.FindNextLocMin = function (E) {\n  var E2;\n  for (;;) {\n    while (ClipperLib.FPoint_op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.FPoint_op_Equality(E.Curr, E.Top))\n      E = E.Next;\n    if (E.Dx !== ClipperLib.ClipperBase.horizontal && E.Prev.Dx !== ClipperLib.ClipperBase.horizontal)\n      break;\n    while (E.Prev.Dx === ClipperLib.ClipperBase.horizontal)\n      E = E.Prev;\n    E2 = E;\n    while (E.Dx === ClipperLib.ClipperBase.horizontal)\n      E = E.Next;\n    if (E.Top[1] === E.Prev.Bot[1])\n      continue;\n    //ie just an intermediate horz.\n    if (E2.Prev.Bot[0] < E.Bot[0])\n      E = E2;\n    break;\n  }\n  return E;\n};\n\nClipperLib.ClipperBase.prototype.ProcessBound = function (E, LeftBoundIsForward) {\n  var EStart;\n  var Result = E;\n  var Horz;\n\n  if (Result.OutIdx === ClipperLib.ClipperBase.Skip) {\n    //check if there are edges beyond the skip edge in the bound and if so\n    //create another LocMin and calling ProcessBound once more ...\n    E = Result;\n    if (LeftBoundIsForward) {\n      while (E.Top[1] === E.Next.Bot[1]) E = E.Next;\n      while (E !== Result && E.Dx === ClipperLib.ClipperBase.horizontal) E = E.Prev;\n    } else {\n      while (E.Top[1] === E.Prev.Bot[1]) E = E.Prev;\n      while (E !== Result && E.Dx === ClipperLib.ClipperBase.horizontal) E = E.Next;\n    }\n    if (E === Result) {\n      if (LeftBoundIsForward) Result = E.Next;\n      else Result = E.Prev;\n    } else {\n      //there are more edges in the bound beyond result starting with E\n      if (LeftBoundIsForward)\n        E = Result.Next;\n      else\n        E = Result.Prev;\n      var locMin = new ClipperLib.LocalMinima();\n      locMin.Next = null;\n      locMin[1] = E.Bot[1];\n      locMin.LeftBound = null;\n      locMin.RightBound = E;\n      E.WindDelta = 0;\n      Result = this.ProcessBound(E, LeftBoundIsForward);\n      this.InsertLocalMinima(locMin);\n    }\n    return Result;\n  }\n\n  if (E.Dx === ClipperLib.ClipperBase.horizontal) {\n    //We need to be careful with open paths because this may not be a\n    //true local minima (ie E may be following a skip edge).\n    //Also, consecutive horz. edges may start heading left before going right.\n    if (LeftBoundIsForward) EStart = E.Prev;\n    else EStart = E.Next;\n\n    if (EStart.Dx === ClipperLib.ClipperBase.horizontal) //ie an adjoining horizontal skip edge\n    {\n      if (EStart.Bot[0] !== E.Bot[0] && EStart.Top[0] !== E.Bot[0])\n        this.ReverseHorizontal(E);\n    } else if (EStart.Bot[0] !== E.Bot[0])\n      this.ReverseHorizontal(E);\n  }\n\n  EStart = E;\n  if (LeftBoundIsForward) {\n    while (Result.Top[1] === Result.Next.Bot[1] && Result.Next.OutIdx !== ClipperLib.ClipperBase.Skip)\n      Result = Result.Next;\n    if (Result.Dx === ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx !== ClipperLib.ClipperBase.Skip) {\n      //nb: at the top of a bound, horizontals are added to the bound\n      //only when the preceding edge attaches to the horizontal's left vertex\n      //unless a Skip edge is encountered when that becomes the top divide\n      Horz = Result;\n      while (Horz.Prev.Dx === ClipperLib.ClipperBase.horizontal)\n        Horz = Horz.Prev;\n      if (Horz.Prev.Top[0] > Result.Next.Top[0])\n        Result = Horz.Prev;\n    }\n    while (E !== Result) {\n      E.NextInLML = E.Next;\n      if (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot[0] !== E.Prev.Top[0])\n        this.ReverseHorizontal(E);\n      E = E.Next;\n    }\n    if (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot[0] !== E.Prev.Top[0])\n      this.ReverseHorizontal(E);\n    Result = Result.Next;\n    //move to the edge just beyond current bound\n  } else {\n    while (Result.Top[1] === Result.Prev.Bot[1] && Result.Prev.OutIdx !== ClipperLib.ClipperBase.Skip)\n      Result = Result.Prev;\n    if (Result.Dx === ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx !== ClipperLib.ClipperBase.Skip) {\n      Horz = Result;\n      while (Horz.Next.Dx === ClipperLib.ClipperBase.horizontal)\n        Horz = Horz.Next;\n      if (Horz.Next.Top[0] === Result.Prev.Top[0] || Horz.Next.Top[0] > Result.Prev.Top[0]) {\n        Result = Horz.Next;\n      }\n    }\n    while (E !== Result) {\n      E.NextInLML = E.Prev;\n      if (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot[0] !== E.Next.Top[0])\n        this.ReverseHorizontal(E);\n      E = E.Prev;\n    }\n    if (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot[0] !== E.Next.Top[0])\n      this.ReverseHorizontal(E);\n    Result = Result.Prev;\n    //move to the edge just beyond current bound\n  }\n\n  return Result;\n};\n\nClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed) {\n  if (ClipperLib.use_lines) {\n    if (!Closed && polyType === ClipperLib.PolyType.ptClip)\n      ClipperLib.Error(\"AddPath: Open paths must be subject.\");\n  } else {\n    if (!Closed)\n      ClipperLib.Error(\"AddPath: Open paths have been disabled.\");\n  }\n  var highI = pg.length - 1;\n  if (Closed)\n    while (highI > 0 && (ClipperLib.FPoint_op_Equality(pg[highI], pg[0])))\n      --highI;\n  while (highI > 0 && (ClipperLib.FPoint_op_Equality(pg[highI], pg[highI - 1])))\n    --highI;\n  if ((Closed && highI < 2) || (!Closed && highI < 1))\n    return false;\n  //create a new edge array ...\n  var edges = new Array();\n  for (var i = 0; i <= highI; i++)\n    edges.push(new ClipperLib.TEdge());\n  var IsFlat = true;\n  //1. Basic (first) edge initialization ...\n\n  //edges[1].Curr = pg[1];\n  edges[1].Curr[0] = pg[1][0];\n  edges[1].Curr[1] = pg[1][1];\n\n  this.RangeTest(pg[0]);\n\n  this.RangeTest(pg[highI]);\n\n  this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);\n  this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);\n  for (var i = highI - 1; i >= 1; --i) {\n    this.RangeTest(pg[i]);\n\n    this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);\n  }\n\n  var eStart = edges[0];\n  //2. Remove duplicate vertices, and (when closed) collinear edges ...\n  var E = eStart,\n    eLoopStop = eStart;\n  for (;;) {\n    //console.log(E.Next, eStart);\n    //nb: allows matching start and end points when not Closed ...\n    if (E.Curr === E.Next.Curr && (Closed || E.Next !== eStart)) {\n      if (E === E.Next)\n        break;\n      if (E === eStart)\n        eStart = E.Next;\n      E = this.RemoveEdge(E);\n      eLoopStop = E;\n      continue;\n    }\n    if (E.Prev === E.Next)\n      break;\n    else if (Closed && ClipperLib.ClipperBase.SlopesEqual4(E.Prev.Curr, E.Curr, E.Next.Curr) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr))) {\n      //Collinear edges are allowed for open paths but in closed paths\n      //the default is to merge adjacent collinear edges into a single edge.\n      //However, if the PreserveCollinear property is enabled, only overlapping\n      //collinear edges (ie spikes) will be removed from closed paths.\n      if (E === eStart)\n        eStart = E.Next;\n      E = this.RemoveEdge(E);\n      E = E.Prev;\n      eLoopStop = E;\n      continue;\n    }\n    E = E.Next;\n    if ((E === eLoopStop) || (!Closed && E.Next === eStart)) break;\n  }\n  if ((!Closed && (E === E.Next)) || (Closed && (E.Prev === E.Next)))\n    return false;\n  if (!Closed) {\n    this.m_HasOpenPaths = true;\n    eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n  }\n  //3. Do second stage of edge initialization ...\n  E = eStart;\n  do {\n    this.InitEdge2(E, polyType);\n    E = E.Next;\n    if (IsFlat && E.Curr[1] !== eStart.Curr[1])\n      IsFlat = false;\n  }\n  while (E !== eStart)\n  //4. Finally, add edge bounds to LocalMinima list ...\n  //Totally flat paths must be handled differently when adding them\n  //to LocalMinima list to avoid endless loops etc ...\n  if (IsFlat) {\n    if (Closed)\n      return false;\n\n    E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n\n    var locMin = new ClipperLib.LocalMinima();\n    locMin.Next = null;\n    locMin[1] = E.Bot[1];\n    locMin.LeftBound = null;\n    locMin.RightBound = E;\n    locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n    locMin.RightBound.WindDelta = 0;\n\n    for (;;) {\n      if (E.Bot[0] !== E.Prev.Top[0]) this.ReverseHorizontal(E);\n      if (E.Next.OutIdx === ClipperLib.ClipperBase.Skip) break;\n      E.NextInLML = E.Next;\n      E = E.Next;\n    }\n    this.InsertLocalMinima(locMin);\n    this.m_edges.push(edges);\n    return true;\n  }\n  this.m_edges.push(edges);\n  var leftBoundIsForward;\n  var EMin = null;\n\n  //workaround to avoid an endless loop in the while loop below when\n  //open paths have matching start and end points ...\n  if (ClipperLib.FPoint_op_Equality(E.Prev.Bot, E.Prev.Top))\n    E = E.Next;\n\n  for (;;) {\n    E = this.FindNextLocMin(E);\n    if (E === EMin)\n      break;\n    else if (EMin === null)\n      EMin = E;\n    //E and E.Prev now share a local minima (left aligned if horizontal).\n    //Compare their slopes to find which starts which bound ...\n    var locMin = new ClipperLib.LocalMinima();\n    locMin.Next = null;\n    locMin[1] = E.Bot[1];\n    if (E.Dx < E.Prev.Dx) {\n      locMin.LeftBound = E.Prev;\n      locMin.RightBound = E;\n      leftBoundIsForward = false;\n      //Q.nextInLML = Q.prev\n    } else {\n      locMin.LeftBound = E;\n      locMin.RightBound = E.Prev;\n      leftBoundIsForward = true;\n      //Q.nextInLML = Q.next\n    }\n    locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;\n    locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n    if (!Closed)\n      locMin.LeftBound.WindDelta = 0;\n    else if (locMin.LeftBound.Next === locMin.RightBound)\n      locMin.LeftBound.WindDelta = -1;\n    else\n      locMin.LeftBound.WindDelta = 1;\n    locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;\n    E = this.ProcessBound(locMin.LeftBound, leftBoundIsForward);\n    if (E.OutIdx === ClipperLib.ClipperBase.Skip)\n      E = this.ProcessBound(E, leftBoundIsForward);\n    var E2 = this.ProcessBound(locMin.RightBound, !leftBoundIsForward);\n    if (E2.OutIdx === ClipperLib.ClipperBase.Skip) E2 = this.ProcessBound(E2, !leftBoundIsForward);\n    if (locMin.LeftBound.OutIdx === ClipperLib.ClipperBase.Skip)\n      locMin.LeftBound = null;\n    else if (locMin.RightBound.OutIdx === ClipperLib.ClipperBase.Skip)\n      locMin.RightBound = null;\n    this.InsertLocalMinima(locMin);\n    if (!leftBoundIsForward)\n      E = E2;\n  }\n  return true;\n};\n\nClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed) {\n  //  console.log(\"-------------------------------------------\");\n  //  console.log(JSON.stringify(ppg));\n  var result = false;\n  for (var i = 0, ilen = ppg.length; i < ilen; ++i)\n    if (this.AddPath(ppg[i], polyType, closed))\n      result = true;\n  return result;\n};\n\nClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3) {\n  if ((ClipperLib.FPoint_op_Equality(pt1, pt3)) || (ClipperLib.FPoint_op_Equality(pt1, pt2)) || (ClipperLib.FPoint_op_Equality(pt3, pt2)))\n\n    //if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))\n    return false;\n\n  else if (pt1[0] !== pt3[0])\n    return (pt2[0] > pt1[0]) === (pt2[0] < pt3[0]);\n  else\n    return (pt2[1] > pt1[1]) === (pt2[1] < pt3[1]);\n};\n\nClipperLib.ClipperBase.prototype.RemoveEdge = function (e) {\n  //removes e from double_linked_list (but without removing from memory)\n  e.Prev.Next = e.Next;\n  e.Next.Prev = e.Prev;\n  var result = e.Next;\n  e.Prev = null; //flag as removed (see ClipperBase.Clear)\n  return result;\n};\n\nClipperLib.ClipperBase.prototype.SetDx = function (e) {\n  e.Delta[0] = (e.Top[0] - e.Bot[0]);\n  e.Delta[1] = (e.Top[1] - e.Bot[1]);\n  if (e.Delta[1] === 0) e.Dx = ClipperLib.ClipperBase.horizontal;\n  else e.Dx = (e.Delta[0]) / (e.Delta[1]);\n};\n\nClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm) {\n  if (this.m_MinimaList === null) {\n    this.m_MinimaList = newLm;\n  } else if (newLm[1] >= this.m_MinimaList[1]) {\n    newLm.Next = this.m_MinimaList;\n    this.m_MinimaList = newLm;\n  } else {\n    var tmpLm = this.m_MinimaList;\n    while (tmpLm.Next !== null && (newLm[1] < tmpLm.Next[1]))\n      tmpLm = tmpLm.Next;\n    newLm.Next = tmpLm.Next;\n    tmpLm.Next = newLm;\n  }\n};\n\nClipperLib.ClipperBase.prototype.PopLocalMinima = function (Y, current) {\n  current.v = this.m_CurrentLM;\n  if (this.m_CurrentLM !== null && this.m_CurrentLM[1] === Y) {\n    this.m_CurrentLM = this.m_CurrentLM.Next;\n    return true;\n  }\n  return false;\n};\n\nClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e) {\n  //swap horizontal edges' top and bottom x's so they follow the natural\n  //progression of the bounds - ie so their xbots will align with the\n  //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\n  var tmp = e.Top[0];\n  e.Top[0] = e.Bot[0];\n  e.Bot[0] = tmp;\n};\n\nClipperLib.ClipperBase.prototype.Reset = function () {\n  this.m_CurrentLM = this.m_MinimaList;\n  if (this.m_CurrentLM === null) //ie nothing to process\n    return;\n  //reset all edges ...\n  this.m_Scanbeam = null;\n  var lm = this.m_MinimaList;\n  while (lm !== null) {\n    this.InsertScanbeam(lm[1]);\n    var e = lm.LeftBound;\n    if (e !== null) {\n      //e.Curr = e.Bot;\n      e.Curr[0] = e.Bot[0];\n      e.Curr[1] = e.Bot[1];\n      e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n    }\n    e = lm.RightBound;\n    if (e !== null) {\n      //e.Curr = e.Bot;\n      e.Curr[0] = e.Bot[0];\n      e.Curr[1] = e.Bot[1];\n      e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n    }\n    lm = lm.Next;\n  }\n  this.m_ActiveEdges = null;\n};\n\nClipperLib.ClipperBase.prototype.InsertScanbeam = function (Y) {\n  //single-linked list: sorted descending, ignoring dups.\n  if (this.m_Scanbeam === null) {\n    this.m_Scanbeam = new ClipperLib.Scanbeam();\n    this.m_Scanbeam.Next = null;\n    this.m_Scanbeam[1] = Y;\n  } else if (Y > this.m_Scanbeam[1]) {\n    var newSb = new ClipperLib.Scanbeam();\n    newSb[1] = Y;\n    newSb.Next = this.m_Scanbeam;\n    this.m_Scanbeam = newSb;\n  } else {\n    var sb2 = this.m_Scanbeam;\n    while (sb2.Next !== null && Y <= sb2.Next[1]) {\n      sb2 = sb2.Next;\n    }\n    if (Y === sb2[1]) {\n      return;\n    } //ie ignores duplicates\n    var newSb1 = new ClipperLib.Scanbeam();\n    newSb1[1] = Y;\n    newSb1.Next = sb2.Next;\n    sb2.Next = newSb1;\n  }\n};\n\nClipperLib.ClipperBase.prototype.PopScanbeam = function (Y) {\n  if (this.m_Scanbeam === null) {\n    Y.v = 0;\n    return false;\n  }\n  Y.v = this.m_Scanbeam[1];\n  this.m_Scanbeam = this.m_Scanbeam.Next;\n  return true;\n};\n\nClipperLib.ClipperBase.prototype.LocalMinimaPending = function () {\n  return (this.m_CurrentLM !== null);\n};\n\nClipperLib.ClipperBase.prototype.CreateOutRec = function () {\n  var result = new ClipperLib.OutRec();\n  result.Idx = ClipperLib.ClipperBase.Unassigned;\n  result.IsHole = false;\n  result.IsOpen = false;\n  result.FirstLeft = null;\n  result.Pts = null;\n  result.BottomPt = null;\n  result.PolyNode = null;\n  this.m_PolyOuts.push(result);\n  result.Idx = this.m_PolyOuts.length - 1;\n  return result;\n};\n\nClipperLib.ClipperBase.prototype.DisposeOutRec = function (index) {\n  var outRec = this.m_PolyOuts[index];\n  outRec.Pts = null;\n  outRec = null;\n  this.m_PolyOuts[index] = null;\n};\n\nClipperLib.ClipperBase.prototype.UpdateEdgeIntoAEL = function (e) {\n  if (e.NextInLML === null) {\n    ClipperLib.Error(\"UpdateEdgeIntoAEL: invalid call\");\n  }\n  var AelPrev = e.PrevInAEL;\n  var AelNext = e.NextInAEL;\n  e.NextInLML.OutIdx = e.OutIdx;\n  if (AelPrev !== null) {\n    AelPrev.NextInAEL = e.NextInLML;\n  } else {\n    this.m_ActiveEdges = e.NextInLML;\n  }\n  if (AelNext !== null) {\n    AelNext.PrevInAEL = e.NextInLML;\n  }\n  e.NextInLML.Side = e.Side;\n  e.NextInLML.WindDelta = e.WindDelta;\n  e.NextInLML.WindCnt = e.WindCnt;\n  e.NextInLML.WindCnt2 = e.WindCnt2;\n  e = e.NextInLML;\n  e.Curr[0] = e.Bot[0];\n  e.Curr[1] = e.Bot[1];\n  e.PrevInAEL = AelPrev;\n  e.NextInAEL = AelNext;\n  if (!ClipperLib.ClipperBase.IsHorizontal(e)) {\n    this.InsertScanbeam(e.Top[1]);\n  }\n  return e;\n};\n\nClipperLib.ClipperBase.prototype.SwapPositionsInAEL = function (edge1, edge2) {\n  //check that one or other edge hasn't already been removed from AEL ...\n  if (edge1.NextInAEL === edge1.PrevInAEL || edge2.NextInAEL === edge2.PrevInAEL) {\n    return;\n  }\n\n  if (edge1.NextInAEL === edge2) {\n    var next = edge2.NextInAEL;\n    if (next !== null) {\n      next.PrevInAEL = edge1;\n    }\n    var prev = edge1.PrevInAEL;\n    if (prev !== null) {\n      prev.NextInAEL = edge2;\n    }\n    edge2.PrevInAEL = prev;\n    edge2.NextInAEL = edge1;\n    edge1.PrevInAEL = edge2;\n    edge1.NextInAEL = next;\n  } else if (edge2.NextInAEL === edge1) {\n    var next1 = edge1.NextInAEL;\n    if (next1 !== null) {\n      next1.PrevInAEL = edge2;\n    }\n    var prev1 = edge2.PrevInAEL;\n    if (prev1 !== null) {\n      prev1.NextInAEL = edge1;\n    }\n    edge1.PrevInAEL = prev1;\n    edge1.NextInAEL = edge2;\n    edge2.PrevInAEL = edge1;\n    edge2.NextInAEL = next1;\n  } else {\n    var next2 = edge1.NextInAEL;\n    var prev2 = edge1.PrevInAEL;\n    edge1.NextInAEL = edge2.NextInAEL;\n    if (edge1.NextInAEL !== null) {\n      edge1.NextInAEL.PrevInAEL = edge1;\n    }\n    edge1.PrevInAEL = edge2.PrevInAEL;\n    if (edge1.PrevInAEL !== null) {\n      edge1.PrevInAEL.NextInAEL = edge1;\n    }\n    edge2.NextInAEL = next2;\n    if (edge2.NextInAEL !== null) {\n      edge2.NextInAEL.PrevInAEL = edge2;\n    }\n    edge2.PrevInAEL = prev2;\n    if (edge2.PrevInAEL !== null) {\n      edge2.PrevInAEL.NextInAEL = edge2;\n    }\n  }\n\n  if (edge1.PrevInAEL === null) {\n    this.m_ActiveEdges = edge1;\n  } else {\n    if (edge2.PrevInAEL === null) {\n      this.m_ActiveEdges = edge2;\n    }\n  }\n};\n\nClipperLib.ClipperBase.prototype.DeleteFromAEL = function (e) {\n  var AelPrev = e.PrevInAEL;\n  var AelNext = e.NextInAEL;\n  if (AelPrev === null && AelNext === null && e !== this.m_ActiveEdges) {\n    return;\n  } //already deleted\n  if (AelPrev !== null) {\n    AelPrev.NextInAEL = AelNext;\n  } else {\n    this.m_ActiveEdges = AelNext;\n  }\n  if (AelNext !== null) {\n    AelNext.PrevInAEL = AelPrev;\n  }\n  e.NextInAEL = null;\n  e.PrevInAEL = null;\n}\n\n// public Clipper(int InitOptions = 0)\n/**\n * @suppress {missingProperties}\n */\nClipperLib.Clipper = function (InitOptions) {\n  if (typeof (InitOptions) === \"undefined\") InitOptions = 0;\n  this.m_PolyOuts = null;\n  this.m_ClipType = ClipperLib.ClipType.ctIntersection;\n  this.m_Scanbeam = null;\n  this.m_Maxima = null;\n  this.m_ActiveEdges = null;\n  this.m_SortedEdges = null;\n  this.m_IntersectList = null;\n  this.m_IntersectNodeComparer = null;\n  this.m_ExecuteLocked = false;\n  this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;\n  this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;\n  this.m_Joins = null;\n  this.m_GhostJoins = null;\n  this.m_UsingPolyTree = false;\n  this.ReverseSolution = false;\n  this.StrictlySimple = false;\n\n  ClipperLib.ClipperBase.call(this);\n\n  this.m_Scanbeam = null;\n  this.m_Maxima = null;\n  this.m_ActiveEdges = null;\n  this.m_SortedEdges = null;\n  this.m_IntersectList = new Array();\n  this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;\n  this.m_ExecuteLocked = false;\n  this.m_UsingPolyTree = false;\n  this.m_PolyOuts = new Array();\n  this.m_Joins = new Array();\n  this.m_GhostJoins = new Array();\n  this.ReverseSolution = (1 & InitOptions) !== 0;\n  this.StrictlySimple = (2 & InitOptions) !== 0;\n  this.PreserveCollinear = (4 & InitOptions) !== 0;\n};\n\nClipperLib.Clipper.ioReverseSolution = 1;\nClipperLib.Clipper.ioStrictlySimple = 2;\nClipperLib.Clipper.ioPreserveCollinear = 4;\n\nClipperLib.Clipper.prototype.Clear = function () {\n  if (this.m_edges.length === 0)\n    return;\n  //avoids problems with ClipperBase destructor\n  this.DisposeAllPolyPts();\n  ClipperLib.ClipperBase.prototype.Clear.call(this);\n};\n\nClipperLib.Clipper.prototype.InsertMaxima = function (X) {\n  //double-linked list: sorted ascending, ignoring dups.\n  var newMax = new ClipperLib.Maxima();\n  newMax[0] = X;\n  if (this.m_Maxima === null) {\n    this.m_Maxima = newMax;\n    this.m_Maxima.Next = null;\n    this.m_Maxima.Prev = null;\n  } else if (X < this.m_Maxima[0]) {\n    newMax.Next = this.m_Maxima;\n    newMax.Prev = null;\n    this.m_Maxima = newMax;\n  } else {\n    var m = this.m_Maxima;\n    while (m.Next !== null && X >= m.Next[0]) {\n      m = m.Next;\n    }\n    if (X === m[0]) {\n      return;\n    } //ie ignores duplicates (& CG to clean up newMax)\n    //insert newMax between m and m.Next ...\n    newMax.Next = m.Next;\n    newMax.Prev = m;\n    if (m.Next !== null) {\n      m.Next.Prev = newMax;\n    }\n    m.Next = newMax;\n  }\n};\n\n// ************************************\nClipperLib.Clipper.prototype.Execute = function () {\n  var a = arguments,\n    alen = a.length,\n    ispolytree = a[1] instanceof ClipperLib.PolyTree;\n  if (alen === 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)\n  {\n    var clipType = a[0],\n      solution = a[1],\n      subjFillType = a[2],\n      clipFillType = a[3];\n    if (this.m_ExecuteLocked)\n      return false;\n    if (this.m_HasOpenPaths)\n      ClipperLib.Error(\"Error: PolyTree struct is needed for open path clipping.\");\n    this.m_ExecuteLocked = true;\n    ClipperLib.Clear(solution);\n    this.m_SubjFillType = subjFillType;\n    this.m_ClipFillType = clipFillType;\n    this.m_ClipType = clipType;\n    this.m_UsingPolyTree = false;\n    try {\n      var succeeded = this.ExecuteInternal();\n      //build the return polygons ...\n      if (succeeded) this.BuildResult(solution);\n    } finally {\n      this.DisposeAllPolyPts();\n      this.m_ExecuteLocked = false;\n    }\n    return succeeded;\n  } else if (alen === 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)\n  {\n    var clipType = a[0],\n      polytree = a[1],\n      subjFillType = a[2],\n      clipFillType = a[3];\n    if (this.m_ExecuteLocked)\n      return false;\n    this.m_ExecuteLocked = true;\n    this.m_SubjFillType = subjFillType;\n    this.m_ClipFillType = clipFillType;\n    this.m_ClipType = clipType;\n    this.m_UsingPolyTree = true;\n    try {\n      var succeeded = this.ExecuteInternal();\n      //build the return polygons ...\n      if (succeeded) this.BuildResult2(polytree);\n    } finally {\n      this.DisposeAllPolyPts();\n      this.m_ExecuteLocked = false;\n    }\n    return succeeded;\n  } else if (alen === 2 && !ispolytree) // function (clipType, solution)\n  {\n    var clipType = a[0],\n      solution = a[1];\n    return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n  } else if (alen === 2 && ispolytree) // function (clipType, polytree)\n  {\n    var clipType = a[0],\n      polytree = a[1];\n    return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n  }\n};\n\nClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec) {\n  //skip if an outermost polygon or\n  //already already points to the correct FirstLeft ...\n  if (outRec.FirstLeft === null || (outRec.IsHole !== outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))\n    return;\n  var orfl = outRec.FirstLeft;\n  while (orfl !== null && ((orfl.IsHole === outRec.IsHole) || orfl.Pts === null))\n    orfl = orfl.FirstLeft;\n  outRec.FirstLeft = orfl;\n};\n\nClipperLib.Clipper.prototype.ExecuteInternal = function () {\n  try {\n    this.Reset();\n    this.m_SortedEdges = null;\n    this.m_Maxima = null;\n\n    var botY = {},\n      topY = {};\n\n    if (!this.PopScanbeam(botY)) {\n      return false;\n    }\n    this.InsertLocalMinimaIntoAEL(botY.v);\n    while (this.PopScanbeam(topY) || this.LocalMinimaPending()) {\n      this.ProcessHorizontals();\n      this.m_GhostJoins.length = 0;\n      if (!this.ProcessIntersections(topY.v)) {\n        return false;\n      }\n      this.ProcessEdgesAtTopOfScanbeam(topY.v);\n      botY.v = topY.v;\n      this.InsertLocalMinimaIntoAEL(botY.v);\n    }\n\n    //fix orientations ...\n    var outRec, i, ilen;\n    //fix orientations ...\n    for (i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n      outRec = this.m_PolyOuts[i];\n      if (outRec.Pts === null || outRec.IsOpen) continue;\n      if ((outRec.IsHole ^ this.ReverseSolution) == (this.Area$1(outRec) > 0))\n        this.ReversePolyPtLinks(outRec.Pts);\n    }\n\n    this.JoinCommonEdges();\n\n    for (i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n      outRec = this.m_PolyOuts[i];\n      if (outRec.Pts === null)\n        continue;\n      else if (outRec.IsOpen)\n        this.FixupOutPolyline(outRec);\n      else\n        this.FixupOutPolygon(outRec);\n    }\n\n    if (this.StrictlySimple) this.DoSimplePolygons();\n    return true;\n  }\n  //catch { return false; }\n  finally {\n    this.m_Joins.length = 0;\n    this.m_GhostJoins.length = 0;\n  }\n};\n\nClipperLib.Clipper.prototype.DisposeAllPolyPts = function () {\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)\n    this.DisposeOutRec(i);\n  ClipperLib.Clear(this.m_PolyOuts);\n};\n\nClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt) {\n  var j = new ClipperLib.Join();\n  j.OutPt1 = Op1;\n  j.OutPt2 = Op2;\n  //j.OffPt = OffPt;\n  j.OffPt[0] = OffPt[0];\n  j.OffPt[1] = OffPt[1];\n  this.m_Joins.push(j);\n};\n\nClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt) {\n  var j = new ClipperLib.Join();\n  j.OutPt1 = Op;\n  //j.OffPt = OffPt;\n  j.OffPt[0] = OffPt[0];\n  j.OffPt[1] = OffPt[1];\n  this.m_GhostJoins.push(j);\n};\n\nClipperLib.Clipper.prototype.SetZ = function (pt, e1, e2) {\n  if (this.ZFillFunction !== null) {\n    if (pt.Z !== 0 || this.ZFillFunction === null) return;\n    else if (ClipperLib.FPoint_op_Equality(pt, e1.Bot)) pt.Z = e1.Bot.Z;\n    else if (ClipperLib.FPoint_op_Equality(pt, e1.Top)) pt.Z = e1.Top.Z;\n    else if (ClipperLib.FPoint_op_Equality(pt, e2.Bot)) pt.Z = e2.Bot.Z;\n    else if (ClipperLib.FPoint_op_Equality(pt, e2.Top)) pt.Z = e2.Top.Z;\n    else this.ZFillFunction(e1.Bot, e1.Top, e2.Bot, e2.Top, pt);\n  }\n};\n//}\n\nClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY) {\n  var lm = {};\n\n  var lb;\n  var rb;\n  while (this.PopLocalMinima(botY, lm)) {\n    lb = lm.v.LeftBound;\n    rb = lm.v.RightBound;\n\n    var Op1 = null;\n    if (lb === null) {\n      this.InsertEdgeIntoAEL(rb, null);\n      this.SetWindingCount(rb);\n      if (this.IsContributing(rb))\n        Op1 = this.AddOutPt(rb, rb.Bot);\n    } else if (rb === null) {\n      this.InsertEdgeIntoAEL(lb, null);\n      this.SetWindingCount(lb);\n      if (this.IsContributing(lb))\n        Op1 = this.AddOutPt(lb, lb.Bot);\n      this.InsertScanbeam(lb.Top[1]);\n    } else {\n      this.InsertEdgeIntoAEL(lb, null);\n      this.InsertEdgeIntoAEL(rb, lb);\n      this.SetWindingCount(lb);\n      rb.WindCnt = lb.WindCnt;\n      rb.WindCnt2 = lb.WindCnt2;\n      if (this.IsContributing(lb))\n        Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);\n      this.InsertScanbeam(lb.Top[1]);\n    }\n    if (rb !== null) {\n      if (ClipperLib.ClipperBase.IsHorizontal(rb)) {\n        if (rb.NextInLML !== null) {\n          this.InsertScanbeam(rb.NextInLML.Top[1]);\n        }\n        this.AddEdgeToSEL(rb);\n      } else {\n        this.InsertScanbeam(rb.Top[1]);\n      }\n    }\n    if (lb === null || rb === null) continue;\n    //if output polygons share an Edge with a horizontal rb, they'll need joining later ...\n    if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0) {\n      for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++) {\n        //if the horizontal Rb and a 'ghost' horizontal overlap, then convert\n        //the 'ghost' join to a real join ready for later ...\n        var j = this.m_GhostJoins[i];\n\n        if (this.HorzSegmentsOverlap(j.OutPt1.Pt[0], j.OffPt[0], rb.Bot[0], rb.Top[0]))\n          this.AddJoin(j.OutPt1, Op1, j.OffPt);\n      }\n    }\n\n    if (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&\n      lb.PrevInAEL.Curr[0] === lb.Bot[0] &&\n      lb.PrevInAEL.OutIdx >= 0 &&\n      ClipperLib.ClipperBase.SlopesEqual5(lb.PrevInAEL.Curr, lb.PrevInAEL.Top, lb.Curr, lb.Top) &&\n      lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0) {\n      var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);\n      this.AddJoin(Op1, Op2, lb.Top);\n    }\n    if (lb.NextInAEL !== rb) {\n      if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&\n        ClipperLib.ClipperBase.SlopesEqual5(rb.PrevInAEL.Curr, rb.PrevInAEL.Top, rb.Curr, rb.Top) &&\n        rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0) {\n        var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);\n        this.AddJoin(Op1, Op2, rb.Top);\n      }\n      var e = lb.NextInAEL;\n      if (e !== null)\n        while (e !== rb) {\n          //nb: For calculating winding counts etc, IntersectEdges() assumes\n          //that param1 will be to the right of param2 ABOVE the intersection ...\n          this.IntersectEdges(rb, e, lb.Curr);\n          //order important here\n          e = e.NextInAEL;\n        }\n    }\n  }\n};\n\nClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge) {\n  if (this.m_ActiveEdges === null) {\n    edge.PrevInAEL = null;\n    edge.NextInAEL = null;\n    this.m_ActiveEdges = edge;\n  } else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge)) {\n    edge.PrevInAEL = null;\n    edge.NextInAEL = this.m_ActiveEdges;\n    this.m_ActiveEdges.PrevInAEL = edge;\n    this.m_ActiveEdges = edge;\n  } else {\n    if (startEdge === null)\n      startEdge = this.m_ActiveEdges;\n    while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))\n      startEdge = startEdge.NextInAEL;\n    edge.NextInAEL = startEdge.NextInAEL;\n    if (startEdge.NextInAEL !== null)\n      startEdge.NextInAEL.PrevInAEL = edge;\n    edge.PrevInAEL = startEdge;\n    startEdge.NextInAEL = edge;\n  }\n};\n\nClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2) {\n  if (e2.Curr[0] === e1.Curr[0]) {\n    if (e2.Top[1] > e1.Top[1])\n      return e2.Top[0] < ClipperLib.Clipper.TopX(e1, e2.Top[1]);\n    else\n      return e1.Top[0] > ClipperLib.Clipper.TopX(e2, e1.Top[1]);\n  } else\n    return e2.Curr[0] < e1.Curr[0];\n};\n\nClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge) {\n  if (edge.PolyTyp === ClipperLib.PolyType.ptSubject)\n    return this.m_SubjFillType === ClipperLib.PolyFillType.pftEvenOdd;\n  else\n    return this.m_ClipFillType === ClipperLib.PolyFillType.pftEvenOdd;\n};\n\nClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge) {\n  if (edge.PolyTyp === ClipperLib.PolyType.ptSubject)\n    return this.m_ClipFillType === ClipperLib.PolyFillType.pftEvenOdd;\n  else\n    return this.m_SubjFillType === ClipperLib.PolyFillType.pftEvenOdd;\n};\n\nClipperLib.Clipper.prototype.IsContributing = function (edge) {\n  var pft, pft2;\n  if (edge.PolyTyp === ClipperLib.PolyType.ptSubject) {\n    pft = this.m_SubjFillType;\n    pft2 = this.m_ClipFillType;\n  } else {\n    pft = this.m_ClipFillType;\n    pft2 = this.m_SubjFillType;\n  }\n  switch (pft) {\n    case ClipperLib.PolyFillType.pftEvenOdd:\n      if (edge.WindDelta === 0 && edge.WindCnt !== 1)\n        return false;\n      break;\n    case ClipperLib.PolyFillType.pftNonZero:\n      if (Math.abs(edge.WindCnt) !== 1)\n        return false;\n      break;\n    case ClipperLib.PolyFillType.pftPositive:\n      if (edge.WindCnt !== 1)\n        return false;\n      break;\n    default:\n      if (edge.WindCnt !== -1)\n        return false;\n      break;\n  }\n  switch (this.m_ClipType) {\n    case ClipperLib.ClipType.ctIntersection:\n      switch (pft2) {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 !== 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 > 0);\n        default:\n          return (edge.WindCnt2 < 0);\n      }\n    case ClipperLib.ClipType.ctUnion:\n      switch (pft2) {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 === 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 <= 0);\n        default:\n          return (edge.WindCnt2 >= 0);\n      }\n    case ClipperLib.ClipType.ctDifference:\n      if (edge.PolyTyp === ClipperLib.PolyType.ptSubject)\n        switch (pft2) {\n          case ClipperLib.PolyFillType.pftEvenOdd:\n          case ClipperLib.PolyFillType.pftNonZero:\n            return (edge.WindCnt2 === 0);\n          case ClipperLib.PolyFillType.pftPositive:\n            return (edge.WindCnt2 <= 0);\n          default:\n            return (edge.WindCnt2 >= 0);\n        }\n      else\n        switch (pft2) {\n          case ClipperLib.PolyFillType.pftEvenOdd:\n          case ClipperLib.PolyFillType.pftNonZero:\n            return (edge.WindCnt2 !== 0);\n          case ClipperLib.PolyFillType.pftPositive:\n            return (edge.WindCnt2 > 0);\n          default:\n            return (edge.WindCnt2 < 0);\n        }\n    case ClipperLib.ClipType.ctXor:\n      if (edge.WindDelta === 0)\n        switch (pft2) {\n          case ClipperLib.PolyFillType.pftEvenOdd:\n          case ClipperLib.PolyFillType.pftNonZero:\n            return (edge.WindCnt2 === 0);\n          case ClipperLib.PolyFillType.pftPositive:\n            return (edge.WindCnt2 <= 0);\n          default:\n            return (edge.WindCnt2 >= 0);\n        }\n      else\n        return true;\n  }\n  return true;\n};\n\nClipperLib.Clipper.prototype.SetWindingCount = function (edge) {\n  var e = edge.PrevInAEL;\n  //find the edge of the same polytype that immediately preceeds 'edge' in AEL\n  while (e !== null && ((e.PolyTyp !== edge.PolyTyp) || (e.WindDelta === 0)))\n    e = e.PrevInAEL;\n  if (e === null) {\n    var pft = (edge.PolyTyp === ClipperLib.PolyType.ptSubject ? this.m_SubjFillType : this.m_ClipFillType);\n    if (edge.WindDelta === 0) {\n      edge.WindCnt = (pft === ClipperLib.PolyFillType.pftNegative ? -1 : 1);\n    } else {\n      edge.WindCnt = edge.WindDelta;\n    }\n    edge.WindCnt2 = 0;\n    e = this.m_ActiveEdges;\n    //ie get ready to calc WindCnt2\n  } else if (edge.WindDelta === 0 && this.m_ClipType !== ClipperLib.ClipType.ctUnion) {\n    edge.WindCnt = 1;\n    edge.WindCnt2 = e.WindCnt2;\n    e = e.NextInAEL;\n    //ie get ready to calc WindCnt2\n  } else if (this.IsEvenOddFillType(edge)) {\n    //EvenOdd filling ...\n    if (edge.WindDelta === 0) {\n      //are we inside a subj polygon ...\n      var Inside = true;\n      var e2 = e.PrevInAEL;\n      while (e2 !== null) {\n        if (e2.PolyTyp === e.PolyTyp && e2.WindDelta !== 0)\n          Inside = !Inside;\n        e2 = e2.PrevInAEL;\n      }\n      edge.WindCnt = (Inside ? 0 : 1);\n    } else {\n      edge.WindCnt = edge.WindDelta;\n    }\n    edge.WindCnt2 = e.WindCnt2;\n    e = e.NextInAEL;\n    //ie get ready to calc WindCnt2\n  } else {\n    //nonZero, Positive or Negative filling ...\n    if (e.WindCnt * e.WindDelta < 0) {\n      //prev edge is 'decreasing' WindCount (WC) toward zero\n      //so we're outside the previous polygon ...\n      if (Math.abs(e.WindCnt) > 1) {\n        //outside prev poly but still inside another.\n        //when reversing direction of prev poly use the same WC\n        if (e.WindDelta * edge.WindDelta < 0)\n          edge.WindCnt = e.WindCnt;\n        else\n          edge.WindCnt = e.WindCnt + edge.WindDelta;\n      } else\n        edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n    } else {\n      //prev edge is 'increasing' WindCount (WC) away from zero\n      //so we're inside the previous polygon ...\n      if (edge.WindDelta === 0)\n        edge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);\n      else if (e.WindDelta * edge.WindDelta < 0)\n        edge.WindCnt = e.WindCnt;\n      else\n        edge.WindCnt = e.WindCnt + edge.WindDelta;\n    }\n    edge.WindCnt2 = e.WindCnt2;\n    e = e.NextInAEL;\n    //ie get ready to calc WindCnt2\n  }\n  //update WindCnt2 ...\n  if (this.IsEvenOddAltFillType(edge)) {\n    //EvenOdd filling ...\n    while (e !== edge) {\n      if (e.WindDelta !== 0)\n        edge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);\n      e = e.NextInAEL;\n    }\n  } else {\n    //nonZero, Positive or Negative filling ...\n    while (e !== edge) {\n      edge.WindCnt2 += e.WindDelta;\n      e = e.NextInAEL;\n    }\n  }\n};\n\nClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge) {\n  //SEL pointers in PEdge are use to build transient lists of horizontal edges.\n  //However, since we don't need to worry about processing order, all additions\n  //are made to the front of the list ...\n  if (this.m_SortedEdges === null) {\n    this.m_SortedEdges = edge;\n    edge.PrevInSEL = null;\n    edge.NextInSEL = null;\n  } else {\n    edge.NextInSEL = this.m_SortedEdges;\n    edge.PrevInSEL = null;\n    this.m_SortedEdges.PrevInSEL = edge;\n    this.m_SortedEdges = edge;\n  }\n};\n\nClipperLib.Clipper.prototype.PopEdgeFromSEL = function (e) {\n  //Pop edge from front of SEL (ie SEL is a FILO list)\n  e.v = this.m_SortedEdges;\n  if (e.v === null) {\n    return false;\n  }\n  var oldE = e.v;\n  this.m_SortedEdges = e.v.NextInSEL;\n  if (this.m_SortedEdges !== null) {\n    this.m_SortedEdges.PrevInSEL = null;\n  }\n  oldE.NextInSEL = null;\n  oldE.PrevInSEL = null;\n  return true;\n};\n\nClipperLib.Clipper.prototype.CopyAELToSEL = function () {\n  var e = this.m_ActiveEdges;\n  this.m_SortedEdges = e;\n  while (e !== null) {\n    e.PrevInSEL = e.PrevInAEL;\n    e.NextInSEL = e.NextInAEL;\n    e = e.NextInAEL;\n  }\n};\n\nClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2) {\n  if (edge1.NextInSEL === null && edge1.PrevInSEL === null)\n    return;\n  if (edge2.NextInSEL === null && edge2.PrevInSEL === null)\n    return;\n  if (edge1.NextInSEL === edge2) {\n    var next = edge2.NextInSEL;\n    if (next !== null)\n      next.PrevInSEL = edge1;\n    var prev = edge1.PrevInSEL;\n    if (prev !== null)\n      prev.NextInSEL = edge2;\n    edge2.PrevInSEL = prev;\n    edge2.NextInSEL = edge1;\n    edge1.PrevInSEL = edge2;\n    edge1.NextInSEL = next;\n  } else if (edge2.NextInSEL === edge1) {\n    var next = edge1.NextInSEL;\n    if (next !== null)\n      next.PrevInSEL = edge2;\n    var prev = edge2.PrevInSEL;\n    if (prev !== null)\n      prev.NextInSEL = edge1;\n    edge1.PrevInSEL = prev;\n    edge1.NextInSEL = edge2;\n    edge2.PrevInSEL = edge1;\n    edge2.NextInSEL = next;\n  } else {\n    var next = edge1.NextInSEL;\n    var prev = edge1.PrevInSEL;\n    edge1.NextInSEL = edge2.NextInSEL;\n    if (edge1.NextInSEL !== null)\n      edge1.NextInSEL.PrevInSEL = edge1;\n    edge1.PrevInSEL = edge2.PrevInSEL;\n    if (edge1.PrevInSEL !== null)\n      edge1.PrevInSEL.NextInSEL = edge1;\n    edge2.NextInSEL = next;\n    if (edge2.NextInSEL !== null)\n      edge2.NextInSEL.PrevInSEL = edge2;\n    edge2.PrevInSEL = prev;\n    if (edge2.PrevInSEL !== null)\n      edge2.PrevInSEL.NextInSEL = edge2;\n  }\n  if (edge1.PrevInSEL === null)\n    this.m_SortedEdges = edge1;\n  else if (edge2.PrevInSEL === null)\n    this.m_SortedEdges = edge2;\n};\n\nClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt) {\n  this.AddOutPt(e1, pt);\n  if (e2.WindDelta === 0) this.AddOutPt(e2, pt);\n  if (e1.OutIdx === e2.OutIdx) {\n    e1.OutIdx = -1;\n    e2.OutIdx = -1;\n  } else if (e1.OutIdx < e2.OutIdx)\n    this.AppendPolygon(e1, e2);\n  else\n    this.AppendPolygon(e2, e1);\n};\n\nClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt) {\n  var result;\n  var e, prevE;\n  if (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx)) {\n    result = this.AddOutPt(e1, pt);\n    e2.OutIdx = e1.OutIdx;\n    e1.Side = ClipperLib.EdgeSide.esLeft;\n    e2.Side = ClipperLib.EdgeSide.esRight;\n    e = e1;\n    if (e.PrevInAEL === e2)\n      prevE = e2.PrevInAEL;\n    else\n      prevE = e.PrevInAEL;\n  } else {\n    result = this.AddOutPt(e2, pt);\n    e1.OutIdx = e2.OutIdx;\n    e1.Side = ClipperLib.EdgeSide.esRight;\n    e2.Side = ClipperLib.EdgeSide.esLeft;\n    e = e2;\n    if (e.PrevInAEL === e1)\n      prevE = e1.PrevInAEL;\n    else\n      prevE = e.PrevInAEL;\n  }\n\n  if (prevE !== null && prevE.OutIdx >= 0 && prevE.Top[1] < pt[1] && e.Top[1] < pt[1]) {\n    var xPrev = ClipperLib.Clipper.TopX(prevE, pt[1]);\n    var xE = ClipperLib.Clipper.TopX(e, pt[1]);\n    if ((xPrev === xE) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0) && ClipperLib.ClipperBase.SlopesEqual5([xPrev, pt[1]], prevE.Top, [xE, pt[1]], e.Top)) {\n      var outPt = this.AddOutPt(prevE, pt);\n      this.AddJoin(result, outPt, e.Top);\n    }\n  }\n  return result;\n};\n\nClipperLib.Clipper.prototype.AddOutPt = function (e, pt) {\n  if (e.OutIdx < 0) {\n    var outRec = this.CreateOutRec();\n    outRec.IsOpen = (e.WindDelta === 0);\n    var newOp = new ClipperLib.OutPt();\n    outRec.Pts = newOp;\n    newOp.Idx = outRec.Idx;\n    //newOp.Pt = pt;\n    newOp.Pt[0] = pt[0];\n    newOp.Pt[1] = pt[1];\n    newOp.Next = newOp;\n    newOp.Prev = newOp;\n    if (!outRec.IsOpen)\n      this.SetHoleState(e, outRec);\n    e.OutIdx = outRec.Idx;\n    //nb: do this after SetZ !\n    return newOp;\n  } else {\n    var outRec = this.m_PolyOuts[e.OutIdx];\n    //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\n    var op = outRec.Pts;\n    var ToFront = (e.Side === ClipperLib.EdgeSide.esLeft);\n    if (ToFront && ClipperLib.FPoint_op_Equality(pt, op.Pt))\n      return op;\n    else if (!ToFront && ClipperLib.FPoint_op_Equality(pt, op.Prev.Pt))\n      return op.Prev;\n    var newOp = new ClipperLib.OutPt();\n    newOp.Idx = outRec.Idx;\n    //newOp.Pt = pt;\n    newOp.Pt[0] = pt[0];\n    newOp.Pt[1] = pt[1];\n    newOp.Next = op;\n    newOp.Prev = op.Prev;\n    newOp.Prev.Next = newOp;\n    op.Prev = newOp;\n    if (ToFront)\n      outRec.Pts = newOp;\n    return newOp;\n  }\n};\n\nClipperLib.Clipper.prototype.GetLastOutPt = function (e) {\n  var outRec = this.m_PolyOuts[e.OutIdx];\n  if (e.Side === ClipperLib.EdgeSide.esLeft) {\n    return outRec.Pts;\n  } else {\n    return outRec.Pts.Prev;\n  }\n};\n\nClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2) {\n  var tmp = [...pt1.Value]\n  //pt1.Value = pt2.Value;\n  pt1.Value[0] = pt2.Value[0];\n  pt1.Value[1] = pt2.Value[1];\n  //pt2.Value = tmp;\n  pt2.Value[0] = tmp[0];\n  pt2.Value[1] = tmp[1];\n};\n\nClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (seg1a, seg1b, seg2a, seg2b) {\n  var tmp;\n  if (seg1a > seg1b) {\n    tmp = seg1a;\n    seg1a = seg1b;\n    seg1b = tmp;\n  }\n  if (seg2a > seg2b) {\n    tmp = seg2a;\n    seg2a = seg2b;\n    seg2b = tmp;\n  }\n  return (seg1a < seg2b) && (seg2a < seg1b);\n}\n\nClipperLib.Clipper.prototype.SetHoleState = function (e, outRec) {\n  var e2 = e.PrevInAEL;\n  var eTmp = null;\n  while (e2 !== null) {\n    if (e2.OutIdx >= 0 && e2.WindDelta !== 0) {\n      if (eTmp === null)\n        eTmp = e2;\n      else if (eTmp.OutIdx === e2.OutIdx)\n        eTmp = null; //paired\n    }\n    e2 = e2.PrevInAEL;\n  }\n\n  if (eTmp === null) {\n    outRec.FirstLeft = null;\n    outRec.IsHole = false;\n  } else {\n    outRec.FirstLeft = this.m_PolyOuts[eTmp.OutIdx];\n    outRec.IsHole = !outRec.FirstLeft.IsHole;\n  }\n};\n\nClipperLib.Clipper.prototype.GetDx = function (pt1, pt2) {\n  if (pt1[1] === pt2[1])\n    return ClipperLib.ClipperBase.horizontal;\n  else\n    return (pt2[0] - pt1[0]) / (pt2[1] - pt1[1]);\n};\n\nClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2) {\n  var p = btmPt1.Prev;\n  while ((ClipperLib.FPoint_op_Equality(p.Pt, btmPt1.Pt)) && (p !== btmPt1))\n    p = p.Prev;\n  var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n  p = btmPt1.Next;\n  while ((ClipperLib.FPoint_op_Equality(p.Pt, btmPt1.Pt)) && (p !== btmPt1))\n    p = p.Next;\n  var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n  p = btmPt2.Prev;\n  while ((ClipperLib.FPoint_op_Equality(p.Pt, btmPt2.Pt)) && (p !== btmPt2))\n    p = p.Prev;\n  var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n  p = btmPt2.Next;\n  while ((ClipperLib.FPoint_op_Equality(p.Pt, btmPt2.Pt)) && (p !== btmPt2))\n    p = p.Next;\n  var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n\n  if (Math.max(dx1p, dx1n) === Math.max(dx2p, dx2n) && Math.min(dx1p, dx1n) === Math.min(dx2p, dx2n)) {\n    return this.Area(btmPt1) > 0; //if otherwise identical use orientation\n  } else {\n    return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);\n  }\n};\n\nClipperLib.Clipper.prototype.GetBottomPt = function (pp) {\n  var dups = null;\n  var p = pp.Next;\n  while (p !== pp) {\n    if (p.Pt[1] > pp.Pt[1]) {\n      pp = p;\n      dups = null;\n    } else if (p.Pt[1] === pp.Pt[1] && p.Pt[0] <= pp.Pt[0]) {\n      if (p.Pt[0] < pp.Pt[0]) {\n        dups = null;\n        pp = p;\n      } else {\n        if (p.Next !== pp && p.Prev !== pp)\n          dups = p;\n      }\n    }\n    p = p.Next;\n  }\n  if (dups !== null) {\n    //there appears to be at least 2 vertices at bottomPt so ...\n    while (dups !== p) {\n      if (!this.FirstIsBottomPt(p, dups))\n        pp = dups;\n      dups = dups.Next;\n      while (ClipperLib.FPoint_op_Inequality(dups.Pt, pp.Pt))\n        dups = dups.Next;\n    }\n  }\n  return pp;\n};\n\nClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2) {\n  //work out which polygon fragment has the correct hole state ...\n  if (outRec1.BottomPt === null)\n    outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);\n  if (outRec2.BottomPt === null)\n    outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);\n  var bPt1 = outRec1.BottomPt;\n  var bPt2 = outRec2.BottomPt;\n  if (bPt1.Pt[1] > bPt2.Pt[1])\n    return outRec1;\n  else if (bPt1.Pt[1] < bPt2.Pt[1])\n    return outRec2;\n  else if (bPt1.Pt[0] < bPt2.Pt[0])\n    return outRec1;\n  else if (bPt1.Pt[0] > bPt2.Pt[0])\n    return outRec2;\n  else if (bPt1.Next === bPt1)\n    return outRec2;\n  else if (bPt2.Next === bPt2)\n    return outRec1;\n  else if (this.FirstIsBottomPt(bPt1, bPt2))\n    return outRec1;\n  else\n    return outRec2;\n};\n\nClipperLib.Clipper.prototype.OutRec1RightOfOutRec2 = function (outRec1, outRec2) {\n  do {\n    outRec1 = outRec1.FirstLeft;\n    if (outRec1 === outRec2)\n      return true;\n  }\n  while (outRec1 !== null)\n  return false;\n};\n\nClipperLib.Clipper.prototype.GetOutRec = function (idx) {\n  var outrec = this.m_PolyOuts[idx];\n  while (outrec !== this.m_PolyOuts[outrec.Idx])\n    outrec = this.m_PolyOuts[outrec.Idx];\n  return outrec;\n};\n\nClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2) {\n  //get the start and ends of both output polygons ...\n  var outRec1 = this.m_PolyOuts[e1.OutIdx];\n  var outRec2 = this.m_PolyOuts[e2.OutIdx];\n  var holeStateRec;\n  if (this.OutRec1RightOfOutRec2(outRec1, outRec2))\n    holeStateRec = outRec2;\n  else if (this.OutRec1RightOfOutRec2(outRec2, outRec1))\n    holeStateRec = outRec1;\n  else\n    holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\n  //get the start and ends of both output polygons and\n  //join E2 poly onto E1 poly and delete pointers to E2 ...\n\n  var p1_lft = outRec1.Pts;\n  var p1_rt = p1_lft.Prev;\n  var p2_lft = outRec2.Pts;\n  var p2_rt = p2_lft.Prev;\n  //join e2 poly onto e1 poly and delete pointers to e2 ...\n  if (e1.Side === ClipperLib.EdgeSide.esLeft) {\n    if (e2.Side === ClipperLib.EdgeSide.esLeft) {\n      //z y x a b c\n      this.ReversePolyPtLinks(p2_lft);\n      p2_lft.Next = p1_lft;\n      p1_lft.Prev = p2_lft;\n      p1_rt.Next = p2_rt;\n      p2_rt.Prev = p1_rt;\n      outRec1.Pts = p2_rt;\n    } else {\n      //x y z a b c\n      p2_rt.Next = p1_lft;\n      p1_lft.Prev = p2_rt;\n      p2_lft.Prev = p1_rt;\n      p1_rt.Next = p2_lft;\n      outRec1.Pts = p2_lft;\n    }\n  } else {\n    if (e2.Side === ClipperLib.EdgeSide.esRight) {\n      //a b c z y x\n      this.ReversePolyPtLinks(p2_lft);\n      p1_rt.Next = p2_rt;\n      p2_rt.Prev = p1_rt;\n      p2_lft.Next = p1_lft;\n      p1_lft.Prev = p2_lft;\n    } else {\n      //a b c x y z\n      p1_rt.Next = p2_lft;\n      p2_lft.Prev = p1_rt;\n      p1_lft.Prev = p2_rt;\n      p2_rt.Next = p1_lft;\n    }\n  }\n  outRec1.BottomPt = null;\n  if (holeStateRec === outRec2) {\n    if (outRec2.FirstLeft !== outRec1)\n      outRec1.FirstLeft = outRec2.FirstLeft;\n    outRec1.IsHole = outRec2.IsHole;\n  }\n  outRec2.Pts = null;\n  outRec2.BottomPt = null;\n  outRec2.FirstLeft = outRec1;\n  var OKIdx = e1.OutIdx;\n  var ObsoleteIdx = e2.OutIdx;\n  e1.OutIdx = -1;\n  //nb: safe because we only get here via AddLocalMaxPoly\n  e2.OutIdx = -1;\n  var e = this.m_ActiveEdges;\n  while (e !== null) {\n    if (e.OutIdx === ObsoleteIdx) {\n      e.OutIdx = OKIdx;\n      e.Side = e1.Side;\n      break;\n    }\n    e = e.NextInAEL;\n  }\n  outRec2.Idx = outRec1.Idx;\n};\n\nClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp) {\n  if (pp === null)\n    return;\n  var pp1;\n  var pp2;\n  pp1 = pp;\n  do {\n    pp2 = pp1.Next;\n    pp1.Next = pp1.Prev;\n    pp1.Prev = pp2;\n    pp1 = pp2;\n  }\n  while (pp1 !== pp)\n};\n\nClipperLib.Clipper.SwapSides = function (edge1, edge2) {\n  var side = edge1.Side;\n  edge1.Side = edge2.Side;\n  edge2.Side = side;\n};\n\nClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2) {\n  var outIdx = edge1.OutIdx;\n  edge1.OutIdx = edge2.OutIdx;\n  edge2.OutIdx = outIdx;\n};\n\nClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt) {\n  //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before\n  //e2 in AEL except when e1 is being inserted at the intersection point ...\n  var e1Contributing = (e1.OutIdx >= 0);\n  var e2Contributing = (e2.OutIdx >= 0);\n\n  if (ClipperLib.use_lines) {\n    //if either edge is on an OPEN path ...\n    if (e1.WindDelta === 0 || e2.WindDelta === 0) {\n      //ignore subject-subject open path intersections UNLESS they\n      //are both open paths, AND they are both 'contributing maximas' ...\n      if (e1.WindDelta === 0 && e2.WindDelta === 0) return;\n      //if intersecting a subj line with a subj poly ...\n      else if (e1.PolyTyp === e2.PolyTyp &&\n        e1.WindDelta !== e2.WindDelta && this.m_ClipType === ClipperLib.ClipType.ctUnion) {\n        if (e1.WindDelta === 0) {\n          if (e2Contributing) {\n            this.AddOutPt(e1, pt);\n            if (e1Contributing)\n              e1.OutIdx = -1;\n          }\n        } else {\n          if (e1Contributing) {\n            this.AddOutPt(e2, pt);\n            if (e2Contributing)\n              e2.OutIdx = -1;\n          }\n        }\n      } else if (e1.PolyTyp !== e2.PolyTyp) {\n        if ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) === 1 &&\n          (this.m_ClipType !== ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0)) {\n          this.AddOutPt(e1, pt);\n          if (e1Contributing)\n            e1.OutIdx = -1;\n        } else if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) === 1) &&\n          (this.m_ClipType !== ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0)) {\n          this.AddOutPt(e2, pt);\n          if (e2Contributing)\n            e2.OutIdx = -1;\n        }\n      }\n      return;\n    }\n  }\n  //update winding counts...\n  //assumes that e1 will be to the Right of e2 ABOVE the intersection\n  if (e1.PolyTyp === e2.PolyTyp) {\n    if (this.IsEvenOddFillType(e1)) {\n      var oldE1WindCnt = e1.WindCnt;\n      e1.WindCnt = e2.WindCnt;\n      e2.WindCnt = oldE1WindCnt;\n    } else {\n      if (e1.WindCnt + e2.WindDelta === 0)\n        e1.WindCnt = -e1.WindCnt;\n      else\n        e1.WindCnt += e2.WindDelta;\n      if (e2.WindCnt - e1.WindDelta === 0)\n        e2.WindCnt = -e2.WindCnt;\n      else\n        e2.WindCnt -= e1.WindDelta;\n    }\n  } else {\n    if (!this.IsEvenOddFillType(e2))\n      e1.WindCnt2 += e2.WindDelta;\n    else\n      e1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;\n    if (!this.IsEvenOddFillType(e1))\n      e2.WindCnt2 -= e1.WindDelta;\n    else\n      e2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;\n  }\n  var e1FillType, e2FillType, e1FillType2, e2FillType2;\n  if (e1.PolyTyp === ClipperLib.PolyType.ptSubject) {\n    e1FillType = this.m_SubjFillType;\n    e1FillType2 = this.m_ClipFillType;\n  } else {\n    e1FillType = this.m_ClipFillType;\n    e1FillType2 = this.m_SubjFillType;\n  }\n  if (e2.PolyTyp === ClipperLib.PolyType.ptSubject) {\n    e2FillType = this.m_SubjFillType;\n    e2FillType2 = this.m_ClipFillType;\n  } else {\n    e2FillType = this.m_ClipFillType;\n    e2FillType2 = this.m_SubjFillType;\n  }\n  var e1Wc, e2Wc;\n  switch (e1FillType) {\n    case ClipperLib.PolyFillType.pftPositive:\n      e1Wc = e1.WindCnt;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e1Wc = -e1.WindCnt;\n      break;\n    default:\n      e1Wc = Math.abs(e1.WindCnt);\n      break;\n  }\n  switch (e2FillType) {\n    case ClipperLib.PolyFillType.pftPositive:\n      e2Wc = e2.WindCnt;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e2Wc = -e2.WindCnt;\n      break;\n    default:\n      e2Wc = Math.abs(e2.WindCnt);\n      break;\n  }\n  if (e1Contributing && e2Contributing) {\n    if ((e1Wc !== 0 && e1Wc !== 1) || (e2Wc !== 0 && e2Wc !== 1) ||\n      (e1.PolyTyp !== e2.PolyTyp && this.m_ClipType !== ClipperLib.ClipType.ctXor)) {\n      this.AddLocalMaxPoly(e1, e2, pt);\n    } else {\n      this.AddOutPt(e1, pt);\n      this.AddOutPt(e2, pt);\n      ClipperLib.Clipper.SwapSides(e1, e2);\n      ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n    }\n  } else if (e1Contributing) {\n    if (e2Wc === 0 || e2Wc === 1) {\n      this.AddOutPt(e1, pt);\n      ClipperLib.Clipper.SwapSides(e1, e2);\n      ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n    }\n  } else if (e2Contributing) {\n    if (e1Wc === 0 || e1Wc === 1) {\n      this.AddOutPt(e2, pt);\n      ClipperLib.Clipper.SwapSides(e1, e2);\n      ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n    }\n  } else if ((e1Wc === 0 || e1Wc === 1) && (e2Wc === 0 || e2Wc === 1)) {\n    //neither edge is currently contributing ...\n    var e1Wc2, e2Wc2;\n    switch (e1FillType2) {\n      case ClipperLib.PolyFillType.pftPositive:\n        e1Wc2 = e1.WindCnt2;\n        break;\n      case ClipperLib.PolyFillType.pftNegative:\n        e1Wc2 = -e1.WindCnt2;\n        break;\n      default:\n        e1Wc2 = Math.abs(e1.WindCnt2);\n        break;\n    }\n    switch (e2FillType2) {\n      case ClipperLib.PolyFillType.pftPositive:\n        e2Wc2 = e2.WindCnt2;\n        break;\n      case ClipperLib.PolyFillType.pftNegative:\n        e2Wc2 = -e2.WindCnt2;\n        break;\n      default:\n        e2Wc2 = Math.abs(e2.WindCnt2);\n        break;\n    }\n    if (e1.PolyTyp !== e2.PolyTyp) {\n      this.AddLocalMinPoly(e1, e2, pt);\n    } else if (e1Wc === 1 && e2Wc === 1)\n      switch (this.m_ClipType) {\n        case ClipperLib.ClipType.ctIntersection:\n          if (e1Wc2 > 0 && e2Wc2 > 0)\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctUnion:\n          if (e1Wc2 <= 0 && e2Wc2 <= 0)\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctDifference:\n          if (((e1.PolyTyp === ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\n            ((e1.PolyTyp === ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctXor:\n          this.AddLocalMinPoly(e1, e2, pt);\n          break;\n      }\n    else\n      ClipperLib.Clipper.SwapSides(e1, e2);\n  }\n};\n\nClipperLib.Clipper.prototype.DeleteFromSEL = function (e) {\n  var SelPrev = e.PrevInSEL;\n  var SelNext = e.NextInSEL;\n  if (SelPrev === null && SelNext === null && (e !== this.m_SortedEdges))\n    return;\n  //already deleted\n  if (SelPrev !== null)\n    SelPrev.NextInSEL = SelNext;\n  else\n    this.m_SortedEdges = SelNext;\n  if (SelNext !== null)\n    SelNext.PrevInSEL = SelPrev;\n  e.NextInSEL = null;\n  e.PrevInSEL = null;\n};\n\nClipperLib.Clipper.prototype.ProcessHorizontals = function () {\n  var horzEdge = {}; //m_SortedEdges;\n  while (this.PopEdgeFromSEL(horzEdge)) {\n    this.ProcessHorizontal(horzEdge.v);\n  }\n};\n\nClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var) {\n  if (HorzEdge.Bot[0] < HorzEdge.Top[0]) {\n    $var.Left = HorzEdge.Bot[0];\n    $var.Right = HorzEdge.Top[0];\n    $var.Dir = ClipperLib.Direction.dLeftToRight;\n  } else {\n    $var.Left = HorzEdge.Top[0];\n    $var.Right = HorzEdge.Bot[0];\n    $var.Dir = ClipperLib.Direction.dRightToLeft;\n  }\n};\n\nClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge) {\n  var $var = {\n    Dir: null,\n    Left: null,\n    Right: null\n  };\n\n  this.GetHorzDirection(horzEdge, $var);\n  var dir = $var.Dir;\n  var horzLeft = $var.Left;\n  var horzRight = $var.Right;\n\n  var IsOpen = horzEdge.WindDelta === 0;\n\n  var eLastHorz = horzEdge,\n    eMaxPair = null;\n  while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))\n    eLastHorz = eLastHorz.NextInLML;\n  if (eLastHorz.NextInLML === null)\n    eMaxPair = this.GetMaximaPair(eLastHorz);\n\n  var currMax = this.m_Maxima;\n  if (currMax !== null) {\n    //get the first maxima in range (X) ...\n    if (dir === ClipperLib.Direction.dLeftToRight) {\n      while (currMax !== null && currMax[0] <= horzEdge.Bot[0]) {\n        currMax = currMax.Next;\n      }\n      if (currMax !== null && currMax[0] >= eLastHorz.Top[0]) {\n        currMax = null;\n      }\n    } else {\n      while (currMax.Next !== null && currMax.Next[0] < horzEdge.Bot[0]) {\n        currMax = currMax.Next;\n      }\n      if (currMax[0] <= eLastHorz.Top[0]) {\n        currMax = null;\n      }\n    }\n  }\n  var op1 = null;\n  for (;;) //loop through consec. horizontal edges\n  {\n    var IsLastHorz = (horzEdge === eLastHorz);\n    var e = this.GetNextInAEL(horzEdge, dir);\n    while (e !== null) {\n      //this code block inserts extra coords into horizontal edges (in output\n      //polygons) whereever maxima touch these horizontal edges. This helps\n      //'simplifying' polygons (ie if the Simplify property is set).\n      if (currMax !== null) {\n        if (dir === ClipperLib.Direction.dLeftToRight) {\n          while (currMax !== null && currMax[0] < e.Curr[0]) {\n            if (horzEdge.OutIdx >= 0 && !IsOpen) {\n              this.AddOutPt(horzEdge, [currMax[0], horzEdge.Bot[1]]);\n            }\n            currMax = currMax.Next;\n          }\n        } else {\n          while (currMax !== null && currMax[0] > e.Curr[0]) {\n            if (horzEdge.OutIdx >= 0 && !IsOpen) {\n              this.AddOutPt(horzEdge, [currMax[0], horzEdge.Bot[1]]);\n            }\n            currMax = currMax.Prev;\n          }\n        }\n      }\n\n      if ((dir === ClipperLib.Direction.dLeftToRight && e.Curr[0] > horzRight) || (dir === ClipperLib.Direction.dRightToLeft && e.Curr[0] < horzLeft)) {\n        break;\n      }\n\n      //Also break if we've got to the end of an intermediate horizontal edge ...\n      //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\n      if (e.Curr[0] === horzEdge.Top[0] && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)\n        break;\n\n      if (horzEdge.OutIdx >= 0 && !IsOpen) //note: may be done multiple times\n      {\n        op1 = this.AddOutPt(horzEdge, e.Curr);\n        var eNextHorz = this.m_SortedEdges;\n        while (eNextHorz !== null) {\n          if (eNextHorz.OutIdx >= 0 && this.HorzSegmentsOverlap(horzEdge.Bot[0], horzEdge.Top[0], eNextHorz.Bot[0], eNextHorz.Top[0])) {\n            var op2 = this.GetLastOutPt(eNextHorz);\n            this.AddJoin(op2, op1, eNextHorz.Top);\n          }\n          eNextHorz = eNextHorz.NextInSEL;\n        }\n        this.AddGhostJoin(op1, horzEdge.Bot);\n      }\n\n      //OK, so far we're still in range of the horizontal Edge  but make sure\n      //we're at the last of consec. horizontals when matching with eMaxPair\n      if (e === eMaxPair && IsLastHorz) {\n        if (horzEdge.OutIdx >= 0) {\n          this.AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.Top);\n        }\n        this.DeleteFromAEL(horzEdge);\n        this.DeleteFromAEL(eMaxPair);\n        return;\n      }\n\n      if (dir === ClipperLib.Direction.dLeftToRight) {\n        var Pt = [e.Curr[0], horzEdge.Curr[1]];\n        this.IntersectEdges(horzEdge, e, Pt);\n      } else {\n        var Pt = [e.Curr[0], horzEdge.Curr[1]];\n        this.IntersectEdges(e, horzEdge, Pt);\n      }\n      var eNext = this.GetNextInAEL(e, dir);\n      this.SwapPositionsInAEL(horzEdge, e);\n      e = eNext;\n    } //end while(e !== null)\n\n    //Break out of loop if HorzEdge.NextInLML is not also horizontal ...\n    if (horzEdge.NextInLML === null || !ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML)) {\n      break;\n    }\n\n    horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n    if (horzEdge.OutIdx >= 0) {\n      this.AddOutPt(horzEdge, horzEdge.Bot);\n    }\n\n    $var = {\n      Dir: dir,\n      Left: horzLeft,\n      Right: horzRight\n    };\n\n    this.GetHorzDirection(horzEdge, $var);\n    dir = $var.Dir;\n    horzLeft = $var.Left;\n    horzRight = $var.Right;\n\n  } //end for (;;)\n\n  if (horzEdge.OutIdx >= 0 && op1 === null) {\n    op1 = this.GetLastOutPt(horzEdge);\n    var eNextHorz = this.m_SortedEdges;\n    while (eNextHorz !== null) {\n      if (eNextHorz.OutIdx >= 0 && this.HorzSegmentsOverlap(horzEdge.Bot[0], horzEdge.Top[0], eNextHorz.Bot[0], eNextHorz.Top[0])) {\n        var op2 = this.GetLastOutPt(eNextHorz);\n        this.AddJoin(op2, op1, eNextHorz.Top);\n      }\n      eNextHorz = eNextHorz.NextInSEL;\n    }\n    this.AddGhostJoin(op1, horzEdge.Top);\n  }\n\n  if (horzEdge.NextInLML !== null) {\n    if (horzEdge.OutIdx >= 0) {\n      op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\n      horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n      if (horzEdge.WindDelta === 0) {\n        return;\n      }\n      //nb: HorzEdge is no longer horizontal here\n      var ePrev = horzEdge.PrevInAEL;\n      var eNext = horzEdge.NextInAEL;\n      if (ePrev !== null && ePrev.Curr[0] === horzEdge.Bot[0] && ePrev.Curr[1] === horzEdge.Bot[1] && ePrev.WindDelta === 0 && (ePrev.OutIdx >= 0 && ePrev.Curr[1] > ePrev.Top[1] && ClipperLib.ClipperBase.SlopesEqual3(horzEdge, ePrev))) {\n        var op2 = this.AddOutPt(ePrev, horzEdge.Bot);\n        this.AddJoin(op1, op2, horzEdge.Top);\n      } else if (eNext !== null && eNext.Curr[0] === horzEdge.Bot[0] && eNext.Curr[1] === horzEdge.Bot[1] && eNext.WindDelta !== 0 && eNext.OutIdx >= 0 && eNext.Curr[1] > eNext.Top[1] && ClipperLib.ClipperBase.SlopesEqual3(horzEdge, eNext)) {\n        var op2 = this.AddOutPt(eNext, horzEdge.Bot);\n        this.AddJoin(op1, op2, horzEdge.Top);\n      }\n    } else {\n      horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n    }\n  } else {\n    if (horzEdge.OutIdx >= 0) {\n      this.AddOutPt(horzEdge, horzEdge.Top);\n    }\n    this.DeleteFromAEL(horzEdge);\n  }\n};\n\nClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction) {\n  return Direction === ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;\n};\n\nClipperLib.Clipper.prototype.IsMinima = function (e) {\n  return e !== null && (e.Prev.NextInLML !== e) && (e.Next.NextInLML !== e);\n};\n\nClipperLib.Clipper.prototype.IsMaxima = function (e, Y) {\n  return (e !== null && e.Top[1] === Y && e.NextInLML === null);\n};\n\nClipperLib.Clipper.prototype.IsIntermediate = function (e, Y) {\n  return (e.Top[1] === Y && e.NextInLML !== null);\n};\n\nClipperLib.Clipper.prototype.GetMaximaPair = function (e) {\n  if ((ClipperLib.FPoint_op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null) {\n    return e.Next;\n  } else {\n    if ((ClipperLib.FPoint_op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null) {\n      return e.Prev;\n    } else {\n      return null;\n    }\n  }\n};\n\nClipperLib.Clipper.prototype.GetMaximaPairEx = function (e) {\n  //as above but returns null if MaxPair isn't in AEL (unless it's horizontal)\n  var result = this.GetMaximaPair(e);\n  if (result === null || result.OutIdx === ClipperLib.ClipperBase.Skip ||\n    ((result.NextInAEL === result.PrevInAEL) && !ClipperLib.ClipperBase.IsHorizontal(result))) {\n    return null;\n  }\n  return result;\n};\n\nClipperLib.Clipper.prototype.ProcessIntersections = function (topY) {\n  if (this.m_ActiveEdges === null)\n    return true;\n  try {\n    this.BuildIntersectList(topY);\n    if (this.m_IntersectList.length === 0)\n      return true;\n    if (this.m_IntersectList.length === 1 || this.FixupIntersectionOrder())\n      this.ProcessIntersectList();\n    else\n      return false;\n  } catch ($$e2) {\n    this.m_SortedEdges = null;\n    this.m_IntersectList.length = 0;\n    ClipperLib.Error(\"ProcessIntersections error\");\n  }\n  this.m_SortedEdges = null;\n  return true;\n};\n\nClipperLib.Clipper.prototype.BuildIntersectList = function (topY) {\n  if (this.m_ActiveEdges === null)\n    return;\n  //prepare for sorting ...\n  var e = this.m_ActiveEdges;\n  //console.log(JSON.stringify(JSON.decycle( e )));\n  this.m_SortedEdges = e;\n  while (e !== null) {\n    e.PrevInSEL = e.PrevInAEL;\n    e.NextInSEL = e.NextInAEL;\n    e.Curr[0] = ClipperLib.Clipper.TopX(e, topY);\n    e = e.NextInAEL;\n  }\n  //bubblesort ...\n  var isModified = true;\n  while (isModified && this.m_SortedEdges !== null) {\n    isModified = false;\n    e = this.m_SortedEdges;\n    while (e.NextInSEL !== null) {\n      var eNext = e.NextInSEL;\n      var pt = [0, 0];\n      //console.log(\"e.Curr[0]: \" + e.Curr[0] + \" eNext.Curr[0]\" + eNext.Curr[0]);\n      if (e.Curr[0] > eNext.Curr[0]) {\n        this.IntersectPoint(e, eNext, pt);\n        if (pt[1] < topY) {\n          pt = [ClipperLib.Clipper.TopX(e, topY), topY];\n        }\n        var newNode = new ClipperLib.IntersectNode();\n        newNode.Edge1 = e;\n        newNode.Edge2 = eNext;\n        //newNode.Pt = pt;\n        newNode.Pt[0] = pt[0];\n        newNode.Pt[1] = pt[1];\n        this.m_IntersectList.push(newNode);\n        this.SwapPositionsInSEL(e, eNext);\n        isModified = true;\n      } else\n        e = eNext;\n    }\n    if (e.PrevInSEL !== null)\n      e.PrevInSEL.NextInSEL = null;\n    else\n      break;\n  }\n  this.m_SortedEdges = null;\n};\n\nClipperLib.Clipper.prototype.EdgesAdjacent = function (inode) {\n  return (inode.Edge1.NextInSEL === inode.Edge2) || (inode.Edge1.PrevInSEL === inode.Edge2);\n};\n\nClipperLib.Clipper.IntersectNodeSort = function (node1, node2) {\n  //the following typecast is safe because the differences in Pt[1] will\n  //be limited to the height of the scanbeam.\n  return (node2.Pt[1] - node1.Pt[1]);\n};\n\nClipperLib.Clipper.prototype.FixupIntersectionOrder = function () {\n  //pre-condition: intersections are sorted bottom-most first.\n  //Now it's crucial that intersections are made only between adjacent edges,\n  //so to ensure this the order of intersections may need adjusting ...\n  this.m_IntersectList.sort(this.m_IntersectNodeComparer);\n  this.CopyAELToSEL();\n  var cnt = this.m_IntersectList.length;\n  for (var i = 0; i < cnt; i++) {\n    if (!this.EdgesAdjacent(this.m_IntersectList[i])) {\n      var j = i + 1;\n      while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))\n        j++;\n      if (j === cnt)\n        return false;\n      var tmp = this.m_IntersectList[i];\n      this.m_IntersectList[i] = this.m_IntersectList[j];\n      this.m_IntersectList[j] = tmp;\n    }\n    this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);\n  }\n  return true;\n};\n\nClipperLib.Clipper.prototype.ProcessIntersectList = function () {\n  for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++) {\n    var iNode = this.m_IntersectList[i];\n    this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt);\n    this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);\n  }\n  this.m_IntersectList.length = 0;\n};\n\nClipperLib.Clipper.TopX = function (edge, currentY) {\n  //if (edge.Bot == edge.Curr) alert (\"edge.Bot = edge.Curr\");\n  //if (edge.Bot == edge.Top) alert (\"edge.Bot = edge.Top\");\n  if (currentY === edge.Top[1])\n    return edge.Top[0];\n  return edge.Bot[0] + edge.Dx * (currentY - edge.Bot[1]);\n};\n\nClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip) {\n  ip[0] = 0;\n  ip[1] = 0;\n  var b1, b2;\n  //nb: with very large coordinate values, it's possible for SlopesEqual() to\n  //return false but for the edge.Dx value be equal due to double precision rounding.\n  if (edge1.Dx === edge2.Dx) {\n    ip[1] = edge1.Curr[1];\n    ip[0] = ClipperLib.Clipper.TopX(edge1, ip[1]);\n    return;\n  }\n  if (edge1.Delta[0] === 0) {\n    ip[0] = edge1.Bot[0];\n    if (ClipperLib.ClipperBase.IsHorizontal(edge2)) {\n      ip[1] = edge2.Bot[1];\n    } else {\n      b2 = edge2.Bot[1] - (edge2.Bot[0] / edge2.Dx);\n      ip[1] = ip[0] / edge2.Dx + b2;\n    }\n  } else if (edge2.Delta[0] === 0) {\n    ip[0] = edge2.Bot[0];\n    if (ClipperLib.ClipperBase.IsHorizontal(edge1)) {\n      ip[1] = edge1.Bot[1];\n    } else {\n      b1 = edge1.Bot[1] - (edge1.Bot[0] / edge1.Dx);\n      ip[1] = ip[0] / edge1.Dx + b1;\n    }\n  } else {\n    b1 = edge1.Bot[0] - edge1.Bot[1] * edge1.Dx;\n    b2 = edge2.Bot[0] - edge2.Bot[1] * edge2.Dx;\n    var q = (b2 - b1) / (edge1.Dx - edge2.Dx);\n    ip[1] = q;\n    if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n      ip[0] = edge1.Dx * q + b1;\n    else\n      ip[0] = edge2.Dx * q + b2;\n  }\n  if (ip[1] < edge1.Top[1] || ip[1] < edge2.Top[1]) {\n    if (edge1.Top[1] > edge2.Top[1]) {\n      ip[1] = edge1.Top[1];\n      ip[0] = ClipperLib.Clipper.TopX(edge2, edge1.Top[1]);\n      return ip[0] < edge1.Top[0];\n    } else\n      ip[1] = edge2.Top[1];\n    if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n      ip[0] = ClipperLib.Clipper.TopX(edge1, ip[1]);\n    else\n      ip[0] = ClipperLib.Clipper.TopX(edge2, ip[1]);\n  }\n  //finally, don't allow 'ip' to be BELOW curr[1] (ie bottom of scanbeam) ...\n  if (ip[1] > edge1.Curr[1]) {\n    ip[1] = edge1.Curr[1];\n    //better to use the more vertical edge to derive X ...\n    if (Math.abs(edge1.Dx) > Math.abs(edge2.Dx))\n      ip[0] = ClipperLib.Clipper.TopX(edge2, ip[1]);\n    else\n      ip[0] = ClipperLib.Clipper.TopX(edge1, ip[1]);\n  }\n};\n\nClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY) {\n  var e = this.m_ActiveEdges;\n\n  while (e !== null) {\n    //1. process maxima, treating them as if they're 'bent' horizontal edges,\n    //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\n    var IsMaximaEdge = this.IsMaxima(e, topY);\n    if (IsMaximaEdge) {\n      var eMaxPair = this.GetMaximaPairEx(e);\n      IsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));\n    }\n    if (IsMaximaEdge) {\n      if (this.StrictlySimple) {\n        this.InsertMaxima(e.Top[0]);\n      }\n      var ePrev = e.PrevInAEL;\n      this.DoMaxima(e);\n      if (ePrev === null)\n        e = this.m_ActiveEdges;\n      else\n        e = ePrev.NextInAEL;\n    } else {\n      //2. promote horizontal edges, otherwise update Curr[0] and Curr[1] ...\n      if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML)) {\n        e = this.UpdateEdgeIntoAEL(e);\n        if (e.OutIdx >= 0)\n          this.AddOutPt(e, e.Bot);\n        this.AddEdgeToSEL(e);\n      } else {\n        e.Curr[0] = ClipperLib.Clipper.TopX(e, topY);\n        e.Curr[1] = topY;\n      }\n\n      //When StrictlySimple and 'e' is being touched by another edge, then\n      //make sure both edges have a vertex here ...\n      if (this.StrictlySimple) {\n        var ePrev = e.PrevInAEL;\n        if ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&\n          (ePrev.OutIdx >= 0) && (ePrev.Curr[0] === e.Curr[0]) &&\n          (ePrev.WindDelta !== 0)) {\n          var ip = [...e.Curr];\n\n          var op = this.AddOutPt(ePrev, ip);\n          var op2 = this.AddOutPt(e, ip);\n          this.AddJoin(op, op2, ip); //StrictlySimple (type-3) join\n        }\n      }\n      e = e.NextInAEL;\n    }\n  }\n  //3. Process horizontals at the Top of the scanbeam ...\n  this.ProcessHorizontals();\n  this.m_Maxima = null;\n  //4. Promote intermediate vertices ...\n  e = this.m_ActiveEdges;\n  while (e !== null) {\n    if (this.IsIntermediate(e, topY)) {\n      var op = null;\n      if (e.OutIdx >= 0)\n        op = this.AddOutPt(e, e.Top);\n      e = this.UpdateEdgeIntoAEL(e);\n      //if output polygons share an edge, they'll need joining later ...\n      var ePrev = e.PrevInAEL;\n      var eNext = e.NextInAEL;\n\n      if (ePrev !== null && ePrev.Curr[0] === e.Bot[0] && ePrev.Curr[1] === e.Bot[1] && op !== null && ePrev.OutIdx >= 0 && ePrev.Curr[1] === ePrev.Top[1] && ClipperLib.ClipperBase.SlopesEqual5(e.Curr, e.Top, ePrev.Curr, ePrev.Top) && (e.WindDelta !== 0) && (ePrev.WindDelta !== 0)) {\n        var op2 = this.AddOutPt(ePrev2, e.Bot);\n        this.AddJoin(op, op2, e.Top);\n      } else if (eNext !== null && eNext.Curr[0] === e.Bot[0] && eNext.Curr[1] === e.Bot[1] && op !== null && eNext.OutIdx >= 0 && eNext.Curr[1] === eNext.Top[1] && ClipperLib.ClipperBase.SlopesEqual5(e.Curr, e.Top, eNext.Curr, eNext.Top) && (e.WindDelta !== 0) && (eNext.WindDelta !== 0)) {\n        var op2 = this.AddOutPt(eNext, e.Bot);\n        this.AddJoin(op, op2, e.Top);\n      }\n    }\n    e = e.NextInAEL;\n  }\n};\n\nClipperLib.Clipper.prototype.DoMaxima = function (e) {\n  var eMaxPair = this.GetMaximaPairEx(e);\n  if (eMaxPair === null) {\n    if (e.OutIdx >= 0)\n      this.AddOutPt(e, e.Top);\n    this.DeleteFromAEL(e);\n    return;\n  }\n  var eNext = e.NextInAEL;\n  while (eNext !== null && eNext !== eMaxPair) {\n    this.IntersectEdges(e, eNext, e.Top);\n    this.SwapPositionsInAEL(e, eNext);\n    eNext = e.NextInAEL;\n  }\n  if (e.OutIdx === -1 && eMaxPair.OutIdx === -1) {\n    this.DeleteFromAEL(e);\n    this.DeleteFromAEL(eMaxPair);\n  } else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0) {\n    if (e.OutIdx >= 0) this.AddLocalMaxPoly(e, eMaxPair, e.Top);\n    this.DeleteFromAEL(e);\n    this.DeleteFromAEL(eMaxPair);\n  } else if (ClipperLib.use_lines && e.WindDelta === 0) {\n    if (e.OutIdx >= 0) {\n      this.AddOutPt(e, e.Top);\n      e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n    }\n    this.DeleteFromAEL(e);\n    if (eMaxPair.OutIdx >= 0) {\n      this.AddOutPt(eMaxPair, e.Top);\n      eMaxPair.OutIdx = ClipperLib.ClipperBase.Unassigned;\n    }\n    this.DeleteFromAEL(eMaxPair);\n  } else\n    ClipperLib.Error(\"DoMaxima error\");\n};\n\nClipperLib.Clipper.ReversePaths = function (polys) {\n  for (var i = 0, len = polys.length; i < len; i++)\n    polys[i].reverse();\n};\n\nClipperLib.Clipper.Orientation = function (poly) {\n  return ClipperLib.Clipper.Area(poly) >= 0;\n};\n\nClipperLib.Clipper.prototype.PointCount = function (pts) {\n  if (pts === null)\n    return 0;\n  var result = 0;\n  var p = pts;\n  do {\n    result++;\n    p = p.Next;\n  }\n  while (p !== pts)\n  return result;\n};\n\nClipperLib.Clipper.prototype.BuildResult = function (polyg) {\n  ClipperLib.Clear(polyg);\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n    var outRec = this.m_PolyOuts[i];\n    if (outRec.Pts === null)\n      continue;\n    var p = outRec.Pts.Prev;\n    var cnt = this.PointCount(p);\n    if (cnt < 2)\n      continue;\n    var pg = new Array(cnt);\n    for (var j = 0; j < cnt; j++) {\n      pg[j] = p.Pt;\n      p = p.Prev;\n    }\n    polyg.push(pg);\n  }\n};\n\nClipperLib.Clipper.prototype.BuildResult2 = function (polytree) {\n  polytree.Clear();\n  //add each output polygon/contour to polytree ...\n  //polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n    var outRec = this.m_PolyOuts[i];\n    var cnt = this.PointCount(outRec.Pts);\n    if ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))\n      continue;\n    this.FixHoleLinkage(outRec);\n    var pn = new ClipperLib.PolyNode();\n    polytree.m_AllPolys.push(pn);\n    outRec.PolyNode = pn;\n    pn.m_polygon.length = cnt;\n    var op = outRec.Pts.Prev;\n    for (var j = 0; j < cnt; j++) {\n      pn.m_polygon[j] = op.Pt;\n      op = op.Prev;\n    }\n  }\n  //fixup PolyNode links etc ...\n  //polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n    var outRec = this.m_PolyOuts[i];\n    if (outRec.PolyNode === null)\n      continue;\n    else if (outRec.IsOpen) {\n      outRec.PolyNode.IsOpen = true;\n      polytree.AddChild(outRec.PolyNode);\n    } else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode !== null)\n      outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);\n    else\n      polytree.AddChild(outRec.PolyNode);\n  }\n};\n\nClipperLib.Clipper.prototype.FixupOutPolyline = function (outRec) {\n  var pp = outRec.Pts;\n  var lastPP = pp.Prev;\n  while (pp !== lastPP) {\n    pp = pp.Next;\n    if (ClipperLib.FPoint_op_Equality(pp.Pt, pp.Prev.Pt)) {\n      if (pp === lastPP) {\n        lastPP = pp.Prev;\n      }\n      var tmpPP = pp.Prev;\n      tmpPP.Next = pp.Next;\n      pp.Next.Prev = tmpPP;\n      pp = tmpPP;\n    }\n  }\n  if (pp === pp.Prev) {\n    outRec.Pts = null;\n  }\n};\n\nClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec) {\n  //FixupOutPolygon() - removes duplicate points and simplifies consecutive\n  //parallel edges by removing the middle vertex.\n  var lastOK = null;\n  outRec.BottomPt = null;\n  var pp = outRec.Pts;\n  var preserveCol = this.PreserveCollinear || this.StrictlySimple;\n  for (;;) {\n    if (pp.Prev === pp || pp.Prev === pp.Next) {\n      outRec.Pts = null;\n      return;\n    }\n\n    //test for duplicate points and collinear edges ...\n    if ((ClipperLib.FPoint_op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.FPoint_op_Equality(pp.Pt, pp.Prev.Pt)) || (ClipperLib.ClipperBase.SlopesEqual4(pp.Prev.Pt, pp.Pt, pp.Next.Pt) && (!preserveCol || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt)))) {\n      lastOK = null;\n      pp.Prev.Next = pp.Next;\n      pp.Next.Prev = pp.Prev;\n      pp = pp.Prev;\n    } else if (pp === lastOK)\n      break;\n    else {\n      if (lastOK === null)\n        lastOK = pp;\n      pp = pp.Next;\n    }\n  }\n  outRec.Pts = pp;\n};\n\nClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter) {\n  var result = new ClipperLib.OutPt();\n  //result.Pt = outPt.Pt;\n  result.Pt[0] = outPt.Pt[0];\n  result.Pt[1] = outPt.Pt[1];\n  result.Idx = outPt.Idx;\n  if (InsertAfter) {\n    result.Next = outPt.Next;\n    result.Prev = outPt;\n    outPt.Next.Prev = result;\n    outPt.Next = result;\n  } else {\n    result.Prev = outPt.Prev;\n    result.Next = outPt;\n    outPt.Prev.Next = result;\n    outPt.Prev = result;\n  }\n  return result;\n};\n\nClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val) {\n  if (a1 < a2) {\n    if (b1 < b2) {\n      $val.Left = Math.max(a1, b1);\n      $val.Right = Math.min(a2, b2);\n    } else {\n      $val.Left = Math.max(a1, b2);\n      $val.Right = Math.min(a2, b1);\n    }\n  } else {\n    if (b1 < b2) {\n      $val.Left = Math.max(a2, b1);\n      $val.Right = Math.min(a1, b2);\n    } else {\n      $val.Left = Math.max(a2, b2);\n      $val.Right = Math.min(a1, b1);\n    }\n  }\n  return $val.Left < $val.Right;\n};\n\nClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft) {\n  var Dir1 = (op1.Pt[0] > op1b.Pt[0] ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n  var Dir2 = (op2.Pt[0] > op2b.Pt[0] ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n  if (Dir1 === Dir2)\n    return false;\n  //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\n  //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\n  //So, to facilitate this while inserting Op1b and Op2b ...\n  //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\n  //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\n  if (Dir1 === ClipperLib.Direction.dLeftToRight) {\n    while (op1.Next.Pt[0] <= Pt[0] &&\n      op1.Next.Pt[0] >= op1.Pt[0] && op1.Next.Pt[1] === Pt[1])\n      op1 = op1.Next;\n    if (DiscardLeft && (op1.Pt[0] !== Pt[0]))\n      op1 = op1.Next;\n    op1b = this.DupOutPt(op1, !DiscardLeft);\n    if (ClipperLib.FPoint_op_Inequality(op1b.Pt, Pt)) {\n      op1 = op1b;\n      //op1.Pt = Pt;\n      op1.Pt[0] = Pt[0];\n      op1.Pt[1] = Pt[1];\n      op1b = this.DupOutPt(op1, !DiscardLeft);\n    }\n  } else {\n    while (op1.Next.Pt[0] >= Pt[0] &&\n      op1.Next.Pt[0] <= op1.Pt[0] && op1.Next.Pt[1] === Pt[1])\n      op1 = op1.Next;\n    if (!DiscardLeft && (op1.Pt[0] !== Pt[0]))\n      op1 = op1.Next;\n    op1b = this.DupOutPt(op1, DiscardLeft);\n    if (ClipperLib.FPoint_op_Inequality(op1b.Pt, Pt)) {\n      op1 = op1b;\n      //op1.Pt = Pt;\n      op1.Pt[0] = Pt[0];\n      op1.Pt[1] = Pt[1];\n      op1b = this.DupOutPt(op1, DiscardLeft);\n    }\n  }\n  if (Dir2 === ClipperLib.Direction.dLeftToRight) {\n    while (op2.Next.Pt[0] <= Pt[0] &&\n      op2.Next.Pt[0] >= op2.Pt[0] && op2.Next.Pt[1] === Pt[1])\n      op2 = op2.Next;\n    if (DiscardLeft && (op2.Pt[0] !== Pt[0]))\n      op2 = op2.Next;\n    op2b = this.DupOutPt(op2, !DiscardLeft);\n    if (ClipperLib.FPoint_op_Inequality(op2b.Pt, Pt)) {\n      op2 = op2b;\n      //op2.Pt = Pt;\n      op2.Pt[0] = Pt[0];\n      op2.Pt[1] = Pt[1];\n      op2b = this.DupOutPt(op2, !DiscardLeft);\n    }\n  } else {\n    while (op2.Next.Pt[0] >= Pt[0] &&\n      op2.Next.Pt[0] <= op2.Pt[0] && op2.Next.Pt[1] === Pt[1])\n      op2 = op2.Next;\n    if (!DiscardLeft && (op2.Pt[0] !== Pt[0]))\n      op2 = op2.Next;\n    op2b = this.DupOutPt(op2, DiscardLeft);\n    if (ClipperLib.FPoint_op_Inequality(op2b.Pt, Pt)) {\n      op2 = op2b;\n      //op2.Pt = Pt;\n      op2.Pt[0] = Pt[0];\n      op2.Pt[1] = Pt[1];\n      op2b = this.DupOutPt(op2, DiscardLeft);\n    }\n  }\n  if ((Dir1 === ClipperLib.Direction.dLeftToRight) === DiscardLeft) {\n    op1.Prev = op2;\n    op2.Next = op1;\n    op1b.Next = op2b;\n    op2b.Prev = op1b;\n  } else {\n    op1.Next = op2;\n    op2.Prev = op1;\n    op1b.Prev = op2b;\n    op2b.Next = op1b;\n  }\n  return true;\n};\n\nClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2) {\n  var op1 = j.OutPt1,\n    op1b = new ClipperLib.OutPt();\n  var op2 = j.OutPt2,\n    op2b = new ClipperLib.OutPt();\n  //There are 3 kinds of joins for output polygons ...\n  //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are vertices anywhere\n  //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\n  //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\n  //location at the Bottom of the overlapping segment (& Join.OffPt is above).\n  //3. StrictlySimple joins where edges touch but are not collinear and where\n  //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\n  var isHorizontal = (j.OutPt1.Pt[1] === j.OffPt[1]);\n  if (isHorizontal && (ClipperLib.FPoint_op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.FPoint_op_Equality(j.OffPt, j.OutPt2.Pt))) {\n    //Strictly Simple join ...\n    if (outRec1 !== outRec2) return false;\n\n    op1b = j.OutPt1.Next;\n    while (op1b !== op1 && (ClipperLib.FPoint_op_Equality(op1b.Pt, j.OffPt)))\n      op1b = op1b.Next;\n    var reverse1 = (op1b.Pt[1] > j.OffPt[1]);\n    op2b = j.OutPt2.Next;\n    while (op2b !== op2 && (ClipperLib.FPoint_op_Equality(op2b.Pt, j.OffPt)))\n      op2b = op2b.Next;\n    var reverse2 = (op2b.Pt[1] > j.OffPt[1]);\n    if (reverse1 === reverse2)\n      return false;\n    if (reverse1) {\n      op1b = this.DupOutPt(op1, false);\n      op2b = this.DupOutPt(op2, true);\n      op1.Prev = op2;\n      op2.Next = op1;\n      op1b.Next = op2b;\n      op2b.Prev = op1b;\n      j.OutPt1 = op1;\n      j.OutPt2 = op1b;\n      return true;\n    } else {\n      op1b = this.DupOutPt(op1, true);\n      op2b = this.DupOutPt(op2, false);\n      op1.Next = op2;\n      op2.Prev = op1;\n      op1b.Prev = op2b;\n      op2b.Next = op1b;\n      j.OutPt1 = op1;\n      j.OutPt2 = op1b;\n      return true;\n    }\n  } else if (isHorizontal) {\n    //treat horizontal joins differently to non-horizontal joins since with\n    //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\n    //may be anywhere along the horizontal edge.\n    op1b = op1;\n    while (op1.Prev.Pt[1] === op1.Pt[1] && op1.Prev !== op1b && op1.Prev !== op2)\n      op1 = op1.Prev;\n    while (op1b.Next.Pt[1] === op1b.Pt[1] && op1b.Next !== op1 && op1b.Next !== op2)\n      op1b = op1b.Next;\n    if (op1b.Next === op1 || op1b.Next === op2)\n      return false;\n    //a flat 'polygon'\n    op2b = op2;\n    while (op2.Prev.Pt[1] === op2.Pt[1] && op2.Prev !== op2b && op2.Prev !== op1b)\n      op2 = op2.Prev;\n    while (op2b.Next.Pt[1] === op2b.Pt[1] && op2b.Next !== op2 && op2b.Next !== op1)\n      op2b = op2b.Next;\n    if (op2b.Next === op2 || op2b.Next === op1)\n      return false;\n    //a flat 'polygon'\n    //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges\n\n    var $val = {\n      Left: null,\n      Right: null\n    };\n\n    if (!this.GetOverlap(op1.Pt[0], op1b.Pt[0], op2.Pt[0], op2b.Pt[0], $val))\n      return false;\n    var Left = $val.Left;\n    var Right = $val.Right;\n\n    //DiscardLeftSide: when overlapping edges are joined, a spike will created\n    //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\n    //on the discard Side as either may still be needed for other joins ...\n    var Pt = [0, 0];\n    var DiscardLeftSide;\n    if (op1.Pt[0] >= Left && op1.Pt[0] <= Right) {\n      //Pt = op1.Pt;\n      Pt[0] = op1.Pt[0];\n      Pt[1] = op1.Pt[1];\n      DiscardLeftSide = (op1.Pt[0] > op1b.Pt[0]);\n    } else if (op2.Pt[0] >= Left && op2.Pt[0] <= Right) {\n      //Pt = op2.Pt;\n      Pt[0] = op2.Pt[0];\n      Pt[1] = op2.Pt[1];\n      DiscardLeftSide = (op2.Pt[0] > op2b.Pt[0]);\n    } else if (op1b.Pt[0] >= Left && op1b.Pt[0] <= Right) {\n      //Pt = op1b.Pt;\n      Pt[0] = op1b.Pt[0];\n      Pt[1] = op1b.Pt[1];\n      DiscardLeftSide = op1b.Pt[0] > op1.Pt[0];\n    } else {\n      //Pt = op2b.Pt;\n      Pt[0] = op2b.Pt[0];\n      Pt[1] = op2b.Pt[1];\n      DiscardLeftSide = (op2b.Pt[0] > op2.Pt[0]);\n    }\n    j.OutPt1 = op1;\n    j.OutPt2 = op2;\n    return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\n  } else {\n    //nb: For non-horizontal joins ...\n    //    1. Jr.OutPt1.Pt[1] == Jr.OutPt2.Pt[1]\n    //    2. Jr.OutPt1.Pt > Jr.OffPt[1]\n    //make sure the polygons are correctly oriented ...\n    op1b = op1.Next;\n    while ((ClipperLib.FPoint_op_Equality(op1b.Pt, op1.Pt)) && (op1b !== op1))\n      op1b = op1b.Next;\n    var Reverse1 = ((op1b.Pt[1] > op1.Pt[1]) || !ClipperLib.ClipperBase.SlopesEqual4(op1.Pt, op1b.Pt, j.OffPt));\n    if (Reverse1) {\n      op1b = op1.Prev;\n      while ((ClipperLib.FPoint_op_Equality(op1b.Pt, op1.Pt)) && (op1b !== op1))\n        op1b = op1b.Prev;\n\n      if ((op1b.Pt[1] > op1.Pt[1]) || !ClipperLib.ClipperBase.SlopesEqual4(op1.Pt, op1b.Pt, j.OffPt))\n        return false;\n    }\n    op2b = op2.Next;\n    while ((ClipperLib.FPoint_op_Equality(op2b.Pt, op2.Pt)) && (op2b !== op2))\n      op2b = op2b.Next;\n\n    var Reverse2 = ((op2b.Pt[1] > op2.Pt[1]) || !ClipperLib.ClipperBase.SlopesEqual4(op2.Pt, op2b.Pt, j.OffPt));\n    if (Reverse2) {\n      op2b = op2.Prev;\n      while ((ClipperLib.FPoint_op_Equality(op2b.Pt, op2.Pt)) && (op2b !== op2))\n        op2b = op2b.Prev;\n\n      if ((op2b.Pt[1] > op2.Pt[1]) || !ClipperLib.ClipperBase.SlopesEqual4(op2.Pt, op2b.Pt, j.OffPt))\n        return false;\n    }\n    if ((op1b === op1) || (op2b === op2) || (op1b === op2b) ||\n      ((outRec1 === outRec2) && (Reverse1 === Reverse2)))\n      return false;\n    if (Reverse1) {\n      op1b = this.DupOutPt(op1, false);\n      op2b = this.DupOutPt(op2, true);\n      op1.Prev = op2;\n      op2.Next = op1;\n      op1b.Next = op2b;\n      op2b.Prev = op1b;\n      j.OutPt1 = op1;\n      j.OutPt2 = op1b;\n      return true;\n    } else {\n      op1b = this.DupOutPt(op1, true);\n      op2b = this.DupOutPt(op2, false);\n      op1.Next = op2;\n      op2.Prev = op1;\n      op1b.Prev = op2b;\n      op2b.Next = op1b;\n      j.OutPt1 = op1;\n      j.OutPt2 = op1b;\n      return true;\n    }\n  }\n};\n\nClipperLib.Clipper.GetBounds = function (paths) {\n  var i = 0,\n    cnt = paths.length;\n  while (i < cnt && paths[i].length === 0) i++;\n  if (i === cnt) return new ClipperLib.FRect(0, 0, 0, 0);\n  var result = new ClipperLib.FRect();\n  result.left = paths[i][0][0];\n  result.right = result.left;\n  result.top = paths[i][0][1];\n  result.bottom = result.top;\n  for (; i < cnt; i++)\n    for (var j = 0, jlen = paths[i].length; j < jlen; j++) {\n      if (paths[i][j][0] < result.left) result.left = paths[i][j][0];\n      else if (paths[i][j][0] > result.right) result.right = paths[i][j][0];\n      if (paths[i][j][1] < result.top) result.top = paths[i][j][1];\n      else if (paths[i][j][1] > result.bottom) result.bottom = paths[i][j][1];\n    }\n  return result;\n}\nClipperLib.Clipper.prototype.GetBounds2 = function (ops) {\n  var opStart = ops;\n  var result = new ClipperLib.FRect();\n  result.left = ops.Pt[0];\n  result.right = ops.Pt[0];\n  result.top = ops.Pt[1];\n  result.bottom = ops.Pt[1];\n  ops = ops.Next;\n  while (ops !== opStart) {\n    if (ops.Pt[0] < result.left)\n      result.left = ops.Pt[0];\n    if (ops.Pt[0] > result.right)\n      result.right = ops.Pt[0];\n    if (ops.Pt[1] < result.top)\n      result.top = ops.Pt[1];\n    if (ops.Pt[1] > result.bottom)\n      result.bottom = ops.Pt[1];\n    ops = ops.Next;\n  }\n  return result;\n};\n\nClipperLib.Clipper.PointInPolygon = function (pt, path) {\n  //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n  //See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n  //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n  var result = 0,\n    cnt = path.length;\n  if (cnt < 3)\n    return 0;\n  var ip = path[0];\n  for (var i = 1; i <= cnt; ++i) {\n    var ipNext = (i === cnt ? path[0] : path[i]);\n    if (ipNext[1] === pt[1]) {\n      if ((ipNext[0] === pt[0]) || (ip[1] === pt[1] && ((ipNext[0] > pt[0]) === (ip[0] < pt[0]))))\n        return -1;\n    }\n    if ((ip[1] < pt[1]) !== (ipNext[1] < pt[1])) {\n      if (ip[0] >= pt[0]) {\n        if (ipNext[0] > pt[0])\n          result = 1 - result;\n        else {\n          var d = (ip[0] - pt[0]) * (ipNext[1] - pt[1]) - (ipNext[0] - pt[0]) * (ip[1] - pt[1]);\n          if (d === 0)\n            return -1;\n          else if ((d > 0) === (ipNext[1] > ip[1]))\n            result = 1 - result;\n        }\n      } else {\n        if (ipNext[0] > pt[0]) {\n          var d = (ip[0] - pt[0]) * (ipNext[1] - pt[1]) - (ipNext[0] - pt[0]) * (ip[1] - pt[1]);\n          if (d === 0)\n            return -1;\n          else if ((d > 0) === (ipNext[1] > ip[1]))\n            result = 1 - result;\n        }\n      }\n    }\n    ip = ipNext;\n  }\n  return result;\n};\n\nClipperLib.Clipper.prototype.PointInPolygon = function (pt, op) {\n  //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n  var result = 0;\n  var startOp = op;\n  var ptx = pt[0],\n    pty = pt[1];\n  var poly0x = op.Pt[0],\n    poly0y = op.Pt[1];\n  do {\n    op = op.Next;\n    var poly1x = op.Pt[0],\n      poly1y = op.Pt[1];\n    if (poly1y === pty) {\n      if ((poly1x === ptx) || (poly0y === pty && ((poly1x > ptx) === (poly0x < ptx))))\n        return -1;\n    }\n    if ((poly0y < pty) !== (poly1y < pty)) {\n      if (poly0x >= ptx) {\n        if (poly1x > ptx)\n          result = 1 - result;\n        else {\n          var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n          if (d === 0)\n            return -1;\n          if ((d > 0) === (poly1y > poly0y))\n            result = 1 - result;\n        }\n      } else {\n        if (poly1x > ptx) {\n          var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n          if (d === 0)\n            return -1;\n          if ((d > 0) === (poly1y > poly0y))\n            result = 1 - result;\n        }\n      }\n    }\n    poly0x = poly1x;\n    poly0y = poly1y;\n  } while (startOp !== op);\n\n  return result;\n};\n\nClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2) {\n  var op = outPt1;\n  do {\n    //nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon\n    var res = this.PointInPolygon(op.Pt, outPt2);\n    if (res >= 0)\n      return res > 0;\n    op = op.Next;\n  }\n  while (op !== outPt1)\n  return true;\n};\n\nClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec) {\n  var outRec, firstLeft;\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n    outRec = this.m_PolyOuts[i];\n    firstLeft = ClipperLib.Clipper.ParseFirstLeft(outRec.FirstLeft);\n    if (outRec.Pts !== null && firstLeft === OldOutRec) {\n      if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))\n        outRec.FirstLeft = NewOutRec;\n    }\n  }\n}\n\nClipperLib.Clipper.prototype.FixupFirstLefts2 = function (innerOutRec, outerOutRec) {\n  //A polygon has split into two such that one is now the inner of the other.\n  //It's possible that these polygons now wrap around other polygons, so check\n  //every polygon that's also contained by OuterOutRec's FirstLeft container\n  //(including nil) to see if they've become inner to the new inner polygon ...\n  var orfl = outerOutRec.FirstLeft;\n  var outRec, firstLeft;\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n    outRec = this.m_PolyOuts[i];\n    if (outRec.Pts === null || outRec === outerOutRec || outRec === innerOutRec)\n      continue;\n    firstLeft = ClipperLib.Clipper.ParseFirstLeft(outRec.FirstLeft);\n    if (firstLeft !== orfl && firstLeft !== innerOutRec && firstLeft !== outerOutRec)\n      continue;\n    if (this.Poly2ContainsPoly1(outRec.Pts, innerOutRec.Pts))\n      outRec.FirstLeft = innerOutRec;\n    else if (this.Poly2ContainsPoly1(outRec.Pts, outerOutRec.Pts))\n      outRec.FirstLeft = outerOutRec;\n    else if (outRec.FirstLeft === innerOutRec || outRec.FirstLeft === outerOutRec)\n      outRec.FirstLeft = orfl;\n  }\n}\n\nClipperLib.Clipper.prototype.FixupFirstLefts3 = function (OldOutRec, NewOutRec) {\n  //same as FixupFirstLefts1 but doesn't call Poly2ContainsPoly1()\n  var outRec;\n  var firstLeft;\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n    outRec = this.m_PolyOuts[i];\n    firstLeft = ClipperLib.Clipper.ParseFirstLeft(outRec.FirstLeft);\n    if (outRec.Pts !== null && firstLeft === OldOutRec)\n      outRec.FirstLeft = NewOutRec;\n  }\n}\n\nClipperLib.Clipper.ParseFirstLeft = function (FirstLeft) {\n  while (FirstLeft !== null && FirstLeft.Pts === null)\n    FirstLeft = FirstLeft.FirstLeft;\n  return FirstLeft;\n};\n\nClipperLib.Clipper.prototype.JoinCommonEdges = function () {\n  for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++) {\n    var join = this.m_Joins[i];\n    var outRec1 = this.GetOutRec(join.OutPt1.Idx);\n    var outRec2 = this.GetOutRec(join.OutPt2.Idx);\n    if (outRec1.Pts === null || outRec2.Pts === null)\n      continue;\n\n    if (outRec1.IsOpen || outRec2.IsOpen) {\n      continue;\n    }\n\n    //get the polygon fragment with the correct hole state (FirstLeft)\n    //before calling JoinPoints() ...\n    var holeStateRec;\n    if (outRec1 === outRec2)\n      holeStateRec = outRec1;\n    else if (this.OutRec1RightOfOutRec2(outRec1, outRec2))\n      holeStateRec = outRec2;\n    else if (this.OutRec1RightOfOutRec2(outRec2, outRec1))\n      holeStateRec = outRec1;\n    else\n      holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\n    if (!this.JoinPoints(join, outRec1, outRec2)) continue;\n\n    if (outRec1 === outRec2) {\n      //instead of joining two polygons, we've just created a new one by\n      //splitting one polygon into two.\n      outRec1.Pts = join.OutPt1;\n      outRec1.BottomPt = null;\n      outRec2 = this.CreateOutRec();\n      outRec2.Pts = join.OutPt2;\n      //update all OutRec2.Pts Idx's ...\n      this.UpdateOutPtIdxs(outRec2);\n\n      if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts)) {\n        //outRec1 contains outRec2 ...\n        outRec2.IsHole = !outRec1.IsHole;\n        outRec2.FirstLeft = outRec1;\n        if (this.m_UsingPolyTree)\n          this.FixupFirstLefts2(outRec2, outRec1);\n        if ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area$1(outRec2) > 0))\n          this.ReversePolyPtLinks(outRec2.Pts);\n      } else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts)) {\n        //outRec2 contains outRec1 ...\n        outRec2.IsHole = outRec1.IsHole;\n        outRec1.IsHole = !outRec2.IsHole;\n        outRec2.FirstLeft = outRec1.FirstLeft;\n        outRec1.FirstLeft = outRec2;\n        if (this.m_UsingPolyTree)\n          this.FixupFirstLefts2(outRec1, outRec2);\n\n        if ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area$1(outRec1) > 0))\n          this.ReversePolyPtLinks(outRec1.Pts);\n      } else {\n        //the 2 polygons are completely separate ...\n        outRec2.IsHole = outRec1.IsHole;\n        outRec2.FirstLeft = outRec1.FirstLeft;\n        //fixup FirstLeft pointers that may need reassigning to OutRec2\n        if (this.m_UsingPolyTree)\n          this.FixupFirstLefts1(outRec1, outRec2);\n      }\n    } else {\n      //joined 2 polygons together ...\n      outRec2.Pts = null;\n      outRec2.BottomPt = null;\n      outRec2.Idx = outRec1.Idx;\n      outRec1.IsHole = holeStateRec.IsHole;\n      if (holeStateRec === outRec2)\n        outRec1.FirstLeft = outRec2.FirstLeft;\n      outRec2.FirstLeft = outRec1;\n      //fixup FirstLeft pointers that may need reassigning to OutRec1\n      if (this.m_UsingPolyTree)\n        this.FixupFirstLefts3(outRec2, outRec1);\n    }\n  }\n};\n\nClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec) {\n  var op = outrec.Pts;\n  do {\n    op.Idx = outrec.Idx;\n    op = op.Prev;\n  }\n  while (op !== outrec.Pts)\n};\n\nClipperLib.Clipper.prototype.DoSimplePolygons = function () {\n  var i = 0;\n  while (i < this.m_PolyOuts.length) {\n    var outrec = this.m_PolyOuts[i++];\n    var op = outrec.Pts;\n    if (op === null || outrec.IsOpen)\n      continue;\n    do //for each Pt in Polygon until duplicate found do ...\n    {\n      var op2 = op.Next;\n      while (op2 !== outrec.Pts) {\n        if ((ClipperLib.FPoint_op_Equality(op.Pt, op2.Pt)) && op2.Next !== op && op2.Prev !== op) {\n          //split the polygon into two ...\n          var op3 = op.Prev;\n          var op4 = op2.Prev;\n          op.Prev = op4;\n          op4.Next = op;\n          op2.Prev = op3;\n          op3.Next = op2;\n          outrec.Pts = op;\n          var outrec2 = this.CreateOutRec();\n          outrec2.Pts = op2;\n          this.UpdateOutPtIdxs(outrec2);\n          if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts)) {\n            //OutRec2 is contained by OutRec1 ...\n            outrec2.IsHole = !outrec.IsHole;\n            outrec2.FirstLeft = outrec;\n            if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec2, outrec);\n\n          } else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts)) {\n            //OutRec1 is contained by OutRec2 ...\n            outrec2.IsHole = outrec.IsHole;\n            outrec.IsHole = !outrec2.IsHole;\n            outrec2.FirstLeft = outrec.FirstLeft;\n            outrec.FirstLeft = outrec2;\n            if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec, outrec2);\n          } else {\n            //the 2 polygons are separate ...\n            outrec2.IsHole = outrec.IsHole;\n            outrec2.FirstLeft = outrec.FirstLeft;\n            if (this.m_UsingPolyTree) this.FixupFirstLefts1(outrec, outrec2);\n          }\n          op2 = op;\n          //ie get ready for the next iteration\n        }\n        op2 = op2.Next;\n      }\n      op = op.Next;\n    }\n    while (op !== outrec.Pts)\n  }\n};\n\nClipperLib.Clipper.Area = function (poly) {\n  if (!Array.isArray(poly))\n    return 0;\n  var cnt = poly.length;\n  if (cnt < 3)\n    return 0;\n  var a = 0;\n  for (var i = 0, j = cnt - 1; i < cnt; ++i) {\n    a += (poly[j][0] + poly[i][0]) * (poly[j][1] - poly[i][1]);\n    j = i;\n  }\n  return -a * 0.5;\n};\n\nClipperLib.Clipper.prototype.Area = function (op) {\n  var opFirst = op;\n  if (op === null) return 0;\n  var a = 0;\n  do {\n    a = a + (op.Prev.Pt[0] + op.Pt[0]) * (op.Prev.Pt[1] - op.Pt[1]);\n    op = op.Next;\n  } while (op !== opFirst); // && typeof op !== 'undefined');\n  return a * 0.5;\n}\n\nClipperLib.Clipper.prototype.Area$1 = function (outRec) {\n  return this.Area(outRec.Pts);\n};\n\nClipperLib.Clipper.SimplifyPolygon = function (poly, fillType) {\n  var result = new Array();\n  var c = new ClipperLib.Clipper(0);\n  c.StrictlySimple = true;\n  c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);\n  c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n  return result;\n};\n\nClipperLib.Clipper.SimplifyPolygons = function (polys, fillType) {\n  if (typeof (fillType) === \"undefined\") fillType = ClipperLib.PolyFillType.pftEvenOdd;\n  var result = new Array();\n  var c = new ClipperLib.Clipper(0);\n  c.StrictlySimple = true;\n  c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);\n  c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n  return result;\n};\n\nClipperLib.Clipper.DistanceSqrd = function (pt1, pt2) {\n  var dx = (pt1[0] - pt2[0]);\n  var dy = (pt1[1] - pt2[1]);\n  return (dx * dx + dy * dy);\n};\n\nClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2) {\n  //The equation of a line in general form (Ax + By + C = 0)\n  //given 2 points (x¹,y¹) & (x²,y²) is ...\n  //(y¹ - y²)x + (x² - x¹)y + (y² - y¹)x¹ - (x² - x¹)y¹ = 0\n  //A = (y¹ - y²); B = (x² - x¹); C = (y² - y¹)x¹ - (x² - x¹)y¹\n  //perpendicular distance of point (x³,y³) = (Ax³ + By³ + C)/Sqrt(A² + B²)\n  //see http://en.wikipedia.org/wiki/Perpendicular_distance\n  var A = ln1[1] - ln2[1];\n  var B = ln2[0] - ln1[0];\n  var C = A * ln1[0] + B * ln1[1];\n  C = A * pt[0] + B * pt[1] - C;\n  return (C * C) / (A * A + B * B);\n};\n\nClipperLib.Clipper.SlopesNearCollinear = function (pt1, pt2, pt3, distSqrd) {\n  //this function is more accurate when the point that's GEOMETRICALLY\n  //between the other 2 points is the one that's tested for distance.\n  //nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts\n  if (Math.abs(pt1[0] - pt2[0]) > Math.abs(pt1[1] - pt2[1])) {\n    if ((pt1[0] > pt2[0]) === (pt1[0] < pt3[0]))\n      return ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n    else if ((pt2[0] > pt1[0]) === (pt2[0] < pt3[0]))\n      return ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n    else\n      return ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n  } else {\n    if ((pt1[1] > pt2[1]) === (pt1[1] < pt3[1]))\n      return ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n    else if ((pt2[1] > pt1[1]) === (pt2[1] < pt3[1]))\n      return ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n    else\n      return ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n  }\n}\n\nClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd) {\n  var dx = pt1[0] - pt2[0];\n  var dy = pt1[1] - pt2[1];\n  return ((dx * dx) + (dy * dy) <= distSqrd);\n};\n\nClipperLib.Clipper.ExcludeOp = function (op) {\n  var result = op.Prev;\n  result.Next = op.Next;\n  op.Next.Prev = result;\n  result.Idx = 0;\n  return result;\n};\n\nClipperLib.Clipper.CleanPolygon = function (path, distance) {\n  if (typeof (distance) === \"undefined\") distance = 1.415;\n  //distance = proximity in units/pixels below which vertices will be stripped.\n  //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have\n  //both x & y coords within 1 unit, then the second vertex will be stripped.\n  var cnt = path.length;\n  if (cnt === 0)\n    return new Array();\n  var outPts = new Array(cnt);\n  for (var i = 0; i < cnt; ++i)\n    outPts[i] = new ClipperLib.OutPt();\n  for (var i = 0; i < cnt; ++i) {\n    outPts[i].Pt = path[i];\n    outPts[i].Next = outPts[(i + 1) % cnt];\n    outPts[i].Next.Prev = outPts[i];\n    outPts[i].Idx = 0;\n  }\n  var distSqrd = distance * distance;\n  var op = outPts[0];\n  while (op.Idx === 0 && op.Next !== op.Prev) {\n    if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd)) {\n      op = ClipperLib.Clipper.ExcludeOp(op);\n      cnt--;\n    } else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd)) {\n      ClipperLib.Clipper.ExcludeOp(op.Next);\n      op = ClipperLib.Clipper.ExcludeOp(op);\n      cnt -= 2;\n    } else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd)) {\n      op = ClipperLib.Clipper.ExcludeOp(op);\n      cnt--;\n    } else {\n      op.Idx = 1;\n      op = op.Next;\n    }\n  }\n  if (cnt < 3)\n    cnt = 0;\n  var result = new Array(cnt);\n  for (var i = 0; i < cnt; ++i) {\n    result[i] = [...op.Pt];\n    op = op.Next;\n  }\n  outPts = null;\n  return result;\n};\n\nClipperLib.Clipper.CleanPolygons = function (polys, distance) {\n  var result = new Array(polys.length);\n  for (var i = 0, ilen = polys.length; i < ilen; i++)\n    result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);\n  return result;\n};\n\nClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed) {\n  var delta = (IsClosed ? 1 : 0);\n  var polyCnt = pattern.length;\n  var pathCnt = path.length;\n  var result = new Array();\n  if (IsSum)\n    for (var i = 0; i < pathCnt; i++) {\n      var p = new Array(polyCnt);\n      for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n        p[j] = [path[i][0] + ip[0], path[i][1] + ip[1]];\n      result.push(p);\n    }\n  else\n    for (var i = 0; i < pathCnt; i++) {\n      var p = new Array(polyCnt);\n      for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n        p[j] = [path[i][0] - ip[0], path[i][1] - ip[1]];\n      result.push(p);\n    }\n  var quads = new Array();\n  for (var i = 0; i < pathCnt - 1 + delta; i++)\n    for (var j = 0; j < polyCnt; j++) {\n      var quad = new Array();\n      quad.push(result[i % pathCnt][j % polyCnt]);\n      quad.push(result[(i + 1) % pathCnt][j % polyCnt]);\n      quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);\n      quad.push(result[i % pathCnt][(j + 1) % polyCnt]);\n      if (!ClipperLib.Clipper.Orientation(quad))\n        quad.reverse();\n      quads.push(quad);\n    }\n  return quads;\n};\n\nClipperLib.Clipper.MinkowskiSum = function (pattern, path_or_paths, pathIsClosed) {\n  if (!(path_or_paths[0] instanceof Array)) {\n    var path = path_or_paths;\n    var paths = ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);\n    var c = new ClipperLib.Clipper();\n    c.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n    c.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n    return paths;\n  } else {\n    var paths = path_or_paths;\n    var solution = new ClipperLib.Paths();\n    var c = new ClipperLib.Clipper();\n    for (var i = 0; i < paths.length; ++i) {\n      var tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);\n      c.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);\n      if (pathIsClosed) {\n        var path = ClipperLib.Clipper.TranslatePath(paths[i], pattern[0]);\n        c.AddPath(path, ClipperLib.PolyType.ptClip, true);\n      }\n    }\n    c.Execute(ClipperLib.ClipType.ctUnion, solution,\n      ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n    return solution;\n  }\n}\n\nClipperLib.Clipper.TranslatePath = function (path, delta) {\n  var outPath = new ClipperLib.Path();\n  for (var i = 0; i < path.length; i++)\n    outPath.push([path[i][0] + delta[0], path[i][1] + delta[1]]);\n  return outPath;\n}\n\nClipperLib.Clipper.MinkowskiDiff = function (poly1, poly2) {\n  var paths = ClipperLib.Clipper.Minkowski(poly1, poly2, false, true);\n  var c = new ClipperLib.Clipper();\n  c.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n  c.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n  return paths;\n}\n\nClipperLib.Clipper.PolyTreeToPaths = function (polytree) {\n  var result = new Array();\n  //result.set_Capacity(polytree.get_Total());\n  ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);\n  return result;\n};\n\nClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths) {\n  var match = true;\n  switch (nt) {\n    case ClipperLib.Clipper.NodeType.ntOpen:\n      return;\n    case ClipperLib.Clipper.NodeType.ntClosed:\n      match = !polynode.IsOpen;\n      break;\n    default:\n      break;\n  }\n  if (polynode.m_polygon.length > 0 && match)\n    paths.push(polynode.m_polygon);\n  for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])\n    ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);\n};\n\nClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree) {\n  var result = new ClipperLib.Paths();\n  //result.set_Capacity(polytree.ChildCount());\n  for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)\n    if (polytree.Childs()[i].IsOpen)\n      result.push(polytree.Childs()[i].m_polygon);\n  return result;\n};\n\nClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree) {\n  var result = new ClipperLib.Paths();\n  //result.set_Capacity(polytree.Total());\n  ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);\n  return result;\n};\n\nInherit(ClipperLib.Clipper, ClipperLib.ClipperBase);\nClipperLib.Clipper.NodeType = {\n  ntAny: 0,\n  ntOpen: 1,\n  ntClosed: 2\n};\n\n/**\n * @constructor\n */\nClipperLib.ClipperOffset = function (miterLimit, arcTolerance) {\n  if (typeof (miterLimit) === \"undefined\") miterLimit = 2;\n  if (typeof (arcTolerance) === \"undefined\") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;\n  this.m_destPolys = new ClipperLib.Paths();\n  this.m_srcPoly = new ClipperLib.Path();\n  this.m_destPoly = new ClipperLib.Path();\n  this.m_normals = new Array();\n  this.m_delta = 0;\n  this.m_sinA = 0;\n  this.m_sin = 0;\n  this.m_cos = 0;\n  this.m_miterLim = 0;\n  this.m_StepsPerRad = 0;\n  this.m_lowest = [0, 0];\n  this.m_polyNodes = new ClipperLib.PolyNode();\n  this.MiterLimit = miterLimit;\n  this.ArcTolerance = arcTolerance;\n  this.m_lowest[0] = -1;\n};\n\nClipperLib.ClipperOffset.two_pi = 6.28318530717959;\nClipperLib.ClipperOffset.def_arc_tolerance = 0.25;\nClipperLib.ClipperOffset.prototype.Clear = function () {\n  ClipperLib.Clear(this.m_polyNodes.Childs());\n  this.m_lowest[0] = -1;\n};\n\nClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType) {\n  var highI = path.length - 1;\n  if (highI < 0)\n    return;\n  var newNode = new ClipperLib.PolyNode();\n  newNode.m_jointype = joinType;\n  newNode.m_endtype = endType;\n  //strip duplicate points from path and also get index to the lowest point ...\n  if (endType === ClipperLib.EndType.etClosedLine || endType === ClipperLib.EndType.etClosedPolygon)\n    while (highI > 0 && ClipperLib.FPoint_op_Equality(path[0], path[highI]))\n      highI--;\n  //newNode.m_polygon.set_Capacity(highI + 1);\n  newNode.m_polygon.push(path[0]);\n  var j = 0,\n    k = 0;\n  for (var i = 1; i <= highI; i++)\n    if (ClipperLib.FPoint_op_Inequality(newNode.m_polygon[j], path[i])) {\n      j++;\n      newNode.m_polygon.push(path[i]);\n      if (path[i][1] > newNode.m_polygon[k][1] || (path[i][1] === newNode.m_polygon[k][1] && path[i][0] < newNode.m_polygon[k][0]))\n        k = j;\n    }\n  if (endType === ClipperLib.EndType.etClosedPolygon && j < 2) return;\n\n  this.m_polyNodes.AddChild(newNode);\n  //if this path's lowest pt is lower than all the others then update m_lowest\n  if (endType !== ClipperLib.EndType.etClosedPolygon)\n    return;\n  if (this.m_lowest[0] < 0)\n    this.m_lowest = [this.m_polyNodes.ChildCount() - 1, k];\n  else {\n    var ip = this.m_polyNodes.Childs()[this.m_lowest[0]].m_polygon[this.m_lowest[1]];\n    if (newNode.m_polygon[k][1] > ip[1] || (newNode.m_polygon[k][1] === ip[1] && newNode.m_polygon[k][0] < ip[0]))\n      this.m_lowest = [this.m_polyNodes.ChildCount() - 1, k];\n  }\n};\n\nClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType) {\n  for (var i = 0, ilen = paths.length; i < ilen; i++)\n    this.AddPath(paths[i], joinType, endType);\n};\n\nClipperLib.ClipperOffset.prototype.FixOrientations = function () {\n  //fixup orientations of all closed paths if the orientation of the\n  //closed path with the lowermost vertex is wrong ...\n  if (this.m_lowest[0] >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest[0]].m_polygon)) {\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++) {\n      var node = this.m_polyNodes.Childs()[i];\n      if (node.m_endtype === ClipperLib.EndType.etClosedPolygon || (node.m_endtype === ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))\n        node.m_polygon.reverse();\n    }\n  } else {\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++) {\n      var node = this.m_polyNodes.Childs()[i];\n      if (node.m_endtype === ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))\n        node.m_polygon.reverse();\n    }\n  }\n};\n\nClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2) {\n  var dx = (pt2[0] - pt1[0]);\n  var dy = (pt2[1] - pt1[1]);\n  if ((dx === 0) && (dy === 0))\n    return [0, 0];\n  var f = 1 / Math.sqrt(dx * dx + dy * dy);\n  dx *= f;\n  dy *= f;\n  return [dy, -dx];\n};\n\nClipperLib.ClipperOffset.prototype.DoOffset = function (delta) {\n  this.m_destPolys = new Array();\n  this.m_delta = delta;\n  //if Zero offset, just copy any CLOSED polygons to m_p and return ...\n  if (ClipperLib.ClipperBase.near_zero(delta)) {\n    //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++) {\n      var node = this.m_polyNodes.Childs()[i];\n      if (node.m_endtype === ClipperLib.EndType.etClosedPolygon)\n        this.m_destPolys.push(node.m_polygon);\n    }\n    return;\n  }\n  //see offset_triginometry3.svg in the documentation folder ...\n  if (this.MiterLimit > 2)\n    this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);\n  else\n    this.m_miterLim = 0.5;\n  var y;\n  if (this.ArcTolerance <= 0)\n    y = ClipperLib.ClipperOffset.def_arc_tolerance;\n  else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)\n    y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;\n  else\n    y = this.ArcTolerance;\n  //see offset_triginometry2.svg in the documentation folder ...\n  var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));\n  this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);\n  this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);\n  this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;\n  if (delta < 0)\n    this.m_sin = -this.m_sin;\n  //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);\n  for (var i = 0; i < this.m_polyNodes.ChildCount(); i++) {\n    var node = this.m_polyNodes.Childs()[i];\n    this.m_srcPoly = node.m_polygon;\n    var len = this.m_srcPoly.length;\n    if (len === 0 || (delta <= 0 && (len < 3 || node.m_endtype !== ClipperLib.EndType.etClosedPolygon)))\n      continue;\n    this.m_destPoly = new Array();\n    if (len === 1) {\n      if (node.m_jointype === ClipperLib.JoinType.jtRound) {\n        var X = 1,\n          Y = 0;\n        for (var j = 1; j <= steps; j++) {\n          this.m_destPoly.push([this.m_srcPoly[0][0] + X * delta, this.m_srcPoly[0][1] + Y * delta]);\n          var X2 = X;\n          X = X * this.m_cos - this.m_sin * Y;\n          Y = X2 * this.m_sin + Y * this.m_cos;\n        }\n      } else {\n        var X = -1,\n          Y = -1;\n        for (var j = 0; j < 4; ++j) {\n          this.m_destPoly.push([this.m_srcPoly[0][0] + X * delta, this.m_srcPoly[0][1] + Y * delta]);\n          if (X < 0)\n            X = 1;\n          else if (Y < 0)\n            Y = 1;\n          else\n            X = -1;\n        }\n      }\n      this.m_destPolys.push(this.m_destPoly);\n      continue;\n    }\n    //build m_normals ...\n    this.m_normals.length = 0;\n    //this.m_normals.set_Capacity(len);\n    for (var j = 0; j < len - 1; j++)\n      this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));\n    if (node.m_endtype === ClipperLib.EndType.etClosedLine || node.m_endtype === ClipperLib.EndType.etClosedPolygon)\n      this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));\n    else\n      this.m_normals.push([...this.m_normals[len - 2]]);\n    if (node.m_endtype === ClipperLib.EndType.etClosedPolygon) {\n      var k = len - 1;\n      for (var j = 0; j < len; j++)\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      this.m_destPolys.push(this.m_destPoly);\n    } else if (node.m_endtype === ClipperLib.EndType.etClosedLine) {\n      var k = len - 1;\n      for (var j = 0; j < len; j++)\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      this.m_destPolys.push(this.m_destPoly);\n      this.m_destPoly = new Array();\n      //re-build m_normals ...\n      var n = this.m_normals[len - 1];\n      for (var j = len - 1; j > 0; j--)\n        this.m_normals[j] = [-this.m_normals[j - 1][0], -this.m_normals[j - 1][1]];\n      this.m_normals[0] = [-n[0], -n[1]];\n      k = 0;\n      for (var j = len - 1; j >= 0; j--)\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      this.m_destPolys.push(this.m_destPoly);\n    } else {\n      var k = 0;\n      for (var j = 1; j < len - 1; ++j)\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      var pt1;\n      if (node.m_endtype === ClipperLib.EndType.etOpenButt) {\n        var j = len - 1;\n        pt1 = [this.m_srcPoly[j][0] + this.m_normals[j][0] * delta, this.m_srcPoly[j][1] + this.m_normals[j][1] * delta];\n        this.m_destPoly.push(pt1);\n        pt1 = [this.m_srcPoly[j][0] - this.m_normals[j][0] * delta, this.m_srcPoly[j][1] - this.m_normals[j][1] * delta];\n        this.m_destPoly.push(pt1);\n      } else {\n        var j = len - 1;\n        k = len - 2;\n        this.m_sinA = 0;\n        this.m_normals[j] = [-this.m_normals[j][0], -this.m_normals[j][1]];\n        if (node.m_endtype === ClipperLib.EndType.etOpenSquare)\n          this.DoSquare(j, k);\n        else\n          this.DoRound(j, k);\n      }\n      //re-build m_normals ...\n      for (var j = len - 1; j > 0; j--)\n        this.m_normals[j] = [-this.m_normals[j - 1][0], -this.m_normals[j - 1][1]];\n      this.m_normals[0] = [-this.m_normals[1][0], -this.m_normals[1][1]];\n      k = len - 1;\n      for (var j = k - 1; j > 0; --j)\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      if (node.m_endtype === ClipperLib.EndType.etOpenButt) {\n        pt1 = [this.m_srcPoly[0][0] - this.m_normals[0][0] * delta, this.m_srcPoly[0][1] - this.m_normals[0][1] * delta];\n        this.m_destPoly.push(pt1);\n        pt1 = [this.m_srcPoly[0][0] + this.m_normals[0][0] * delta, this.m_srcPoly[0][1] + this.m_normals[0][1] * delta];\n        this.m_destPoly.push(pt1);\n      } else {\n        k = 1;\n        this.m_sinA = 0;\n        if (node.m_endtype === ClipperLib.EndType.etOpenSquare)\n          this.DoSquare(0, 1);\n        else\n          this.DoRound(0, 1);\n      }\n      this.m_destPolys.push(this.m_destPoly);\n    }\n  }\n};\n\nClipperLib.ClipperOffset.prototype.Execute = function () {\n  var a = arguments,\n    ispolytree = a[0] instanceof ClipperLib.PolyTree;\n  if (!ispolytree) // function (solution, delta)\n  {\n    var solution = a[0],\n      delta = a[1];\n    ClipperLib.Clear(solution);\n    this.FixOrientations();\n    this.DoOffset(delta);\n    //now clean up 'corners' ...\n    var clpr = new ClipperLib.Clipper(0);\n    clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n    if (delta > 0) {\n      clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n    } else {\n      var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n      var outer = new ClipperLib.Path();\n      outer.push([r.left - 10, r.bottom + 10]);\n      outer.push([r.right + 10, r.bottom + 10]);\n      outer.push([r.right + 10, r.top - 10]);\n      outer.push([r.left - 10, r.top - 10]);\n      clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n      clpr.ReverseSolution = true;\n      clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n      if (solution.length > 0)\n        solution.splice(0, 1);\n    }\n    //console.log(JSON.stringify(solution));\n  } else // function (polytree, delta)\n  {\n    var solution = a[0],\n      delta = a[1];\n    solution.Clear();\n    this.FixOrientations();\n    this.DoOffset(delta);\n    //now clean up 'corners' ...\n    var clpr = new ClipperLib.Clipper(0);\n    clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n    if (delta > 0) {\n      clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n    } else {\n      var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n      var outer = new ClipperLib.Path();\n      outer.push([r.left - 10, r.bottom + 10]);\n      outer.push([r.right + 10, r.bottom + 10]);\n      outer.push([r.right + 10, r.top - 10]);\n      outer.push([r.left - 10, r.top - 10]);\n      clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n      clpr.ReverseSolution = true;\n      clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n      //remove the outer PolyNode rectangle ...\n      if (solution.ChildCount() === 1 && solution.Childs()[0].ChildCount() > 0) {\n        var outerNode = solution.Childs()[0];\n        //solution.Childs.set_Capacity(outerNode.ChildCount);\n        solution.Childs()[0] = outerNode.Childs()[0];\n        solution.Childs()[0].m_Parent = solution;\n        for (var i = 1; i < outerNode.ChildCount(); i++)\n          solution.AddChild(outerNode.Childs()[i]);\n      } else\n        solution.Clear();\n    }\n  }\n};\n\nClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype) {\n  //cross product ...\n  this.m_sinA = (this.m_normals[k][0] * this.m_normals[j][1] - this.m_normals[j][0] * this.m_normals[k][1]);\n\n  if (this.m_sinA === 0) {\n    return k;\n  } else if (this.m_sinA < 0.00005 && this.m_sinA > -0.00005)\n\n    console.log(this.m_sinA);\n  return k;\n\n\n  if (Math.abs(this.m_sinA * this.m_delta) < 1.0) {\n    //dot product ...\n    var cosA = (this.m_normals[k][0] * this.m_normals[j][0] + this.m_normals[j][1] * this.m_normals[k][1]);\n    if (cosA > 0) // angle ==> 0 degrees\n    {\n      this.m_destPoly.push([this.m_srcPoly[j][0] + this.m_normals[k][0] * this.m_delta,\n        this.m_srcPoly[j][1] + this.m_normals[k][1] * this.m_delta]);\n      return k;\n    }\n    //else angle ==> 180 degrees\n  } else if (this.m_sinA > 1)\n    this.m_sinA = 1.0;\n  else if (this.m_sinA < -1)\n    this.m_sinA = -1.0;\n  if (this.m_sinA * this.m_delta < 0) {\n    this.m_destPoly.push([this.m_srcPoly[j][0] + this.m_normals[k][0] * this.m_delta,\n      this.m_srcPoly[j][1] + this.m_normals[k][1] * this.m_delta]);\n    this.m_destPoly.push([...this.m_srcPoly[j]]);\n    this.m_destPoly.push([this.m_srcPoly[j][0] + this.m_normals[j][0] * this.m_delta,\n      this.m_srcPoly[j][1] + this.m_normals[j][1] * this.m_delta]);\n  } else\n    switch (jointype) {\n      case ClipperLib.JoinType.jtMiter:\n        {\n          var r = 1 + (this.m_normals[j][0] * this.m_normals[k][0] + this.m_normals[j][1] * this.m_normals[k][1]);\n          if (r >= this.m_miterLim)\n            this.DoMiter(j, k, r);\n          else\n            this.DoSquare(j, k);\n          break;\n        }\n      case ClipperLib.JoinType.jtSquare:\n        this.DoSquare(j, k);\n        break;\n      case ClipperLib.JoinType.jtRound:\n        this.DoRound(j, k);\n        break;\n    }\n  k = j;\n  return k;\n};\n\nClipperLib.ClipperOffset.prototype.DoSquare = function (j, k) {\n  var dx = Math.tan(Math.atan2(this.m_sinA,\n    this.m_normals[k][0] * this.m_normals[j][0] + this.m_normals[k][1] * this.m_normals[j][1]) / 4);\n  this.m_destPoly.push([this.m_srcPoly[j][0] + this.m_delta * (this.m_normals[k][0] - this.m_normals[k][1] * dx),\n    this.m_srcPoly[j][1] + this.m_delta * (this.m_normals[k][1] + this.m_normals[k][0] * dx)]);\n  this.m_destPoly.push([ this.m_srcPoly[j][0] + this.m_delta * (this.m_normals[j][0] + this.m_normals[j][1] * dx),\n    this.m_srcPoly[j][1] + this.m_delta * (this.m_normals[j][1] - this.m_normals[j][0] * dx) ]);\n};\n\nClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r) {\n  var q = this.m_delta / r;\n  this.m_destPoly.push([ this.m_srcPoly[j][0] + (this.m_normals[k][0] + this.m_normals[j][0]) * q,\n    this.m_srcPoly[j][1] + (this.m_normals[k][1] + this.m_normals[j][1]) * q ]);\n};\n\nClipperLib.ClipperOffset.prototype.DoRound = function (j, k) {\n  var a = Math.atan2(this.m_sinA,\n    this.m_normals[k][0] * this.m_normals[j][0] + this.m_normals[k][1] * this.m_normals[j][1]);\n\n  var steps = Math.max(Math.round(this.m_StepsPerRad * Math.abs(a)), 1);\n\n  var X = this.m_normals[k][0],\n    Y = this.m_normals[k][1],\n    X2;\n  for (var i = 0; i < steps; ++i) {\n    this.m_destPoly.push([ this.m_srcPoly[j][0] + X * this.m_delta,\n      this.m_srcPoly[j][1] + Y * this.m_delta ]);\n    X2 = X;\n    X = X * this.m_cos - this.m_sin * Y;\n    Y = X2 * this.m_sin + Y * this.m_cos;\n  }\n  this.m_destPoly.push([ this.m_srcPoly[j][0] + this.m_normals[j][0] * this.m_delta,\n    this.m_srcPoly[j][1] + this.m_normals[j][1] * this.m_delta ]);\n};\n\nClipperLib.Error = function (message) {\n  try {\n    throw new Error(message);\n  } catch (err) {\n    alert(err.message);\n  }\n};\n\n// ---------------------------------------------\n\n// JS extension by Timo 2013\nClipperLib.JS = {};\n\nClipperLib.JS.AreaOfPolygon = function (poly) {\n  return ClipperLib.Clipper.Area(poly);\n};\n\nClipperLib.JS.AreaOfPolygons = function (poly) {\n  var area = 0;\n  for (var i = 0; i < poly.length; i++) {\n    area += ClipperLib.Clipper.Area(poly[i]);\n  }\n  return area;\n};\n\nClipperLib.JS.BoundsOfPath = function (path) {\n  return ClipperLib.JS.BoundsOfPaths([path]);\n};\n\nClipperLib.JS.BoundsOfPaths = function (paths) {\n  var bounds = ClipperLib.Clipper.GetBounds(paths);\n  return bounds;\n};\n\n// Clean() joins vertices that are too near each other\n// and causes distortion to offsetted polygons without cleaning\nClipperLib.JS.Clean = function (polygon, delta) {\n  if (!(polygon instanceof Array)) return [];\n  var isPolygons = polygon[0] instanceof Array;\n  var polygon = ClipperLib.JS.Clone(polygon);\n  if (typeof delta !== \"number\" || delta === null) {\n    ClipperLib.Error(\"Delta is not a number in Clean().\");\n    return polygon;\n  }\n  if (polygon.length === 0 || (polygon.length === 1 && polygon[0].length === 0) || delta < 0) return polygon;\n  if (!isPolygons) polygon = [polygon];\n  var k_length = polygon.length;\n  var len, poly, result, d, p, j, i;\n  var results = [];\n  for (var k = 0; k < k_length; k++) {\n    poly = polygon[k];\n    len = poly.length;\n    if (len === 0) continue;\n    else if (len < 3) {\n      result = poly;\n      results.push(result);\n      continue;\n    }\n    result = poly;\n    d = delta * delta;\n    //d = Math.floor(c_delta * c_delta);\n    p = poly[0];\n    j = 1;\n    for (i = 1; i < len; i++) {\n      if ((poly[i][0] - p[0]) * (poly[i][0] - p[0]) +\n        (poly[i][1] - p[1]) * (poly[i][1] - p[1]) <= d)\n        continue;\n      result[j] = poly[i];\n      p = poly[i];\n      j++;\n    }\n    p = poly[j - 1];\n    if ((poly[0][0] - p[0]) * (poly[0][0] - p[0]) +\n      (poly[0][1] - p[1]) * (poly[0][1] - p[1]) <= d)\n      j--;\n    if (j < len)\n      result.splice(j, len - j);\n    if (result.length) results.push(result);\n  }\n  if (!isPolygons && results.length) results = results[0];\n  else if (!isPolygons && results.length === 0) results = [];\n  else if (isPolygons && results.length === 0) results = [\n    []\n  ];\n  return results;\n}\n// Make deep copy of Polygons or Polygon\n// so that also FPoint objects are cloned and not only referenced\n// This should be the fastest way\nClipperLib.JS.Clone = function (polygon) {\n  if (!(polygon instanceof Array)) return [];\n  if (polygon.length === 0) return [];\n  else if (polygon.length === 1 && polygon[0].length === 0) return [\n    []\n  ];\n  var isPolygons = polygon[0] instanceof Array;\n  if (!isPolygons) polygon = [polygon];\n  var len = polygon.length,\n    plen, i, j, result;\n  var results = new Array(len);\n  for (i = 0; i < len; i++) {\n    plen = polygon[i].length;\n    result = new Array(plen);\n    for (j = 0; j < plen; j++) {\n      result[j] = [polygon[i][j][0], polygon[i][j][1]];\n    }\n    results[i] = result;\n  }\n  if (!isPolygons) results = results[0];\n  return results;\n};\n\n// Removes points that doesn't affect much to the visual appearance.\n// If middle point is at or under certain distance (tolerance) of the line segment between\n// start and end point, the middle point is removed.\nClipperLib.JS.Lighten = function (polygon, tolerance) {\n  if (!(polygon instanceof Array)) return [];\n  if (typeof tolerance !== \"number\" || tolerance === null) {\n    ClipperLib.Error(\"Tolerance is not a number in Lighten().\")\n    return ClipperLib.JS.Clone(polygon);\n  }\n  if (polygon.length === 0 || (polygon.length === 1 && polygon[0].length === 0) || tolerance < 0) {\n    return ClipperLib.JS.Clone(polygon);\n  }\n  var isPolygons = polygon[0] instanceof Array;\n  if (!isPolygons) polygon = [polygon];\n  var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;\n  var bxax, byay, l, ax, ay;\n  var len = polygon.length;\n  var toleranceSq = tolerance * tolerance;\n  var results = [];\n  for (i = 0; i < len; i++) {\n    poly = polygon[i];\n    plen = poly.length;\n    if (plen === 0) continue;\n    for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count\n    {\n      poly2 = [];\n      plen = poly.length;\n      // the first have to added to the end, if first and last are not the same\n      // this way we ensure that also the actual last point can be removed if needed\n      if (poly[plen - 1][0] !== poly[0][0] || poly[plen - 1][1] !== poly[0][1]) {\n        addlast = 1;\n        poly.push([poly[0][0], poly[0][1]]);\n        plen = poly.length;\n      } else addlast = 0;\n      rem = []; // Indexes of removed points\n      for (j = 0; j < plen - 2; j++) {\n        A = poly[j]; // Start point of line segment\n        P = poly[j + 1]; // Middle point. This is the one to be removed.\n        B = poly[j + 2]; // End point of line segment\n        ax = A[0];\n        ay = A[1];\n        bxax = B[0] - ax;\n        byay = B[1] - ay;\n        if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.\n        {\n          l = ((P[0] - ax) * bxax + (P[1] - ay) * byay) / (bxax * bxax + byay * byay);\n          if (l > 1) {\n            ax = B[0];\n            ay = B[1];\n          } else if (l > 0) {\n            ax += bxax * l;\n            ay += byay * l;\n          }\n        }\n        bxax = P[0] - ax;\n        byay = P[1] - ay;\n        d = bxax * bxax + byay * byay;\n        if (d <= toleranceSq) {\n          rem[j + 1] = 1;\n          j++; // when removed, transfer the pointer to the next one\n        }\n      }\n      // add all unremoved points to poly2\n      poly2.push([poly[0][0], poly[0][1]]);\n      for (j = 1; j < plen - 1; j++)\n        if (!rem[j]) poly2.push([poly[j][0], poly[j][1]]);\n      poly2.push([poly[plen - 1][0], poly[plen - 1][1]]);\n      // if the first point was added to the end, remove it\n      if (addlast) poly.pop();\n      // break, if there was not anymore removed points\n      if (!rem.length) break;\n      // else continue looping using poly2, to check if there are points to remove\n      else poly = poly2;\n    }\n    plen = poly2.length;\n    // remove duplicate from end, if needed\n    if (poly2[plen - 1][0] === poly2[0][0] && poly2[plen - 1][1] === poly2[0][1]) {\n      poly2.pop();\n    }\n    if (poly2.length > 2) // to avoid two-point-polygons\n      results.push(poly2);\n  }\n  if (!isPolygons) {\n    results = results[0];\n  }\n  if (typeof (results) === \"undefined\") {\n    results = [];\n  }\n  return results;\n}\n\nClipperLib.JS.PerimeterOfPath = function (path, closed) {\n  if (typeof (path) === \"undefined\") return 0;\n  var sqrt = Math.sqrt;\n  var perimeter = 0.0;\n  var p1, p2, p1x = 0.0,\n    p1y = 0.0,\n    p2x = 0.0,\n    p2y = 0.0;\n  var j = path.length;\n  if (j < 2) return 0;\n  if (closed) {\n    path[j] = path[0];\n    j++;\n  }\n  while (--j) {\n    p1 = path[j];\n    p1x = p1[0];\n    p1y = p1[1];\n    p2 = path[j - 1];\n    p2x = p2[0];\n    p2y = p2[1];\n    perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));\n  }\n  if (closed) path.pop();\n  return perimeter;\n};\n\nClipperLib.JS.PerimeterOfPaths = function (paths, closed) {\n  var perimeter = 0;\n  for (var i = 0; i < paths.length; i++) {\n    perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed);\n  }\n  return perimeter;\n};\n\n/**\n * @constructor\n */\nClipperLib.ExPolygons = function () {\n  return [];\n}\n/**\n * @constructor\n */\nClipperLib.ExPolygon = function () {\n  this.outer = null;\n  this.holes = null;\n};\n\nClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons) {\n  var ep = new ClipperLib.ExPolygon();\n  ep.outer = polynode.Contour();\n  var childs = polynode.Childs();\n  var ilen = childs.length;\n  ep.holes = new Array(ilen);\n  var node, n, i, j, childs2, jlen;\n  for (i = 0; i < ilen; i++) {\n    node = childs[i];\n    ep.holes[i] = node.Contour();\n    //Add outer polygons contained by (nested within) holes ...\n    for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++) {\n      n = childs2[j];\n      ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);\n    }\n  }\n  expolygons.push(ep);\n};\n\nClipperLib.JS.ExPolygonsToPaths = function (expolygons) {\n  var a, i, alen, ilen;\n  var paths = new ClipperLib.Paths();\n  for (a = 0, alen = expolygons.length; a < alen; a++) {\n    paths.push(expolygons[a].outer);\n    for (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++) {\n      paths.push(expolygons[a].holes[i]);\n    }\n  }\n  return paths;\n}\nClipperLib.JS.PolyTreeToExPolygons = function (polytree) {\n  var expolygons = new ClipperLib.ExPolygons();\n  var node, i, childs, ilen;\n  for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++) {\n    node = childs[i];\n    ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);\n  }\n  return expolygons;\n};\n\nmodule.exports = ClipperLib;\n"],"names":["ClipperLib","version","use_lines","Inherit","ce","ce2","p","Object","getOwnPropertyNames","prototype","$baseCtor","props","i","length","getOwnPropertyDescriptor","defineProperty","Path","push","Array","Paths","PolyNode","this","m_Parent","m_polygon","m_Index","m_jointype","m_endtype","m_Childs","IsOpen","IsHoleNode","result","node","ChildCount","Contour","AddChild","Child","cnt","GetNext","GetNextSiblingUp","Childs","Parent","IsHole","PolyTree","m_AllPolys","call","Clear","ilen","GetFirst","Total","a","PI","PI2","FPoint_op_Equality","b","FPoint_op_Inequality","FRect","arguments","alen","left","top","right","bottom","ir","FRect0","FRect1","FRect4","l","t","r","ClipType","ctIntersection","ctUnion","ctDifference","ctXor","PolyType","ptSubject","ptClip","PolyFillType","pftEvenOdd","pftNonZero","pftPositive","pftNegative","JoinType","jtSquare","jtRound","jtMiter","EndType","etOpenSquare","etOpenRound","etOpenButt","etClosedLine","etClosedPolygon","EdgeSide","esLeft","esRight","Direction","dRightToLeft","dLeftToRight","TEdge","Bot","Curr","Top","Delta","Dx","PolyTyp","Side","WindDelta","WindCnt","WindCnt2","OutIdx","Next","Prev","NextInLML","NextInAEL","PrevInAEL","NextInSEL","PrevInSEL","IntersectNode","Edge1","Edge2","Pt","MyIntersectNodeSort","Compare","node1","node2","LocalMinima","LeftBound","RightBound","Scanbeam","Maxima","OutRec","Idx","FirstLeft","Pts","BottomPt","OutPt","Join","OutPt1","OutPt2","OffPt","ClipperBase","m_MinimaList","m_CurrentLM","m_edges","m_HasOpenPaths","PreserveCollinear","m_Scanbeam","m_PolyOuts","m_ActiveEdges","horizontal","Skip","Unassigned","tolerance","maxValue","Math","sqrt","Number","MAX_VALUE","minValue","MIN_VALUE","near_zero","val","IsHorizontal","e","PointIsVertex","pt","pp","pp2","PointOnLineSegment","linePt1","linePt2","PointOnPolygon","SlopesEqual","e1","e2","pt1","pt2","pt3","pt4","SlopesEqual3","SlopesEqual4","SlopesEqual5","DisposeLocalMinimaList","j","jlen","tmpLm","RangeTest","Error","InitEdge","eNext","ePrev","InitEdge2","polyType","SetDx","FindNextLocMin","E","E2","ProcessBound","LeftBoundIsForward","EStart","Horz","Result","locMin","InsertLocalMinima","ReverseHorizontal","AddPath","pg","Closed","highI","edges","IsFlat","leftBoundIsForward","eStart","eLoopStop","Pt2IsBetweenPt1AndPt3","RemoveEdge","EMin","AddPaths","ppg","closed","newLm","PopLocalMinima","Y","current","v","tmp","Reset","lm","InsertScanbeam","newSb","sb2","newSb1","PopScanbeam","LocalMinimaPending","CreateOutRec","DisposeOutRec","index","outRec","UpdateEdgeIntoAEL","AelPrev","AelNext","SwapPositionsInAEL","edge1","edge2","next","prev","next1","prev1","next2","prev2","DeleteFromAEL","Clipper","InitOptions","m_ClipType","m_Maxima","m_SortedEdges","m_IntersectList","m_IntersectNodeComparer","m_ExecuteLocked","m_ClipFillType","m_SubjFillType","m_Joins","m_GhostJoins","m_UsingPolyTree","ReverseSolution","StrictlySimple","ioReverseSolution","ioStrictlySimple","ioPreserveCollinear","DisposeAllPolyPts","InsertMaxima","X","newMax","m","Execute","ispolytree","clipType","solution","subjFillType","clipFillType","succeeded","ExecuteInternal","BuildResult","polytree","BuildResult2","FixHoleLinkage","orfl","botY","topY","InsertLocalMinimaIntoAEL","ProcessHorizontals","ProcessIntersections","ProcessEdgesAtTopOfScanbeam","Area$1","ReversePolyPtLinks","JoinCommonEdges","FixupOutPolyline","FixupOutPolygon","DoSimplePolygons","AddJoin","Op1","Op2","AddGhostJoin","Op","SetZ","ZFillFunction","Z","lb","rb","InsertEdgeIntoAEL","SetWindingCount","IsContributing","AddOutPt","AddLocalMinPoly","AddEdgeToSEL","HorzSegmentsOverlap","IntersectEdges","edge","startEdge","E2InsertsBeforeE1","TopX","IsEvenOddFillType","IsEvenOddAltFillType","pft","pft2","abs","Inside","PopEdgeFromSEL","oldE","CopyAELToSEL","SwapPositionsInSEL","AddLocalMaxPoly","AppendPolygon","prevE","xPrev","xE","outPt","newOp","SetHoleState","op","ToFront","GetLastOutPt","SwapPoints","Value","seg1a","seg1b","seg2a","seg2b","eTmp","GetDx","FirstIsBottomPt","btmPt1","btmPt2","dx1p","dx1n","dx2p","dx2n","max","min","Area","GetBottomPt","dups","GetLowermostRec","outRec1","outRec2","bPt1","bPt2","OutRec1RightOfOutRec2","GetOutRec","idx","outrec","holeStateRec","p1_lft","p1_rt","p2_lft","p2_rt","OKIdx","ObsoleteIdx","pp1","SwapSides","side","SwapPolyIndexes","outIdx","e1Contributing","e2Contributing","oldE1WindCnt","e1FillType","e2FillType","e1FillType2","e2FillType2","e1Wc","e2Wc","e1Wc2","e2Wc2","DeleteFromSEL","SelPrev","SelNext","horzEdge","ProcessHorizontal","GetHorzDirection","HorzEdge","$var","Left","Right","Dir","dir","horzLeft","horzRight","eLastHorz","eMaxPair","GetMaximaPair","currMax","op1","IsLastHorz","GetNextInAEL","eNextHorz","op2","IsMinima","IsMaxima","IsIntermediate","GetMaximaPairEx","BuildIntersectList","FixupIntersectionOrder","ProcessIntersectList","$$e2","isModified","IntersectPoint","newNode","EdgesAdjacent","inode","IntersectNodeSort","sort","iNode","currentY","ip","b1","b2","q","IsMaximaEdge","DoMaxima","ePrev2","ReversePaths","polys","len","reverse","Orientation","poly","PointCount","pts","polyg","pn","lastPP","tmpPP","lastOK","preserveCol","DupOutPt","InsertAfter","GetOverlap","a1","a2","$val","JoinHorz","op1b","op2b","DiscardLeft","Dir1","Dir2","JoinPoints","isHorizontal","reverse1","DiscardLeftSide","Reverse1","Reverse2","GetBounds","paths","GetBounds2","ops","opStart","PointInPolygon","path","ipNext","d","startOp","ptx","pty","poly0x","poly0y","poly1x","poly1y","Poly2ContainsPoly1","outPt1","outPt2","res","FixupFirstLefts1","OldOutRec","NewOutRec","firstLeft","ParseFirstLeft","FixupFirstLefts2","innerOutRec","outerOutRec","FixupFirstLefts3","join","UpdateOutPtIdxs","op3","op4","outrec2","isArray","opFirst","SimplifyPolygon","fillType","c","SimplifyPolygons","DistanceSqrd","dx","dy","DistanceFromLineSqrd","ln1","ln2","A","B","C","SlopesNearCollinear","distSqrd","PointsAreClose","ExcludeOp","CleanPolygon","distance","outPts","CleanPolygons","Minkowski","pattern","IsSum","IsClosed","delta","polyCnt","pathCnt","quads","quad","MinkowskiSum","path_or_paths","pathIsClosed","TranslatePath","outPath","MinkowskiDiff","poly1","poly2","PolyTreeToPaths","AddPolyNodeToPaths","NodeType","ntAny","polynode","nt","match","ntOpen","ntClosed","$i3","$t3","$l3","OpenPathsFromPolyTree","ClosedPathsFromPolyTree","ClipperOffset","miterLimit","arcTolerance","def_arc_tolerance","m_destPolys","m_srcPoly","m_destPoly","m_normals","m_delta","m_sinA","m_sin","m_cos","m_miterLim","m_StepsPerRad","m_lowest","m_polyNodes","MiterLimit","ArcTolerance","two_pi","joinType","endType","k","FixOrientations","GetUnitNormal","f","DoOffset","y","steps","acos","sin","cos","OffsetPoint","n","DoSquare","DoRound","X2","clpr","outer","outerNode","splice","jointype","console","log","tan","atan2","DoMiter","round","message","err","alert","JS","AreaOfPolygon","AreaOfPolygons","area","BoundsOfPath","BoundsOfPaths","Clean","polygon","isPolygons","Clone","k_length","results","plen","Lighten","P","rem","addlast","bxax","byay","ax","ay","toleranceSq","pop","PerimeterOfPath","p1","p2","perimeter","p1x","p1y","p2x","p2y","PerimeterOfPaths","ExPolygons","ExPolygon","holes","AddOuterPolyNodeToExPolygons","expolygons","ep","childs2","childs","ExPolygonsToPaths","PolyTreeToExPolygons","module","exports"],"mappings":"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"}