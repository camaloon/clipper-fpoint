{"version":3,"file":"clipper-fpoint.umd.js","sources":["../src/clipper_unminified.js"],"sourcesContent":["/*******************************************************************************\n *                                                                              *\n * Author    :  Angus Johnson                                                   *\n * Version   :  6.4.2                                                           *\n * Date      :  27 February 2017                                                *\n * Website   :  http://www.angusj.com                                           *\n * Copyright :  Angus Johnson 2010-2017                                         *\n *                                                                              *\n * License:                                                                     *\n * Use, modification & distribution is subject to Boost Software License Ver 1. *\n * http://www.boost.org/LICENSE_1_0.txt                                         *\n *                                                                              *\n * Attributions:                                                                *\n * The code in this library is an extension of Bala Vatti's clipping algorithm: *\n * \"A generic solution to polygon clipping\"                                     *\n * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n * http://portal.acm.org/citation.cfm?id=129906                                 *\n *                                                                              *\n * Computer graphics and geometric modeling: implementation and algorithms      *\n * By Max K. Agoston                                                            *\n * Springer; 1 edition (January 4, 2005)                                        *\n * http://books.google.com/books?q=vatti+clipping+agoston                       *\n *                                                                              *\n * See also:                                                                    *\n * \"Polygon Offsetting by Computing Winding Numbers\"                            *\n * Paper no. DETC2005-85513 pp. 565-575                                         *\n * ASME 2005 International Design Engineering Technical Conferences             *\n * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n * September 24-28, 2005 , Long Beach, California, USA                          *\n * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Author    :  Timo                                                            *\n * Version   :  6.4.2.2 (FPoint)                                                *\n * Date      :  8 September 2017                                                *\n *                                                                              *\n * This is a translation of the C# Clipper library to Javascript.               *\n *                                                                              *\n *******************************************************************************/\nvar ClipperLib = {};\nClipperLib.version = '6.4.2.2';\n\n// Here starts the actual Clipper library:\n// Helper function to support Inheritance in Javascript\nvar Inherit = function(ce, ce2) {\n  var p;\n  if (typeof(Object.getOwnPropertyNames) === 'undefined') {\n    for (p in ce2.prototype)\n      if (typeof(ce.prototype[p]) === 'undefined' || ce.prototype[p] === Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];\n    for (p in ce2)\n      if (typeof(ce[p]) === 'undefined') ce[p] = ce2[p];\n    ce.$baseCtor = ce2;\n  } else {\n    var props = Object.getOwnPropertyNames(ce2.prototype);\n    for (var i = 0; i < props.length; i++)\n      if (typeof(Object.getOwnPropertyDescriptor(ce.prototype, props[i])) === 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));\n    for (p in ce2)\n      if (typeof(ce[p]) === 'undefined') ce[p] = ce2[p];\n    ce.$baseCtor = ce2;\n  }\n};\n\n/**\n * @constructor\n */\nClipperLib.Path = function() {\n  return [];\n};\n\nClipperLib.Path.prototype.push = Array.prototype.push;\n\n/**\n * @constructor\n */\nClipperLib.Paths = function() {\n  return []; // Was previously [[]], but caused problems when pushed\n};\n\nClipperLib.Paths.prototype.push = Array.prototype.push;\n\n// PolyTree & PolyNode start\n/**\n * @suppress {missingProperties}\n */\nClipperLib.PolyNode = function() {\n  this.m_Parent = null;\n  this.m_polygon = new ClipperLib.Path();\n  this.m_Index = 0;\n  this.m_jointype = 0;\n  this.m_endtype = 0;\n  this.m_Childs = [];\n  this.IsOpen = false;\n};\n\nClipperLib.PolyNode.prototype.IsHoleNode = function() {\n  var result = true;\n  var node = this.m_Parent;\n  while (node !== null) {\n    result = !result;\n    node = node.m_Parent;\n  }\n  return result;\n};\n\nClipperLib.PolyNode.prototype.ChildCount = function() {\n  return this.m_Childs.length;\n};\n\nClipperLib.PolyNode.prototype.Contour = function() {\n  return this.m_polygon;\n};\n\nClipperLib.PolyNode.prototype.AddChild = function(Child) {\n  var cnt = this.m_Childs.length;\n  this.m_Childs.push(Child);\n  Child.m_Parent = this;\n  Child.m_Index = cnt;\n};\n\nClipperLib.PolyNode.prototype.GetNext = function() {\n  if (this.m_Childs.length > 0)\n    return this.m_Childs[0];\n  else\n    return this.GetNextSiblingUp();\n};\n\nClipperLib.PolyNode.prototype.GetNextSiblingUp = function() {\n  if (this.m_Parent === null)\n    return null;\n  else if (this.m_Index === this.m_Parent.m_Childs.length - 1)\n    return this.m_Parent.GetNextSiblingUp();\n  else\n    return this.m_Parent.m_Childs[this.m_Index + 1];\n};\n\nClipperLib.PolyNode.prototype.Childs = function() {\n  return this.m_Childs;\n};\n\nClipperLib.PolyNode.prototype.Parent = function() {\n  return this.m_Parent;\n};\n\nClipperLib.PolyNode.prototype.IsHole = function() {\n  return this.IsHoleNode();\n};\n\n// PolyTree : PolyNode\n/**\n * @suppress {missingProperties}\n * @constructor\n */\nClipperLib.PolyTree = function() {\n  this.m_AllPolys = [];\n  ClipperLib.PolyNode.call(this);\n};\n\nClipperLib.PolyTree.prototype.Clear = function() {\n  for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)\n    this.m_AllPolys[i] = null;\n  this.m_AllPolys.length = 0;\n  this.m_Childs.length = 0;\n};\n\nClipperLib.PolyTree.prototype.GetFirst = function() {\n  if (this.m_Childs.length > 0)\n    return this.m_Childs[0];\n  else\n    return null;\n};\n\nClipperLib.PolyTree.prototype.Total = function() {\n  var result = this.m_AllPolys.length;\n  //with negative offsets, ignore the hidden outer polygon ...\n  if (result > 0 && this.m_Childs[0] !== this.m_AllPolys[0]) result--;\n  return result;\n};\n\nInherit(ClipperLib.PolyTree, ClipperLib.PolyNode);\n\n// PolyTree & PolyNode end\n\nClipperLib.Clear = function(a) {\n  a.length = 0;\n};\n\n//ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function\nClipperLib.PI = 3.141592653589793;\nClipperLib.PI2 = 2 * 3.141592653589793;\n/**\n * @constructor\n */\nClipperLib.FPoint = function() {\n  var a = arguments,\n    alen = a.length;\n  this.x = 0;\n  this.y = 0;\n  if (alen === 2) { // public FPoint(cInt X, cInt Y)\n    this.x = a[0];\n    this.y = a[1];\n  } else if (alen === 1) {\n    if (a[0] instanceof ClipperLib.FPoint) {// public FPoint(FPoint dp)\n      var dp = a[0];\n      this.x = dp.x;\n      this.y = dp.y;\n    } else { // public FPoint(FPoint pt)\n      var pt = a[0];\n      this.x = pt.x;\n      this.y = pt.y;\n    }\n  } else { // public FPoint(FPoint pt)\n    this.x = 0;\n    this.y = 0;\n  }\n};\n\nClipperLib.FPoint.op_Equality = function(a, b) {\n  //return a == b;\n  return a.x === b.x && a.y === b.y;\n};\n\nClipperLib.FPoint.op_Inequality = function(a, b) {\n  //return a !== b;\n  return a.x !== b.x || a.y !== b.y;\n};\n\n/*\nClipperLib.FPoint.prototype.Equals = function (obj)\n{\n  if (obj === null)\n      return false;\n  if (obj instanceof ClipperLib.FPoint)\n  {\n      var a = Cast(obj, ClipperLib.FPoint);\n      return (this.x == a.x) && (this.y == a.y);\n  }\n  else\n      return false;\n};\n\n*/\n\n/**\n * @constructor\n */\nClipperLib.FPoint0 = function() {\n  this.x = 0;\n  this.y = 0;\n};\n\nClipperLib.FPoint0.prototype = ClipperLib.FPoint.prototype;\n\n/**\n * @constructor\n */\nClipperLib.FPoint1 = function(pt) {\n  this.x = pt.x;\n  this.y = pt.y;\n};\n\nClipperLib.FPoint1.prototype = ClipperLib.FPoint.prototype;\n\n/**\n * @constructor\n */\nClipperLib.FPoint1dp = function(dp) {\n  this.x = dp.x;\n  this.y = dp.y;\n};\n\nClipperLib.FPoint1dp.prototype = ClipperLib.FPoint.prototype;\n\n/**\n * @constructor\n */\nClipperLib.FPoint2 = function(x, y, z) {\n  this.x = x;\n  this.y = y;\n};\n\nClipperLib.FPoint2.prototype = ClipperLib.FPoint.prototype;\n\n/**\n * @constructor\n */\nClipperLib.FRect = function() {\n  var a = arguments,\n    alen = a.length;\n  if (alen === 4) // function (l, t, r, b)\n  {\n    this.left = a[0];\n    this.top = a[1];\n    this.right = a[2];\n    this.bottom = a[3];\n  } else if (alen === 1) // function (ir)\n  {\n    var ir = a[0];\n    this.left = ir.left;\n    this.top = ir.top;\n    this.right = ir.right;\n    this.bottom = ir.bottom;\n  } else // function ()\n  {\n    this.left = 0;\n    this.top = 0;\n    this.right = 0;\n    this.bottom = 0;\n  }\n};\n\n/**\n * @constructor\n */\nClipperLib.FRect0 = function() {\n  this.left = 0;\n  this.top = 0;\n  this.right = 0;\n  this.bottom = 0;\n};\n\nClipperLib.FRect0.prototype = ClipperLib.FRect.prototype;\n\n/**\n * @constructor\n */\nClipperLib.FRect1 = function(ir) {\n  this.left = ir.left;\n  this.top = ir.top;\n  this.right = ir.right;\n  this.bottom = ir.bottom;\n};\n\nClipperLib.FRect1.prototype = ClipperLib.FRect.prototype;\n\n/**\n * @constructor\n */\nClipperLib.FRect4 = function(l, t, r, b) {\n  this.left = l;\n  this.top = t;\n  this.right = r;\n  this.bottom = b;\n};\n\nClipperLib.FRect4.prototype = ClipperLib.FRect.prototype;\n\nClipperLib.ClipType = {\n  ctIntersection: 0,\n  ctUnion: 1,\n  ctDifference: 2,\n  ctXor: 3\n};\n\nClipperLib.PolyType = {\n  ptSubject: 0,\n  ptClip: 1\n};\n\nClipperLib.PolyFillType = {\n  pftEvenOdd: 0,\n  pftNonZero: 1,\n  pftPositive: 2,\n  pftNegative: 3\n};\n\nClipperLib.JoinType = {\n  jtSquare: 0,\n  jtRound: 1,\n  jtMiter: 2\n};\n\nClipperLib.EndType = {\n  etOpenSquare: 0,\n  etOpenRound: 1,\n  etOpenButt: 2,\n  etClosedLine: 3,\n  etClosedPolygon: 4\n};\n\nClipperLib.EdgeSide = {\n  esLeft: 0,\n  esRight: 1\n};\n\nClipperLib.Direction = {\n  dRightToLeft: 0,\n  dLeftToRight: 1\n};\n\n/**\n * @constructor\n */\nClipperLib.TEdge = function() {\n  this.Bot = new ClipperLib.FPoint0();\n  this.Curr = new ClipperLib.FPoint0(); //current (updated for every new scanbeam)\n  this.Top = new ClipperLib.FPoint0();\n  this.Delta = new ClipperLib.FPoint0();\n  this.Dx = 0;\n  this.PolyTyp = ClipperLib.PolyType.ptSubject;\n  this.Side = ClipperLib.EdgeSide.esLeft; //side only refers to current side of solution poly\n  this.WindDelta = 0; //1 or -1 depending on winding direction\n  this.WindCnt = 0;\n  this.WindCnt2 = 0; //winding count of the opposite polytype\n  this.OutIdx = 0;\n  this.Next = null;\n  this.Prev = null;\n  this.NextInLML = null;\n  this.NextInAEL = null;\n  this.PrevInAEL = null;\n  this.NextInSEL = null;\n  this.PrevInSEL = null;\n};\n\n/**\n * @constructor\n */\nClipperLib.IntersectNode = function() {\n  this.Edge1 = null;\n  this.Edge2 = null;\n  this.Pt = new ClipperLib.FPoint0();\n};\n\nClipperLib.MyIntersectNodeSort = function() {};\n\nClipperLib.MyIntersectNodeSort.Compare = function(node1, node2) {\n  var i = node2.Pt.y - node1.Pt.y;\n  if (i > 0) return 1;\n  else if (i < 0) return -1;\n  else return 0;\n};\n\n/**\n * @constructor\n */\nClipperLib.LocalMinima = function() {\n  this.y = 0;\n  this.LeftBound = null;\n  this.RightBound = null;\n  this.Next = null;\n};\n\n/**\n * @constructor\n */\nClipperLib.Scanbeam = function() {\n  this.y = 0;\n  this.Next = null;\n};\n\n/**\n * @constructor\n */\nClipperLib.Maxima = function() {\n  this.x = 0;\n  this.Next = null;\n  this.Prev = null;\n};\n\n//OutRec: contains a path in the clipping solution. Edges in the AEL will\n//carry a pointer to an OutRec when they are part of the clipping solution.\n/**\n * @constructor\n */\nClipperLib.OutRec = function() {\n  this.Idx = 0;\n  this.IsHole = false;\n  this.IsOpen = false;\n  this.FirstLeft = null; //see comments in clipper.pas\n  this.Pts = null;\n  this.BottomPt = null;\n  this.PolyNode = null;\n};\n\n/**\n * @constructor\n */\nClipperLib.OutPt = function() {\n  this.Idx = 0;\n  this.Pt = new ClipperLib.FPoint0();\n  this.Next = null;\n  this.Prev = null;\n};\n\n/**\n * @constructor\n */\nClipperLib.Join = function() {\n  this.OutPt1 = null;\n  this.OutPt2 = null;\n  this.OffPt = new ClipperLib.FPoint0();\n};\n\nClipperLib.ClipperBase = function() {\n  this.m_MinimaList = null;\n  this.m_CurrentLM = null;\n  this.m_edges = new Array();\n  this.m_HasOpenPaths = false;\n  this.PreserveCollinear = false;\n  this.m_Scanbeam = null;\n  this.m_PolyOuts = null;\n  this.m_ActiveEdges = null;\n};\n\nClipperLib.ClipperBase.horizontal = -3.4E+38;\nClipperLib.ClipperBase.Skip = -2;\nClipperLib.ClipperBase.Unassigned = -1;\nClipperLib.ClipperBase.tolerance = 1E-20;\n\n// The MAX_VALUE property has a value of 1.7976931348623157e+308. Values larger than MAX_VALUE are represented as \"Infinity\".\n//MIN_VALUE has a value of 5e-324. Values smaller than MIN_VALUE (\"underflow values\") are converted to 0.\nClipperLib.ClipperBase.maxValue = Math.sqrt(Number.MAX_VALUE); // 1.3407807929942596e+154\nClipperLib.ClipperBase.minValue = Math.sqrt(Number.MIN_VALUE); // 2.2227587494850775e-162\n\nClipperLib.ClipperBase.near_zero = function(val) {\n  return (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);\n};\n\nClipperLib.ClipperBase.IsHorizontal = function(e) {\n  return e.Delta.y === 0;\n};\n\nClipperLib.ClipperBase.prototype.PointIsVertex = function(pt, pp) {\n  var pp2 = pp;\n  do {\n    if (ClipperLib.FPoint.op_Equality(pp2.Pt, pt))\n      return true;\n    pp2 = pp2.Next;\n  }\n  while (pp2 !== pp)\n  return false;\n};\n\nClipperLib.ClipperBase.prototype.PointOnLineSegment = function(pt, linePt1, linePt2) {\n  return ((pt.x === linePt1.x) && (pt.y === linePt1.y)) || ((pt.x === linePt2.x) && (pt.y === linePt2.y)) || (((pt.x > linePt1.x) === (pt.x < linePt2.x)) && ((pt.y > linePt1.y) === (pt.y < linePt2.y)) && ((pt.x - linePt1.x) * (linePt2.y - linePt1.y) === (linePt2.x - linePt1.x) * (pt.y - linePt1.y)));\n};\n\nClipperLib.ClipperBase.prototype.PointOnPolygon = function(pt, pp) {\n  var pp2 = pp;\n  while (true) {\n    if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt))\n      return true;\n    pp2 = pp2.Next;\n    if (pp2 === pp)\n      break;\n  }\n  return false;\n};\n\nClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function() {\n  var a = arguments,\n    alen = a.length;\n  var e1, e2, pt1, pt2, pt3, pt4;\n  if (alen === 2) // function (e1, e2)\n  {\n    e1 = a[0];\n    e2 = a[1];\n    return e1.Delta.y * e2.Delta.x === e1.Delta.x * e2.Delta.y;\n  } else if (alen === 3) // function (pt1, pt2, pt3)\n  {\n    pt1 = a[0];\n    pt2 = a[1];\n    pt3 = a[2];\n    return (pt1.y - pt2.y) * (pt2.x - pt3.x) - (pt1.x - pt2.x) * (pt2.y - pt3.y) === 0;\n  } else // function (pt1, pt2, pt3, pt4)\n  {\n    pt1 = a[0];\n    pt2 = a[1];\n    pt3 = a[2];\n    pt4 = a[3];\n    return (pt1.y - pt2.y) * (pt3.x - pt4.x) - (pt1.x - pt2.x) * (pt3.y - pt4.y) === 0;\n  }\n};\n\nClipperLib.ClipperBase.SlopesEqual3 = function(e1, e2) {\n  return e1.Delta.y * e2.Delta.x === e1.Delta.x * e2.Delta.y;\n};\n\nClipperLib.ClipperBase.SlopesEqual4 = function(pt1, pt2, pt3) {\n  return (pt1.y - pt2.y) * (pt2.x - pt3.x) - (pt1.x - pt2.x) * (pt2.y - pt3.y) === 0;\n};\n\nClipperLib.ClipperBase.SlopesEqual5 = function(pt1, pt2, pt3, pt4) {\n  return (pt1.y - pt2.y) * (pt3.x - pt4.x) - (pt1.x - pt2.x) * (pt3.y - pt4.y) === 0;\n};\n\nClipperLib.ClipperBase.prototype.Clear = function() {\n  this.DisposeLocalMinimaList();\n  for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i) {\n    for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)\n      this.m_edges[i][j] = null;\n    ClipperLib.Clear(this.m_edges[i]);\n  }\n  ClipperLib.Clear(this.m_edges);\n  this.m_HasOpenPaths = false;\n};\n\nClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function() {\n  while (this.m_MinimaList !== null) {\n    var tmpLm = this.m_MinimaList.Next;\n    this.m_MinimaList = null;\n    this.m_MinimaList = tmpLm;\n  }\n  this.m_CurrentLM = null;\n};\n\nClipperLib.ClipperBase.prototype.RangeTest = function(pt) {\n  if (pt.x > ClipperLib.ClipperBase.maxValue || pt.x < -ClipperLib.ClipperBase.maxValue ||\n    pt.y > ClipperLib.ClipperBase.maxValue || pt.y < -ClipperLib.ClipperBase.maxValue ||\n    (pt.x > 0 && pt.x < ClipperLib.ClipperBase.minValue) ||\n    (pt.y > 0 && pt.y < ClipperLib.ClipperBase.minValue) ||\n    (pt.x < 0 && pt.x > -ClipperLib.ClipperBase.minValue) ||\n    (pt.y < 0 && pt.y > -ClipperLib.ClipperBase.minValue))\n    ClipperLib.Error(\"Coordinate outside allowed range in RangeTest().\");\n};\n\nClipperLib.ClipperBase.prototype.InitEdge = function(e, eNext, ePrev, pt) {\n  e.Next = eNext;\n  e.Prev = ePrev;\n  //e.Curr = pt;\n  e.Curr.x = pt.x;\n  e.Curr.y = pt.y;\n  e.OutIdx = -1;\n};\n\nClipperLib.ClipperBase.prototype.InitEdge2 = function(e, polyType) {\n  if (e.Curr.y >= e.Next.Curr.y) {\n    //e.Bot = e.Curr;\n    e.Bot.x = e.Curr.x;\n    e.Bot.y = e.Curr.y;\n    //e.Top = e.Next.Curr;\n    e.Top.x = e.Next.Curr.x;\n    e.Top.y = e.Next.Curr.y;\n  } else {\n    //e.Top = e.Curr;\n    e.Top.x = e.Curr.x;\n    e.Top.y = e.Curr.y;\n    //e.Bot = e.Next.Curr;\n    e.Bot.x = e.Next.Curr.x;\n    e.Bot.y = e.Next.Curr.y;\n  }\n  this.SetDx(e);\n  e.PolyTyp = polyType;\n};\n\nClipperLib.ClipperBase.prototype.FindNextLocMin = function(E) {\n  var E2;\n  for (;;) {\n    while (ClipperLib.FPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.FPoint.op_Equality(E.Curr, E.Top))\n      E = E.Next;\n    if (E.Dx !== ClipperLib.ClipperBase.horizontal && E.Prev.Dx !== ClipperLib.ClipperBase.horizontal)\n      break;\n    while (E.Prev.Dx === ClipperLib.ClipperBase.horizontal)\n      E = E.Prev;\n    E2 = E;\n    while (E.Dx === ClipperLib.ClipperBase.horizontal)\n      E = E.Next;\n    if (E.Top.y === E.Prev.Bot.y)\n      continue;\n    //ie just an intermediate horz.\n    if (E2.Prev.Bot.x < E.Bot.x)\n      E = E2;\n    break;\n  }\n  return E;\n};\n\nClipperLib.ClipperBase.prototype.ProcessBound = function(E, LeftBoundIsForward) {\n  var EStart;\n  var Result = E;\n  var Horz;\n\n  if (Result.OutIdx === ClipperLib.ClipperBase.Skip) {\n    //check if there are edges beyond the skip edge in the bound and if so\n    //create another LocMin and calling ProcessBound once more ...\n    E = Result;\n    if (LeftBoundIsForward) {\n      while (E.Top.y === E.Next.Bot.y) E = E.Next;\n      while (E !== Result && E.Dx === ClipperLib.ClipperBase.horizontal) E = E.Prev;\n    } else {\n      while (E.Top.y === E.Prev.Bot.y) E = E.Prev;\n      while (E !== Result && E.Dx === ClipperLib.ClipperBase.horizontal) E = E.Next;\n    }\n    if (E === Result) {\n      if (LeftBoundIsForward) Result = E.Next;\n      else Result = E.Prev;\n    } else {\n      //there are more edges in the bound beyond result starting with E\n      if (LeftBoundIsForward)\n        E = Result.Next;\n      else\n        E = Result.Prev;\n      var locMin = new ClipperLib.LocalMinima();\n      locMin.Next = null;\n      locMin.y = E.Bot.y;\n      locMin.LeftBound = null;\n      locMin.RightBound = E;\n      E.WindDelta = 0;\n      Result = this.ProcessBound(E, LeftBoundIsForward);\n      this.InsertLocalMinima(locMin);\n    }\n    return Result;\n  }\n\n  if (E.Dx === ClipperLib.ClipperBase.horizontal) {\n    //We need to be careful with open paths because this may not be a\n    //true local minima (ie E may be following a skip edge).\n    //Also, consecutive horz. edges may start heading left before going right.\n    if (LeftBoundIsForward) EStart = E.Prev;\n    else EStart = E.Next;\n\n    if (EStart.Dx === ClipperLib.ClipperBase.horizontal) //ie an adjoining horizontal skip edge\n    {\n      if (EStart.Bot.x !== E.Bot.x && EStart.Top.x !== E.Bot.x)\n        this.ReverseHorizontal(E);\n    } else if (EStart.Bot.x !== E.Bot.x)\n      this.ReverseHorizontal(E);\n  }\n\n  EStart = E;\n  if (LeftBoundIsForward) {\n    while (Result.Top.y === Result.Next.Bot.y && Result.Next.OutIdx !== ClipperLib.ClipperBase.Skip)\n      Result = Result.Next;\n    if (Result.Dx === ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx !== ClipperLib.ClipperBase.Skip) {\n      //nb: at the top of a bound, horizontals are added to the bound\n      //only when the preceding edge attaches to the horizontal's left vertex\n      //unless a Skip edge is encountered when that becomes the top divide\n      Horz = Result;\n      while (Horz.Prev.Dx === ClipperLib.ClipperBase.horizontal)\n        Horz = Horz.Prev;\n      if (Horz.Prev.Top.x > Result.Next.Top.x)\n        Result = Horz.Prev;\n    }\n    while (E !== Result) {\n      E.NextInLML = E.Next;\n      if (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot.x !== E.Prev.Top.x)\n        this.ReverseHorizontal(E);\n      E = E.Next;\n    }\n    if (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot.x !== E.Prev.Top.x)\n      this.ReverseHorizontal(E);\n    Result = Result.Next;\n    //move to the edge just beyond current bound\n  } else {\n    while (Result.Top.y === Result.Prev.Bot.y && Result.Prev.OutIdx !== ClipperLib.ClipperBase.Skip)\n      Result = Result.Prev;\n    if (Result.Dx === ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx !== ClipperLib.ClipperBase.Skip) {\n      Horz = Result;\n      while (Horz.Next.Dx === ClipperLib.ClipperBase.horizontal)\n        Horz = Horz.Next;\n      if (Horz.Next.Top.x === Result.Prev.Top.x || Horz.Next.Top.x > Result.Prev.Top.x) {\n        Result = Horz.Next;\n      }\n    }\n    while (E !== Result) {\n      E.NextInLML = E.Prev;\n      if (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot.x !== E.Next.Top.x)\n        this.ReverseHorizontal(E);\n      E = E.Prev;\n    }\n    if (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot.x !== E.Next.Top.x)\n      this.ReverseHorizontal(E);\n    Result = Result.Prev;\n    //move to the edge just beyond current bound\n  }\n\n  return Result;\n};\n\nClipperLib.ClipperBase.prototype.AddPath = function(pg, polyType, Closed) {\n  if (!Closed)\n    ClipperLib.Error(\"AddPath: Open paths have been disabled.\");\n\n  var highI = pg.length - 1;\n  if (Closed)\n    while (highI > 0 && (ClipperLib.FPoint.op_Equality(pg[highI], pg[0])))\n      --highI;\n  while (highI > 0 && (ClipperLib.FPoint.op_Equality(pg[highI], pg[highI - 1])))\n    --highI;\n  if ((Closed && highI < 2) || (!Closed && highI < 1))\n    return false;\n  //create a new edge array ...\n  var edges = new Array();\n  for (var i = 0; i <= highI; i++)\n    edges.push(new ClipperLib.TEdge());\n  var IsFlat = true;\n  //1. Basic (first) edge initialization ...\n\n  //edges[1].Curr = pg[1];\n  edges[1].Curr.x = pg[1].x;\n  edges[1].Curr.y = pg[1].y;\n\n  this.RangeTest(pg[0]);\n\n  this.RangeTest(pg[highI]);\n\n  this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);\n  this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);\n  for (var i = highI - 1; i >= 1; --i) {\n    this.RangeTest(pg[i]);\n\n    this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);\n  }\n\n  var eStart = edges[0];\n  //2. Remove duplicate vertices, and (when closed) collinear edges ...\n  var E = eStart,\n    eLoopStop = eStart;\n  for (;;) {\n    //console.log(E.Next, eStart);\n    //nb: allows matching start and end points when not Closed ...\n    if (E.Curr === E.Next.Curr && (Closed || E.Next !== eStart)) {\n      if (E === E.Next)\n        break;\n      if (E === eStart)\n        eStart = E.Next;\n      E = this.RemoveEdge(E);\n      eLoopStop = E;\n      continue;\n    }\n    if (E.Prev === E.Next)\n      break;\n    else if (Closed && ClipperLib.ClipperBase.SlopesEqual4(E.Prev.Curr, E.Curr, E.Next.Curr) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr))) {\n      //Collinear edges are allowed for open paths but in closed paths\n      //the default is to merge adjacent collinear edges into a single edge.\n      //However, if the PreserveCollinear property is enabled, only overlapping\n      //collinear edges (ie spikes) will be removed from closed paths.\n      if (E === eStart)\n        eStart = E.Next;\n      E = this.RemoveEdge(E);\n      E = E.Prev;\n      eLoopStop = E;\n      continue;\n    }\n    E = E.Next;\n    if ((E === eLoopStop) || (!Closed && E.Next === eStart)) break;\n  }\n  if ((!Closed && (E === E.Next)) || (Closed && (E.Prev === E.Next)))\n    return false;\n  if (!Closed) {\n    this.m_HasOpenPaths = true;\n    eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n  }\n  //3. Do second stage of edge initialization ...\n  E = eStart;\n  do {\n    this.InitEdge2(E, polyType);\n    E = E.Next;\n    if (IsFlat && E.Curr.y !== eStart.Curr.y)\n      IsFlat = false;\n  }\n  while (E !== eStart)\n  //4. Finally, add edge bounds to LocalMinima list ...\n  //Totally flat paths must be handled differently when adding them\n  //to LocalMinima list to avoid endless loops etc ...\n  if (IsFlat) {\n    if (Closed)\n      return false;\n\n    E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n\n    var locMin = new ClipperLib.LocalMinima();\n    locMin.Next = null;\n    locMin.y = E.Bot.y;\n    locMin.LeftBound = null;\n    locMin.RightBound = E;\n    locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n    locMin.RightBound.WindDelta = 0;\n\n    for (;;) {\n      if (E.Bot.x !== E.Prev.Top.x) this.ReverseHorizontal(E);\n      if (E.Next.OutIdx === ClipperLib.ClipperBase.Skip) break;\n      E.NextInLML = E.Next;\n      E = E.Next;\n    }\n    this.InsertLocalMinima(locMin);\n    this.m_edges.push(edges);\n    return true;\n  }\n  this.m_edges.push(edges);\n  var leftBoundIsForward;\n  var EMin = null;\n\n  //workaround to avoid an endless loop in the while loop below when\n  //open paths have matching start and end points ...\n  if (ClipperLib.FPoint.op_Equality(E.Prev.Bot, E.Prev.Top))\n    E = E.Next;\n\n  for (;;) {\n    E = this.FindNextLocMin(E);\n    if (E === EMin)\n      break;\n    else if (EMin === null)\n      EMin = E;\n    //E and E.Prev now share a local minima (left aligned if horizontal).\n    //Compare their slopes to find which starts which bound ...\n    var locMin = new ClipperLib.LocalMinima();\n    locMin.Next = null;\n    locMin.y = E.Bot.y;\n    if (E.Dx < E.Prev.Dx) {\n      locMin.LeftBound = E.Prev;\n      locMin.RightBound = E;\n      leftBoundIsForward = false;\n      //Q.nextInLML = Q.prev\n    } else {\n      locMin.LeftBound = E;\n      locMin.RightBound = E.Prev;\n      leftBoundIsForward = true;\n      //Q.nextInLML = Q.next\n    }\n    locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;\n    locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n    if (!Closed)\n      locMin.LeftBound.WindDelta = 0;\n    else if (locMin.LeftBound.Next === locMin.RightBound)\n      locMin.LeftBound.WindDelta = -1;\n    else\n      locMin.LeftBound.WindDelta = 1;\n    locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;\n    E = this.ProcessBound(locMin.LeftBound, leftBoundIsForward);\n    if (E.OutIdx === ClipperLib.ClipperBase.Skip)\n      E = this.ProcessBound(E, leftBoundIsForward);\n    var E2 = this.ProcessBound(locMin.RightBound, !leftBoundIsForward);\n    if (E2.OutIdx === ClipperLib.ClipperBase.Skip) E2 = this.ProcessBound(E2, !leftBoundIsForward);\n    if (locMin.LeftBound.OutIdx === ClipperLib.ClipperBase.Skip)\n      locMin.LeftBound = null;\n    else if (locMin.RightBound.OutIdx === ClipperLib.ClipperBase.Skip)\n      locMin.RightBound = null;\n    this.InsertLocalMinima(locMin);\n    if (!leftBoundIsForward)\n      E = E2;\n  }\n  return true;\n};\n\nClipperLib.ClipperBase.prototype.AddPaths = function(ppg, polyType, closed) {\n  //  console.log(\"-------------------------------------------\");\n  //  console.log(JSON.stringify(ppg));\n  var result = false;\n  for (var i = 0, ilen = ppg.length; i < ilen; ++i)\n    if (this.AddPath(ppg[i], polyType, closed))\n      result = true;\n  return result;\n};\n\nClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function(pt1, pt2, pt3) {\n  if ((ClipperLib.FPoint.op_Equality(pt1, pt3)) || (ClipperLib.FPoint.op_Equality(pt1, pt2)) || (ClipperLib.FPoint.op_Equality(pt3, pt2)))\n\n    //if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))\n    return false;\n\n  else if (pt1.x !== pt3.x)\n    return (pt2.x > pt1.x) === (pt2.x < pt3.x);\n  else\n    return (pt2.y > pt1.y) === (pt2.y < pt3.y);\n};\n\nClipperLib.ClipperBase.prototype.RemoveEdge = function(e) {\n  //removes e from double_linked_list (but without removing from memory)\n  e.Prev.Next = e.Next;\n  e.Next.Prev = e.Prev;\n  var result = e.Next;\n  e.Prev = null; //flag as removed (see ClipperBase.Clear)\n  return result;\n};\n\nClipperLib.ClipperBase.prototype.SetDx = function(e) {\n  e.Delta.x = (e.Top.x - e.Bot.x);\n  e.Delta.y = (e.Top.y - e.Bot.y);\n  if (e.Delta.y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;\n  else e.Dx = (e.Delta.x) / (e.Delta.y);\n};\n\nClipperLib.ClipperBase.prototype.InsertLocalMinima = function(newLm) {\n  if (this.m_MinimaList === null) {\n    this.m_MinimaList = newLm;\n  } else if (newLm.y >= this.m_MinimaList.y) {\n    newLm.Next = this.m_MinimaList;\n    this.m_MinimaList = newLm;\n  } else {\n    var tmpLm = this.m_MinimaList;\n    while (tmpLm.Next !== null && (newLm.y < tmpLm.Next.y))\n      tmpLm = tmpLm.Next;\n    newLm.Next = tmpLm.Next;\n    tmpLm.Next = newLm;\n  }\n};\n\nClipperLib.ClipperBase.prototype.PopLocalMinima = function(Y, current) {\n  current.v = this.m_CurrentLM;\n  if (this.m_CurrentLM !== null && this.m_CurrentLM.y === Y) {\n    this.m_CurrentLM = this.m_CurrentLM.Next;\n    return true;\n  }\n  return false;\n};\n\nClipperLib.ClipperBase.prototype.ReverseHorizontal = function(e) {\n  //swap horizontal edges' top and bottom x's so they follow the natural\n  //progression of the bounds - ie so their xbots will align with the\n  //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\n  var tmp = e.Top.x;\n  e.Top.x = e.Bot.x;\n  e.Bot.x = tmp;\n};\n\nClipperLib.ClipperBase.prototype.Reset = function() {\n  this.m_CurrentLM = this.m_MinimaList;\n  if (this.m_CurrentLM === null) //ie nothing to process\n    return;\n  //reset all edges ...\n  this.m_Scanbeam = null;\n  var lm = this.m_MinimaList;\n  while (lm !== null) {\n    this.InsertScanbeam(lm.y);\n    var e = lm.LeftBound;\n    if (e !== null) {\n      //e.Curr = e.Bot;\n      e.Curr.x = e.Bot.x;\n      e.Curr.y = e.Bot.y;\n      e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n    }\n    e = lm.RightBound;\n    if (e !== null) {\n      //e.Curr = e.Bot;\n      e.Curr.x = e.Bot.x;\n      e.Curr.y = e.Bot.y;\n      e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n    }\n    lm = lm.Next;\n  }\n  this.m_ActiveEdges = null;\n};\n\nClipperLib.ClipperBase.prototype.InsertScanbeam = function(Y) {\n  //single-linked list: sorted descending, ignoring dups.\n  if (this.m_Scanbeam === null) {\n    this.m_Scanbeam = new ClipperLib.Scanbeam();\n    this.m_Scanbeam.Next = null;\n    this.m_Scanbeam.y = Y;\n  } else if (Y > this.m_Scanbeam.y) {\n    var newSb = new ClipperLib.Scanbeam();\n    newSb.y = Y;\n    newSb.Next = this.m_Scanbeam;\n    this.m_Scanbeam = newSb;\n  } else {\n    var sb2 = this.m_Scanbeam;\n    while (sb2.Next !== null && Y <= sb2.Next.y) {\n      sb2 = sb2.Next;\n    }\n    if (Y === sb2.y) {\n      return;\n    } //ie ignores duplicates\n    var newSb1 = new ClipperLib.Scanbeam();\n    newSb1.y = Y;\n    newSb1.Next = sb2.Next;\n    sb2.Next = newSb1;\n  }\n};\n\nClipperLib.ClipperBase.prototype.PopScanbeam = function(Y) {\n  if (this.m_Scanbeam === null) {\n    Y.v = 0;\n    return false;\n  }\n  Y.v = this.m_Scanbeam.y;\n  this.m_Scanbeam = this.m_Scanbeam.Next;\n  return true;\n};\n\nClipperLib.ClipperBase.prototype.LocalMinimaPending = function() {\n  return (this.m_CurrentLM !== null);\n};\n\nClipperLib.ClipperBase.prototype.CreateOutRec = function() {\n  var result = new ClipperLib.OutRec();\n  result.Idx = ClipperLib.ClipperBase.Unassigned;\n  result.IsHole = false;\n  result.IsOpen = false;\n  result.FirstLeft = null;\n  result.Pts = null;\n  result.BottomPt = null;\n  result.PolyNode = null;\n  this.m_PolyOuts.push(result);\n  result.Idx = this.m_PolyOuts.length - 1;\n  return result;\n};\n\nClipperLib.ClipperBase.prototype.DisposeOutRec = function(index) {\n  var outRec = this.m_PolyOuts[index];\n  outRec.Pts = null;\n  outRec = null;\n  this.m_PolyOuts[index] = null;\n};\n\nClipperLib.ClipperBase.prototype.UpdateEdgeIntoAEL = function(e) {\n  if (e.NextInLML === null) {\n    ClipperLib.Error(\"UpdateEdgeIntoAEL: invalid call\");\n  }\n  var AelPrev = e.PrevInAEL;\n  var AelNext = e.NextInAEL;\n  e.NextInLML.OutIdx = e.OutIdx;\n  if (AelPrev !== null) {\n    AelPrev.NextInAEL = e.NextInLML;\n  } else {\n    this.m_ActiveEdges = e.NextInLML;\n  }\n  if (AelNext !== null) {\n    AelNext.PrevInAEL = e.NextInLML;\n  }\n  e.NextInLML.Side = e.Side;\n  e.NextInLML.WindDelta = e.WindDelta;\n  e.NextInLML.WindCnt = e.WindCnt;\n  e.NextInLML.WindCnt2 = e.WindCnt2;\n  e = e.NextInLML;\n  e.Curr.x = e.Bot.x;\n  e.Curr.y = e.Bot.y;\n  e.PrevInAEL = AelPrev;\n  e.NextInAEL = AelNext;\n  if (!ClipperLib.ClipperBase.IsHorizontal(e)) {\n    this.InsertScanbeam(e.Top.y);\n  }\n  return e;\n};\n\nClipperLib.ClipperBase.prototype.SwapPositionsInAEL = function(edge1, edge2) {\n  //check that one or other edge hasn't already been removed from AEL ...\n  if (edge1.NextInAEL === edge1.PrevInAEL || edge2.NextInAEL === edge2.PrevInAEL) {\n    return;\n  }\n\n  if (edge1.NextInAEL === edge2) {\n    var next = edge2.NextInAEL;\n    if (next !== null) {\n      next.PrevInAEL = edge1;\n    }\n    var prev = edge1.PrevInAEL;\n    if (prev !== null) {\n      prev.NextInAEL = edge2;\n    }\n    edge2.PrevInAEL = prev;\n    edge2.NextInAEL = edge1;\n    edge1.PrevInAEL = edge2;\n    edge1.NextInAEL = next;\n  } else if (edge2.NextInAEL === edge1) {\n    var next1 = edge1.NextInAEL;\n    if (next1 !== null) {\n      next1.PrevInAEL = edge2;\n    }\n    var prev1 = edge2.PrevInAEL;\n    if (prev1 !== null) {\n      prev1.NextInAEL = edge1;\n    }\n    edge1.PrevInAEL = prev1;\n    edge1.NextInAEL = edge2;\n    edge2.PrevInAEL = edge1;\n    edge2.NextInAEL = next1;\n  } else {\n    var next2 = edge1.NextInAEL;\n    var prev2 = edge1.PrevInAEL;\n    edge1.NextInAEL = edge2.NextInAEL;\n    if (edge1.NextInAEL !== null) {\n      edge1.NextInAEL.PrevInAEL = edge1;\n    }\n    edge1.PrevInAEL = edge2.PrevInAEL;\n    if (edge1.PrevInAEL !== null) {\n      edge1.PrevInAEL.NextInAEL = edge1;\n    }\n    edge2.NextInAEL = next2;\n    if (edge2.NextInAEL !== null) {\n      edge2.NextInAEL.PrevInAEL = edge2;\n    }\n    edge2.PrevInAEL = prev2;\n    if (edge2.PrevInAEL !== null) {\n      edge2.PrevInAEL.NextInAEL = edge2;\n    }\n  }\n\n  if (edge1.PrevInAEL === null) {\n    this.m_ActiveEdges = edge1;\n  } else {\n    if (edge2.PrevInAEL === null) {\n      this.m_ActiveEdges = edge2;\n    }\n  }\n};\n\nClipperLib.ClipperBase.prototype.DeleteFromAEL = function(e) {\n  var AelPrev = e.PrevInAEL;\n  var AelNext = e.NextInAEL;\n  if (AelPrev === null && AelNext === null && e !== this.m_ActiveEdges) {\n    return;\n  } //already deleted\n  if (AelPrev !== null) {\n    AelPrev.NextInAEL = AelNext;\n  } else {\n    this.m_ActiveEdges = AelNext;\n  }\n  if (AelNext !== null) {\n    AelNext.PrevInAEL = AelPrev;\n  }\n  e.NextInAEL = null;\n  e.PrevInAEL = null;\n}\n\n// public Clipper(int InitOptions = 0)\n/**\n * @suppress {missingProperties}\n */\nClipperLib.Clipper = function(InitOptions) {\n  if (typeof(InitOptions) === \"undefined\") InitOptions = 0;\n  this.m_PolyOuts = null;\n  this.m_ClipType = ClipperLib.ClipType.ctIntersection;\n  this.m_Scanbeam = null;\n  this.m_Maxima = null;\n  this.m_ActiveEdges = null;\n  this.m_SortedEdges = null;\n  this.m_IntersectList = null;\n  this.m_IntersectNodeComparer = null;\n  this.m_ExecuteLocked = false;\n  this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;\n  this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;\n  this.m_Joins = null;\n  this.m_GhostJoins = null;\n  this.m_UsingPolyTree = false;\n  this.ReverseSolution = false;\n  this.StrictlySimple = false;\n\n  ClipperLib.ClipperBase.call(this);\n\n  this.m_Scanbeam = null;\n  this.m_Maxima = null;\n  this.m_ActiveEdges = null;\n  this.m_SortedEdges = null;\n  this.m_IntersectList = new Array();\n  this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;\n  this.m_ExecuteLocked = false;\n  this.m_UsingPolyTree = false;\n  this.m_PolyOuts = new Array();\n  this.m_Joins = new Array();\n  this.m_GhostJoins = new Array();\n  this.ReverseSolution = (1 & InitOptions) !== 0;\n  this.StrictlySimple = (2 & InitOptions) !== 0;\n  this.PreserveCollinear = (4 & InitOptions) !== 0;\n};\n\nClipperLib.Clipper.ioReverseSolution = 1;\nClipperLib.Clipper.ioStrictlySimple = 2;\nClipperLib.Clipper.ioPreserveCollinear = 4;\n\nClipperLib.Clipper.prototype.Clear = function() {\n  if (this.m_edges.length === 0)\n    return;\n  //avoids problems with ClipperBase destructor\n  this.DisposeAllPolyPts();\n  ClipperLib.ClipperBase.prototype.Clear.call(this);\n};\n\nClipperLib.Clipper.prototype.InsertMaxima = function(X) {\n  //double-linked list: sorted ascending, ignoring dups.\n  var newMax = new ClipperLib.Maxima();\n  newMax.x = X;\n  if (this.m_Maxima === null) {\n    this.m_Maxima = newMax;\n    this.m_Maxima.Next = null;\n    this.m_Maxima.Prev = null;\n  } else if (X < this.m_Maxima.x) {\n    newMax.Next = this.m_Maxima;\n    newMax.Prev = null;\n    this.m_Maxima = newMax;\n  } else {\n    var m = this.m_Maxima;\n    while (m.Next !== null && X >= m.Next.x) {\n      m = m.Next;\n    }\n    if (X === m.x) {\n      return;\n    } //ie ignores duplicates (& CG to clean up newMax)\n    //insert newMax between m and m.Next ...\n    newMax.Next = m.Next;\n    newMax.Prev = m;\n    if (m.Next !== null) {\n      m.Next.Prev = newMax;\n    }\n    m.Next = newMax;\n  }\n};\n\n// ************************************\nClipperLib.Clipper.prototype.Execute = function() {\n  var a = arguments,\n    alen = a.length,\n    ispolytree = a[1] instanceof ClipperLib.PolyTree;\n  if (alen === 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)\n  {\n    var clipType = a[0],\n      solution = a[1],\n      subjFillType = a[2],\n      clipFillType = a[3];\n    if (this.m_ExecuteLocked)\n      return false;\n    if (this.m_HasOpenPaths)\n      ClipperLib.Error(\"Error: PolyTree struct is needed for open path clipping.\");\n    this.m_ExecuteLocked = true;\n    ClipperLib.Clear(solution);\n    this.m_SubjFillType = subjFillType;\n    this.m_ClipFillType = clipFillType;\n    this.m_ClipType = clipType;\n    this.m_UsingPolyTree = false;\n    try {\n      var succeeded = this.ExecuteInternal();\n      //build the return polygons ...\n      if (succeeded) this.BuildResult(solution);\n    } finally {\n      this.DisposeAllPolyPts();\n      this.m_ExecuteLocked = false;\n    }\n    return succeeded;\n  } else if (alen === 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)\n  {\n    var clipType = a[0],\n      polytree = a[1],\n      subjFillType = a[2],\n      clipFillType = a[3];\n    if (this.m_ExecuteLocked)\n      return false;\n    this.m_ExecuteLocked = true;\n    this.m_SubjFillType = subjFillType;\n    this.m_ClipFillType = clipFillType;\n    this.m_ClipType = clipType;\n    this.m_UsingPolyTree = true;\n    try {\n      var succeeded = this.ExecuteInternal();\n      //build the return polygons ...\n      if (succeeded) this.BuildResult2(polytree);\n    } finally {\n      this.DisposeAllPolyPts();\n      this.m_ExecuteLocked = false;\n    }\n    return succeeded;\n  } else if (alen === 2 && !ispolytree) // function (clipType, solution)\n  {\n    var clipType = a[0],\n      solution = a[1];\n    return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n  } else if (alen === 2 && ispolytree) // function (clipType, polytree)\n  {\n    var clipType = a[0],\n      polytree = a[1];\n    return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n  }\n};\n\nClipperLib.Clipper.prototype.FixHoleLinkage = function(outRec) {\n  //skip if an outermost polygon or\n  //already already points to the correct FirstLeft ...\n  if (outRec.FirstLeft === null || (outRec.IsHole !== outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))\n    return;\n  var orfl = outRec.FirstLeft;\n  while (orfl !== null && ((orfl.IsHole === outRec.IsHole) || orfl.Pts === null))\n    orfl = orfl.FirstLeft;\n  outRec.FirstLeft = orfl;\n};\n\nClipperLib.Clipper.prototype.ExecuteInternal = function() {\n  try {\n    this.Reset();\n    this.m_SortedEdges = null;\n    this.m_Maxima = null;\n\n    var botY = {},\n      topY = {};\n\n    if (!this.PopScanbeam(botY)) {\n      return false;\n    }\n    this.InsertLocalMinimaIntoAEL(botY.v);\n    while (this.PopScanbeam(topY) || this.LocalMinimaPending()) {\n      this.ProcessHorizontals();\n      this.m_GhostJoins.length = 0;\n      if (!this.ProcessIntersections(topY.v)) {\n        return false;\n      }\n      this.ProcessEdgesAtTopOfScanbeam(topY.v);\n      botY.v = topY.v;\n      this.InsertLocalMinimaIntoAEL(botY.v);\n    }\n\n    //fix orientations ...\n    var outRec, i, ilen;\n    //fix orientations ...\n    for (i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n      outRec = this.m_PolyOuts[i];\n      if (outRec.Pts === null || outRec.IsOpen) continue;\n      if ((outRec.IsHole ^ this.ReverseSolution) == (this.Area$1(outRec) > 0))\n        this.ReversePolyPtLinks(outRec.Pts);\n    }\n\n    this.JoinCommonEdges();\n\n    for (i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n      outRec = this.m_PolyOuts[i];\n      if (outRec.Pts === null)\n        continue;\n      else if (outRec.IsOpen)\n        this.FixupOutPolyline(outRec);\n      else\n        this.FixupOutPolygon(outRec);\n    }\n\n    if (this.StrictlySimple) this.DoSimplePolygons();\n    return true;\n  }\n  //catch { return false; }\n  finally {\n    this.m_Joins.length = 0;\n    this.m_GhostJoins.length = 0;\n  }\n};\n\nClipperLib.Clipper.prototype.DisposeAllPolyPts = function() {\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)\n    this.DisposeOutRec(i);\n  ClipperLib.Clear(this.m_PolyOuts);\n};\n\nClipperLib.Clipper.prototype.AddJoin = function(Op1, Op2, OffPt) {\n  var j = new ClipperLib.Join();\n  j.OutPt1 = Op1;\n  j.OutPt2 = Op2;\n  //j.OffPt = OffPt;\n  j.OffPt.x = OffPt.x;\n  j.OffPt.y = OffPt.y;\n  this.m_Joins.push(j);\n};\n\nClipperLib.Clipper.prototype.AddGhostJoin = function(Op, OffPt) {\n  var j = new ClipperLib.Join();\n  j.OutPt1 = Op;\n  //j.OffPt = OffPt;\n  j.OffPt.x = OffPt.x;\n  j.OffPt.y = OffPt.y;\n  this.m_GhostJoins.push(j);\n};\n\nClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function(botY) {\n  var lm = {};\n\n  var lb;\n  var rb;\n  while (this.PopLocalMinima(botY, lm)) {\n    lb = lm.v.LeftBound;\n    rb = lm.v.RightBound;\n\n    var Op1 = null;\n    if (lb === null) {\n      this.InsertEdgeIntoAEL(rb, null);\n      this.SetWindingCount(rb);\n      if (this.IsContributing(rb))\n        Op1 = this.AddOutPt(rb, rb.Bot);\n    } else if (rb === null) {\n      this.InsertEdgeIntoAEL(lb, null);\n      this.SetWindingCount(lb);\n      if (this.IsContributing(lb))\n        Op1 = this.AddOutPt(lb, lb.Bot);\n      this.InsertScanbeam(lb.Top.y);\n    } else {\n      this.InsertEdgeIntoAEL(lb, null);\n      this.InsertEdgeIntoAEL(rb, lb);\n      this.SetWindingCount(lb);\n      rb.WindCnt = lb.WindCnt;\n      rb.WindCnt2 = lb.WindCnt2;\n      if (this.IsContributing(lb))\n        Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);\n      this.InsertScanbeam(lb.Top.y);\n    }\n    if (rb !== null) {\n      if (ClipperLib.ClipperBase.IsHorizontal(rb)) {\n        if (rb.NextInLML !== null) {\n          this.InsertScanbeam(rb.NextInLML.Top.y);\n        }\n        this.AddEdgeToSEL(rb);\n      } else {\n        this.InsertScanbeam(rb.Top.y);\n      }\n    }\n    if (lb === null || rb === null) continue;\n    //if output polygons share an Edge with a horizontal rb, they'll need joining later ...\n    if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0) {\n      for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++) {\n        //if the horizontal Rb and a 'ghost' horizontal overlap, then convert\n        //the 'ghost' join to a real join ready for later ...\n        var j = this.m_GhostJoins[i];\n\n        if (this.HorzSegmentsOverlap(j.OutPt1.Pt.x, j.OffPt.x, rb.Bot.x, rb.Top.x))\n          this.AddJoin(j.OutPt1, Op1, j.OffPt);\n      }\n    }\n\n    if (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&\n      lb.PrevInAEL.Curr.x === lb.Bot.x &&\n      lb.PrevInAEL.OutIdx >= 0 &&\n      ClipperLib.ClipperBase.SlopesEqual5(lb.PrevInAEL.Curr, lb.PrevInAEL.Top, lb.Curr, lb.Top) &&\n      lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0) {\n      var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);\n      this.AddJoin(Op1, Op2, lb.Top);\n    }\n    if (lb.NextInAEL !== rb) {\n      if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&\n        ClipperLib.ClipperBase.SlopesEqual5(rb.PrevInAEL.Curr, rb.PrevInAEL.Top, rb.Curr, rb.Top) &&\n        rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0) {\n        var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);\n        this.AddJoin(Op1, Op2, rb.Top);\n      }\n      var e = lb.NextInAEL;\n      if (e !== null)\n        while (e !== rb) {\n          //nb: For calculating winding counts etc, IntersectEdges() assumes\n          //that param1 will be to the right of param2 ABOVE the intersection ...\n          this.IntersectEdges(rb, e, lb.Curr);\n          //order important here\n          e = e.NextInAEL;\n        }\n    }\n  }\n};\n\nClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function(edge, startEdge) {\n  if (this.m_ActiveEdges === null) {\n    edge.PrevInAEL = null;\n    edge.NextInAEL = null;\n    this.m_ActiveEdges = edge;\n  } else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge)) {\n    edge.PrevInAEL = null;\n    edge.NextInAEL = this.m_ActiveEdges;\n    this.m_ActiveEdges.PrevInAEL = edge;\n    this.m_ActiveEdges = edge;\n  } else {\n    if (startEdge === null)\n      startEdge = this.m_ActiveEdges;\n    while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))\n      startEdge = startEdge.NextInAEL;\n    edge.NextInAEL = startEdge.NextInAEL;\n    if (startEdge.NextInAEL !== null)\n      startEdge.NextInAEL.PrevInAEL = edge;\n    edge.PrevInAEL = startEdge;\n    startEdge.NextInAEL = edge;\n  }\n};\n\nClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function(e1, e2) {\n  if (e2.Curr.x === e1.Curr.x) {\n    if (e2.Top.y > e1.Top.y)\n      return e2.Top.x < ClipperLib.Clipper.TopX(e1, e2.Top.y);\n    else\n      return e1.Top.x > ClipperLib.Clipper.TopX(e2, e1.Top.y);\n  } else\n    return e2.Curr.x < e1.Curr.x;\n};\n\nClipperLib.Clipper.prototype.IsEvenOddFillType = function(edge) {\n  if (edge.PolyTyp === ClipperLib.PolyType.ptSubject)\n    return this.m_SubjFillType === ClipperLib.PolyFillType.pftEvenOdd;\n  else\n    return this.m_ClipFillType === ClipperLib.PolyFillType.pftEvenOdd;\n};\n\nClipperLib.Clipper.prototype.IsEvenOddAltFillType = function(edge) {\n  if (edge.PolyTyp === ClipperLib.PolyType.ptSubject)\n    return this.m_ClipFillType === ClipperLib.PolyFillType.pftEvenOdd;\n  else\n    return this.m_SubjFillType === ClipperLib.PolyFillType.pftEvenOdd;\n};\n\nClipperLib.Clipper.prototype.IsContributing = function(edge) {\n  var pft, pft2;\n  if (edge.PolyTyp === ClipperLib.PolyType.ptSubject) {\n    pft = this.m_SubjFillType;\n    pft2 = this.m_ClipFillType;\n  } else {\n    pft = this.m_ClipFillType;\n    pft2 = this.m_SubjFillType;\n  }\n  switch (pft) {\n    case ClipperLib.PolyFillType.pftEvenOdd:\n      if (edge.WindDelta === 0 && edge.WindCnt !== 1)\n        return false;\n      break;\n    case ClipperLib.PolyFillType.pftNonZero:\n      if (Math.abs(edge.WindCnt) !== 1)\n        return false;\n      break;\n    case ClipperLib.PolyFillType.pftPositive:\n      if (edge.WindCnt !== 1)\n        return false;\n      break;\n    default:\n      if (edge.WindCnt !== -1)\n        return false;\n      break;\n  }\n  switch (this.m_ClipType) {\n    case ClipperLib.ClipType.ctIntersection:\n      switch (pft2) {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 !== 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 > 0);\n        default:\n          return (edge.WindCnt2 < 0);\n      }\n      case ClipperLib.ClipType.ctUnion:\n        switch (pft2) {\n          case ClipperLib.PolyFillType.pftEvenOdd:\n          case ClipperLib.PolyFillType.pftNonZero:\n            return (edge.WindCnt2 === 0);\n          case ClipperLib.PolyFillType.pftPositive:\n            return (edge.WindCnt2 <= 0);\n          default:\n            return (edge.WindCnt2 >= 0);\n        }\n        case ClipperLib.ClipType.ctDifference:\n          if (edge.PolyTyp === ClipperLib.PolyType.ptSubject)\n            switch (pft2) {\n              case ClipperLib.PolyFillType.pftEvenOdd:\n              case ClipperLib.PolyFillType.pftNonZero:\n                return (edge.WindCnt2 === 0);\n              case ClipperLib.PolyFillType.pftPositive:\n                return (edge.WindCnt2 <= 0);\n              default:\n                return (edge.WindCnt2 >= 0);\n            }\n          else\n            switch (pft2) {\n              case ClipperLib.PolyFillType.pftEvenOdd:\n              case ClipperLib.PolyFillType.pftNonZero:\n                return (edge.WindCnt2 !== 0);\n              case ClipperLib.PolyFillType.pftPositive:\n                return (edge.WindCnt2 > 0);\n              default:\n                return (edge.WindCnt2 < 0);\n            }\n        case ClipperLib.ClipType.ctXor:\n          if (edge.WindDelta === 0)\n            switch (pft2) {\n              case ClipperLib.PolyFillType.pftEvenOdd:\n              case ClipperLib.PolyFillType.pftNonZero:\n                return (edge.WindCnt2 === 0);\n              case ClipperLib.PolyFillType.pftPositive:\n                return (edge.WindCnt2 <= 0);\n              default:\n                return (edge.WindCnt2 >= 0);\n            }\n          else\n            return true;\n  }\n  return true;\n};\n\nClipperLib.Clipper.prototype.SetWindingCount = function(edge) {\n  var e = edge.PrevInAEL;\n  //find the edge of the same polytype that immediately preceeds 'edge' in AEL\n  while (e !== null && ((e.PolyTyp !== edge.PolyTyp) || (e.WindDelta === 0)))\n    e = e.PrevInAEL;\n  if (e === null) {\n    var pft = (edge.PolyTyp === ClipperLib.PolyType.ptSubject ? this.m_SubjFillType : this.m_ClipFillType);\n    if (edge.WindDelta === 0) {\n      edge.WindCnt = (pft === ClipperLib.PolyFillType.pftNegative ? -1 : 1);\n    } else {\n      edge.WindCnt = edge.WindDelta;\n    }\n    edge.WindCnt2 = 0;\n    e = this.m_ActiveEdges;\n    //ie get ready to calc WindCnt2\n  } else if (edge.WindDelta === 0 && this.m_ClipType !== ClipperLib.ClipType.ctUnion) {\n    edge.WindCnt = 1;\n    edge.WindCnt2 = e.WindCnt2;\n    e = e.NextInAEL;\n    //ie get ready to calc WindCnt2\n  } else if (this.IsEvenOddFillType(edge)) {\n    //EvenOdd filling ...\n    if (edge.WindDelta === 0) {\n      //are we inside a subj polygon ...\n      var Inside = true;\n      var e2 = e.PrevInAEL;\n      while (e2 !== null) {\n        if (e2.PolyTyp === e.PolyTyp && e2.WindDelta !== 0)\n          Inside = !Inside;\n        e2 = e2.PrevInAEL;\n      }\n      edge.WindCnt = (Inside ? 0 : 1);\n    } else {\n      edge.WindCnt = edge.WindDelta;\n    }\n    edge.WindCnt2 = e.WindCnt2;\n    e = e.NextInAEL;\n    //ie get ready to calc WindCnt2\n  } else {\n    //nonZero, Positive or Negative filling ...\n    if (e.WindCnt * e.WindDelta < 0) {\n      //prev edge is 'decreasing' WindCount (WC) toward zero\n      //so we're outside the previous polygon ...\n      if (Math.abs(e.WindCnt) > 1) {\n        //outside prev poly but still inside another.\n        //when reversing direction of prev poly use the same WC\n        if (e.WindDelta * edge.WindDelta < 0)\n          edge.WindCnt = e.WindCnt;\n        else\n          edge.WindCnt = e.WindCnt + edge.WindDelta;\n      } else\n        edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n    } else {\n      //prev edge is 'increasing' WindCount (WC) away from zero\n      //so we're inside the previous polygon ...\n      if (edge.WindDelta === 0)\n        edge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);\n      else if (e.WindDelta * edge.WindDelta < 0)\n        edge.WindCnt = e.WindCnt;\n      else\n        edge.WindCnt = e.WindCnt + edge.WindDelta;\n    }\n    edge.WindCnt2 = e.WindCnt2;\n    e = e.NextInAEL;\n    //ie get ready to calc WindCnt2\n  }\n  //update WindCnt2 ...\n  if (this.IsEvenOddAltFillType(edge)) {\n    //EvenOdd filling ...\n    while (e !== edge) {\n      if (e.WindDelta !== 0)\n        edge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);\n      e = e.NextInAEL;\n    }\n  } else {\n    //nonZero, Positive or Negative filling ...\n    while (e !== edge) {\n      edge.WindCnt2 += e.WindDelta;\n      e = e.NextInAEL;\n    }\n  }\n};\n\nClipperLib.Clipper.prototype.AddEdgeToSEL = function(edge) {\n  //SEL pointers in PEdge are use to build transient lists of horizontal edges.\n  //However, since we don't need to worry about processing order, all additions\n  //are made to the front of the list ...\n  if (this.m_SortedEdges === null) {\n    this.m_SortedEdges = edge;\n    edge.PrevInSEL = null;\n    edge.NextInSEL = null;\n  } else {\n    edge.NextInSEL = this.m_SortedEdges;\n    edge.PrevInSEL = null;\n    this.m_SortedEdges.PrevInSEL = edge;\n    this.m_SortedEdges = edge;\n  }\n};\n\nClipperLib.Clipper.prototype.PopEdgeFromSEL = function(e) {\n  //Pop edge from front of SEL (ie SEL is a FILO list)\n  e.v = this.m_SortedEdges;\n  if (e.v === null) {\n    return false;\n  }\n  var oldE = e.v;\n  this.m_SortedEdges = e.v.NextInSEL;\n  if (this.m_SortedEdges !== null) {\n    this.m_SortedEdges.PrevInSEL = null;\n  }\n  oldE.NextInSEL = null;\n  oldE.PrevInSEL = null;\n  return true;\n};\n\nClipperLib.Clipper.prototype.CopyAELToSEL = function() {\n  var e = this.m_ActiveEdges;\n  this.m_SortedEdges = e;\n  while (e !== null) {\n    e.PrevInSEL = e.PrevInAEL;\n    e.NextInSEL = e.NextInAEL;\n    e = e.NextInAEL;\n  }\n};\n\nClipperLib.Clipper.prototype.SwapPositionsInSEL = function(edge1, edge2) {\n  if (edge1.NextInSEL === null && edge1.PrevInSEL === null)\n    return;\n  if (edge2.NextInSEL === null && edge2.PrevInSEL === null)\n    return;\n  if (edge1.NextInSEL === edge2) {\n    var next = edge2.NextInSEL;\n    if (next !== null)\n      next.PrevInSEL = edge1;\n    var prev = edge1.PrevInSEL;\n    if (prev !== null)\n      prev.NextInSEL = edge2;\n    edge2.PrevInSEL = prev;\n    edge2.NextInSEL = edge1;\n    edge1.PrevInSEL = edge2;\n    edge1.NextInSEL = next;\n  } else if (edge2.NextInSEL === edge1) {\n    var next = edge1.NextInSEL;\n    if (next !== null)\n      next.PrevInSEL = edge2;\n    var prev = edge2.PrevInSEL;\n    if (prev !== null)\n      prev.NextInSEL = edge1;\n    edge1.PrevInSEL = prev;\n    edge1.NextInSEL = edge2;\n    edge2.PrevInSEL = edge1;\n    edge2.NextInSEL = next;\n  } else {\n    var next = edge1.NextInSEL;\n    var prev = edge1.PrevInSEL;\n    edge1.NextInSEL = edge2.NextInSEL;\n    if (edge1.NextInSEL !== null)\n      edge1.NextInSEL.PrevInSEL = edge1;\n    edge1.PrevInSEL = edge2.PrevInSEL;\n    if (edge1.PrevInSEL !== null)\n      edge1.PrevInSEL.NextInSEL = edge1;\n    edge2.NextInSEL = next;\n    if (edge2.NextInSEL !== null)\n      edge2.NextInSEL.PrevInSEL = edge2;\n    edge2.PrevInSEL = prev;\n    if (edge2.PrevInSEL !== null)\n      edge2.PrevInSEL.NextInSEL = edge2;\n  }\n  if (edge1.PrevInSEL === null)\n    this.m_SortedEdges = edge1;\n  else if (edge2.PrevInSEL === null)\n    this.m_SortedEdges = edge2;\n};\n\nClipperLib.Clipper.prototype.AddLocalMaxPoly = function(e1, e2, pt) {\n  this.AddOutPt(e1, pt);\n  if (e2.WindDelta === 0) this.AddOutPt(e2, pt);\n  if (e1.OutIdx === e2.OutIdx) {\n    e1.OutIdx = -1;\n    e2.OutIdx = -1;\n  } else if (e1.OutIdx < e2.OutIdx)\n    this.AppendPolygon(e1, e2);\n  else\n    this.AppendPolygon(e2, e1);\n};\n\nClipperLib.Clipper.prototype.AddLocalMinPoly = function(e1, e2, pt) {\n  var result;\n  var e, prevE;\n  if (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx)) {\n    result = this.AddOutPt(e1, pt);\n    e2.OutIdx = e1.OutIdx;\n    e1.Side = ClipperLib.EdgeSide.esLeft;\n    e2.Side = ClipperLib.EdgeSide.esRight;\n    e = e1;\n    if (e.PrevInAEL === e2)\n      prevE = e2.PrevInAEL;\n    else\n      prevE = e.PrevInAEL;\n  } else {\n    result = this.AddOutPt(e2, pt);\n    e1.OutIdx = e2.OutIdx;\n    e1.Side = ClipperLib.EdgeSide.esRight;\n    e2.Side = ClipperLib.EdgeSide.esLeft;\n    e = e2;\n    if (e.PrevInAEL === e1)\n      prevE = e1.PrevInAEL;\n    else\n      prevE = e.PrevInAEL;\n  }\n\n  if (prevE !== null && prevE.OutIdx >= 0 && prevE.Top.y < pt.y && e.Top.y < pt.y) {\n    var xPrev = ClipperLib.Clipper.TopX(prevE, pt.y);\n    var xE = ClipperLib.Clipper.TopX(e, pt.y);\n    if ((xPrev === xE) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0) && ClipperLib.ClipperBase.SlopesEqual5(new ClipperLib.FPoint2(xPrev, pt.y), prevE.Top, new ClipperLib.FPoint2(xE, pt.y), e.Top)) {\n      var outPt = this.AddOutPt(prevE, pt);\n      this.AddJoin(result, outPt, e.Top);\n    }\n  }\n  return result;\n};\n\nClipperLib.Clipper.prototype.AddOutPt = function(e, pt) {\n  if (e.OutIdx < 0) {\n    var outRec = this.CreateOutRec();\n    outRec.IsOpen = (e.WindDelta === 0);\n    var newOp = new ClipperLib.OutPt();\n    outRec.Pts = newOp;\n    newOp.Idx = outRec.Idx;\n    //newOp.Pt = pt;\n    newOp.Pt.x = pt.x;\n    newOp.Pt.y = pt.y;\n    newOp.Next = newOp;\n    newOp.Prev = newOp;\n    if (!outRec.IsOpen)\n      this.SetHoleState(e, outRec);\n    e.OutIdx = outRec.Idx;\n    //nb: do this after SetZ !\n    return newOp;\n  } else {\n    var outRec = this.m_PolyOuts[e.OutIdx];\n    //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\n    var op = outRec.Pts;\n    var ToFront = (e.Side === ClipperLib.EdgeSide.esLeft);\n    if (ToFront && ClipperLib.FPoint.op_Equality(pt, op.Pt))\n      return op;\n    else if (!ToFront && ClipperLib.FPoint.op_Equality(pt, op.Prev.Pt))\n      return op.Prev;\n    var newOp = new ClipperLib.OutPt();\n    newOp.Idx = outRec.Idx;\n    //newOp.Pt = pt;\n    newOp.Pt.x = pt.x;\n    newOp.Pt.y = pt.y;\n    newOp.Next = op;\n    newOp.Prev = op.Prev;\n    newOp.Prev.Next = newOp;\n    op.Prev = newOp;\n    if (ToFront)\n      outRec.Pts = newOp;\n    return newOp;\n  }\n};\n\nClipperLib.Clipper.prototype.GetLastOutPt = function(e) {\n  var outRec = this.m_PolyOuts[e.OutIdx];\n  if (e.Side === ClipperLib.EdgeSide.esLeft) {\n    return outRec.Pts;\n  } else {\n    return outRec.Pts.Prev;\n  }\n};\n\nClipperLib.Clipper.prototype.SwapPoints = function(pt1, pt2) {\n  var tmp = new ClipperLib.FPoint1(pt1.Value);\n  //pt1.Value = pt2.Value;\n  pt1.Value.x = pt2.Value.x;\n  pt1.Value.y = pt2.Value.y;\n  //pt2.Value = tmp;\n  pt2.Value.x = tmp.x;\n  pt2.Value.y = tmp.y;\n};\n\nClipperLib.Clipper.prototype.HorzSegmentsOverlap = function(seg1a, seg1b, seg2a, seg2b) {\n  var tmp;\n  if (seg1a > seg1b) {\n    tmp = seg1a;\n    seg1a = seg1b;\n    seg1b = tmp;\n  }\n  if (seg2a > seg2b) {\n    tmp = seg2a;\n    seg2a = seg2b;\n    seg2b = tmp;\n  }\n  return (seg1a < seg2b) && (seg2a < seg1b);\n}\n\nClipperLib.Clipper.prototype.SetHoleState = function(e, outRec) {\n  var e2 = e.PrevInAEL;\n  var eTmp = null;\n  while (e2 !== null) {\n    if (e2.OutIdx >= 0 && e2.WindDelta !== 0) {\n      if (eTmp === null)\n        eTmp = e2;\n      else if (eTmp.OutIdx === e2.OutIdx)\n        eTmp = null; //paired\n    }\n    e2 = e2.PrevInAEL;\n  }\n\n  if (eTmp === null) {\n    outRec.FirstLeft = null;\n    outRec.IsHole = false;\n  } else {\n    outRec.FirstLeft = this.m_PolyOuts[eTmp.OutIdx];\n    outRec.IsHole = !outRec.FirstLeft.IsHole;\n  }\n};\n\nClipperLib.Clipper.prototype.GetDx = function(pt1, pt2) {\n  if (pt1.y === pt2.y)\n    return ClipperLib.ClipperBase.horizontal;\n  else\n    return (pt2.x - pt1.x) / (pt2.y - pt1.y);\n};\n\nClipperLib.Clipper.prototype.FirstIsBottomPt = function(btmPt1, btmPt2) {\n  var p = btmPt1.Prev;\n  while ((ClipperLib.FPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p !== btmPt1))\n    p = p.Prev;\n  var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n  p = btmPt1.Next;\n  while ((ClipperLib.FPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p !== btmPt1))\n    p = p.Next;\n  var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n  p = btmPt2.Prev;\n  while ((ClipperLib.FPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p !== btmPt2))\n    p = p.Prev;\n  var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n  p = btmPt2.Next;\n  while ((ClipperLib.FPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p !== btmPt2))\n    p = p.Next;\n  var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n\n  if (Math.max(dx1p, dx1n) === Math.max(dx2p, dx2n) && Math.min(dx1p, dx1n) === Math.min(dx2p, dx2n)) {\n    return this.Area(btmPt1) > 0; //if otherwise identical use orientation\n  } else {\n    return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);\n  }\n};\n\nClipperLib.Clipper.prototype.GetBottomPt = function(pp) {\n  var dups = null;\n  var p = pp.Next;\n  while (p !== pp) {\n    if (p.Pt.y > pp.Pt.y) {\n      pp = p;\n      dups = null;\n    } else if (p.Pt.y === pp.Pt.y && p.Pt.x <= pp.Pt.x) {\n      if (p.Pt.x < pp.Pt.x) {\n        dups = null;\n        pp = p;\n      } else {\n        if (p.Next !== pp && p.Prev !== pp)\n          dups = p;\n      }\n    }\n    p = p.Next;\n  }\n  if (dups !== null) {\n    //there appears to be at least 2 vertices at bottomPt so ...\n    while (dups !== p) {\n      if (!this.FirstIsBottomPt(p, dups))\n        pp = dups;\n      dups = dups.Next;\n      while (ClipperLib.FPoint.op_Inequality(dups.Pt, pp.Pt))\n        dups = dups.Next;\n    }\n  }\n  return pp;\n};\n\nClipperLib.Clipper.prototype.GetLowermostRec = function(outRec1, outRec2) {\n  //work out which polygon fragment has the correct hole state ...\n  if (outRec1.BottomPt === null)\n    outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);\n  if (outRec2.BottomPt === null)\n    outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);\n  var bPt1 = outRec1.BottomPt;\n  var bPt2 = outRec2.BottomPt;\n  if (bPt1.Pt.y > bPt2.Pt.y)\n    return outRec1;\n  else if (bPt1.Pt.y < bPt2.Pt.y)\n    return outRec2;\n  else if (bPt1.Pt.x < bPt2.Pt.x)\n    return outRec1;\n  else if (bPt1.Pt.x > bPt2.Pt.x)\n    return outRec2;\n  else if (bPt1.Next === bPt1)\n    return outRec2;\n  else if (bPt2.Next === bPt2)\n    return outRec1;\n  else if (this.FirstIsBottomPt(bPt1, bPt2))\n    return outRec1;\n  else\n    return outRec2;\n};\n\nClipperLib.Clipper.prototype.OutRec1RightOfOutRec2 = function(outRec1, outRec2) {\n  do {\n    outRec1 = outRec1.FirstLeft;\n    if (outRec1 === outRec2)\n      return true;\n  }\n  while (outRec1 !== null)\n  return false;\n};\n\nClipperLib.Clipper.prototype.GetOutRec = function(idx) {\n  var outrec = this.m_PolyOuts[idx];\n  while (outrec !== this.m_PolyOuts[outrec.Idx])\n    outrec = this.m_PolyOuts[outrec.Idx];\n  return outrec;\n};\n\nClipperLib.Clipper.prototype.AppendPolygon = function(e1, e2) {\n  //get the start and ends of both output polygons ...\n  var outRec1 = this.m_PolyOuts[e1.OutIdx];\n  var outRec2 = this.m_PolyOuts[e2.OutIdx];\n  var holeStateRec;\n  if (this.OutRec1RightOfOutRec2(outRec1, outRec2))\n    holeStateRec = outRec2;\n  else if (this.OutRec1RightOfOutRec2(outRec2, outRec1))\n    holeStateRec = outRec1;\n  else\n    holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\n  //get the start and ends of both output polygons and\n  //join E2 poly onto E1 poly and delete pointers to E2 ...\n\n  var p1_lft = outRec1.Pts;\n  var p1_rt = p1_lft.Prev;\n  var p2_lft = outRec2.Pts;\n  var p2_rt = p2_lft.Prev;\n  //join e2 poly onto e1 poly and delete pointers to e2 ...\n  if (e1.Side === ClipperLib.EdgeSide.esLeft) {\n    if (e2.Side === ClipperLib.EdgeSide.esLeft) {\n      //z y x a b c\n      this.ReversePolyPtLinks(p2_lft);\n      p2_lft.Next = p1_lft;\n      p1_lft.Prev = p2_lft;\n      p1_rt.Next = p2_rt;\n      p2_rt.Prev = p1_rt;\n      outRec1.Pts = p2_rt;\n    } else {\n      //x y z a b c\n      p2_rt.Next = p1_lft;\n      p1_lft.Prev = p2_rt;\n      p2_lft.Prev = p1_rt;\n      p1_rt.Next = p2_lft;\n      outRec1.Pts = p2_lft;\n    }\n  } else {\n    if (e2.Side === ClipperLib.EdgeSide.esRight) {\n      //a b c z y x\n      this.ReversePolyPtLinks(p2_lft);\n      p1_rt.Next = p2_rt;\n      p2_rt.Prev = p1_rt;\n      p2_lft.Next = p1_lft;\n      p1_lft.Prev = p2_lft;\n    } else {\n      //a b c x y z\n      p1_rt.Next = p2_lft;\n      p2_lft.Prev = p1_rt;\n      p1_lft.Prev = p2_rt;\n      p2_rt.Next = p1_lft;\n    }\n  }\n  outRec1.BottomPt = null;\n  if (holeStateRec === outRec2) {\n    if (outRec2.FirstLeft !== outRec1)\n      outRec1.FirstLeft = outRec2.FirstLeft;\n    outRec1.IsHole = outRec2.IsHole;\n  }\n  outRec2.Pts = null;\n  outRec2.BottomPt = null;\n  outRec2.FirstLeft = outRec1;\n  var OKIdx = e1.OutIdx;\n  var ObsoleteIdx = e2.OutIdx;\n  e1.OutIdx = -1;\n  //nb: safe because we only get here via AddLocalMaxPoly\n  e2.OutIdx = -1;\n  var e = this.m_ActiveEdges;\n  while (e !== null) {\n    if (e.OutIdx === ObsoleteIdx) {\n      e.OutIdx = OKIdx;\n      e.Side = e1.Side;\n      break;\n    }\n    e = e.NextInAEL;\n  }\n  outRec2.Idx = outRec1.Idx;\n};\n\nClipperLib.Clipper.prototype.ReversePolyPtLinks = function(pp) {\n  if (pp === null)\n    return;\n  var pp1;\n  var pp2;\n  pp1 = pp;\n  do {\n    pp2 = pp1.Next;\n    pp1.Next = pp1.Prev;\n    pp1.Prev = pp2;\n    pp1 = pp2;\n  }\n  while (pp1 !== pp)\n};\n\nClipperLib.Clipper.SwapSides = function(edge1, edge2) {\n  var side = edge1.Side;\n  edge1.Side = edge2.Side;\n  edge2.Side = side;\n};\n\nClipperLib.Clipper.SwapPolyIndexes = function(edge1, edge2) {\n  var outIdx = edge1.OutIdx;\n  edge1.OutIdx = edge2.OutIdx;\n  edge2.OutIdx = outIdx;\n};\n\nClipperLib.Clipper.prototype.IntersectEdges = function(e1, e2, pt) {\n  //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before\n  //e2 in AEL except when e1 is being inserted at the intersection point ...\n  var e1Contributing = (e1.OutIdx >= 0);\n  var e2Contributing = (e2.OutIdx >= 0);\n\n  //update winding counts...\n  //assumes that e1 will be to the Right of e2 ABOVE the intersection\n  if (e1.PolyTyp === e2.PolyTyp) {\n    if (this.IsEvenOddFillType(e1)) {\n      var oldE1WindCnt = e1.WindCnt;\n      e1.WindCnt = e2.WindCnt;\n      e2.WindCnt = oldE1WindCnt;\n    } else {\n      if (e1.WindCnt + e2.WindDelta === 0)\n        e1.WindCnt = -e1.WindCnt;\n      else\n        e1.WindCnt += e2.WindDelta;\n      if (e2.WindCnt - e1.WindDelta === 0)\n        e2.WindCnt = -e2.WindCnt;\n      else\n        e2.WindCnt -= e1.WindDelta;\n    }\n  } else {\n    if (!this.IsEvenOddFillType(e2))\n      e1.WindCnt2 += e2.WindDelta;\n    else\n      e1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;\n    if (!this.IsEvenOddFillType(e1))\n      e2.WindCnt2 -= e1.WindDelta;\n    else\n      e2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;\n  }\n  var e1FillType, e2FillType, e1FillType2, e2FillType2;\n  if (e1.PolyTyp === ClipperLib.PolyType.ptSubject) {\n    e1FillType = this.m_SubjFillType;\n    e1FillType2 = this.m_ClipFillType;\n  } else {\n    e1FillType = this.m_ClipFillType;\n    e1FillType2 = this.m_SubjFillType;\n  }\n  if (e2.PolyTyp === ClipperLib.PolyType.ptSubject) {\n    e2FillType = this.m_SubjFillType;\n    e2FillType2 = this.m_ClipFillType;\n  } else {\n    e2FillType = this.m_ClipFillType;\n    e2FillType2 = this.m_SubjFillType;\n  }\n  var e1Wc, e2Wc;\n  switch (e1FillType) {\n    case ClipperLib.PolyFillType.pftPositive:\n      e1Wc = e1.WindCnt;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e1Wc = -e1.WindCnt;\n      break;\n    default:\n      e1Wc = Math.abs(e1.WindCnt);\n      break;\n  }\n  switch (e2FillType) {\n    case ClipperLib.PolyFillType.pftPositive:\n      e2Wc = e2.WindCnt;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e2Wc = -e2.WindCnt;\n      break;\n    default:\n      e2Wc = Math.abs(e2.WindCnt);\n      break;\n  }\n  if (e1Contributing && e2Contributing) {\n    if ((e1Wc !== 0 && e1Wc !== 1) || (e2Wc !== 0 && e2Wc !== 1) ||\n      (e1.PolyTyp !== e2.PolyTyp && this.m_ClipType !== ClipperLib.ClipType.ctXor)) {\n      this.AddLocalMaxPoly(e1, e2, pt);\n    } else {\n      this.AddOutPt(e1, pt);\n      this.AddOutPt(e2, pt);\n      ClipperLib.Clipper.SwapSides(e1, e2);\n      ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n    }\n  } else if (e1Contributing) {\n    if (e2Wc === 0 || e2Wc === 1) {\n      this.AddOutPt(e1, pt);\n      ClipperLib.Clipper.SwapSides(e1, e2);\n      ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n    }\n  } else if (e2Contributing) {\n    if (e1Wc === 0 || e1Wc === 1) {\n      this.AddOutPt(e2, pt);\n      ClipperLib.Clipper.SwapSides(e1, e2);\n      ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n    }\n  } else if ((e1Wc === 0 || e1Wc === 1) && (e2Wc === 0 || e2Wc === 1)) {\n    //neither edge is currently contributing ...\n    var e1Wc2, e2Wc2;\n    switch (e1FillType2) {\n      case ClipperLib.PolyFillType.pftPositive:\n        e1Wc2 = e1.WindCnt2;\n        break;\n      case ClipperLib.PolyFillType.pftNegative:\n        e1Wc2 = -e1.WindCnt2;\n        break;\n      default:\n        e1Wc2 = Math.abs(e1.WindCnt2);\n        break;\n    }\n    switch (e2FillType2) {\n      case ClipperLib.PolyFillType.pftPositive:\n        e2Wc2 = e2.WindCnt2;\n        break;\n      case ClipperLib.PolyFillType.pftNegative:\n        e2Wc2 = -e2.WindCnt2;\n        break;\n      default:\n        e2Wc2 = Math.abs(e2.WindCnt2);\n        break;\n    }\n    if (e1.PolyTyp !== e2.PolyTyp) {\n      this.AddLocalMinPoly(e1, e2, pt);\n    } else if (e1Wc === 1 && e2Wc === 1)\n      switch (this.m_ClipType) {\n        case ClipperLib.ClipType.ctIntersection:\n          if (e1Wc2 > 0 && e2Wc2 > 0)\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctUnion:\n          if (e1Wc2 <= 0 && e2Wc2 <= 0)\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctDifference:\n          if (((e1.PolyTyp === ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\n            ((e1.PolyTyp === ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctXor:\n          this.AddLocalMinPoly(e1, e2, pt);\n          break;\n      }\n    else\n      ClipperLib.Clipper.SwapSides(e1, e2);\n  }\n};\n\nClipperLib.Clipper.prototype.DeleteFromSEL = function(e) {\n  var SelPrev = e.PrevInSEL;\n  var SelNext = e.NextInSEL;\n  if (SelPrev === null && SelNext === null && (e !== this.m_SortedEdges))\n    return;\n  //already deleted\n  if (SelPrev !== null)\n    SelPrev.NextInSEL = SelNext;\n  else\n    this.m_SortedEdges = SelNext;\n  if (SelNext !== null)\n    SelNext.PrevInSEL = SelPrev;\n  e.NextInSEL = null;\n  e.PrevInSEL = null;\n};\n\nClipperLib.Clipper.prototype.ProcessHorizontals = function() {\n  var horzEdge = {}; //m_SortedEdges;\n  while (this.PopEdgeFromSEL(horzEdge)) {\n    this.ProcessHorizontal(horzEdge.v);\n  }\n};\n\nClipperLib.Clipper.prototype.GetHorzDirection = function(HorzEdge, $var) {\n  if (HorzEdge.Bot.x < HorzEdge.Top.x) {\n    $var.Left = HorzEdge.Bot.x;\n    $var.Right = HorzEdge.Top.x;\n    $var.Dir = ClipperLib.Direction.dLeftToRight;\n  } else {\n    $var.Left = HorzEdge.Top.x;\n    $var.Right = HorzEdge.Bot.x;\n    $var.Dir = ClipperLib.Direction.dRightToLeft;\n  }\n};\n\nClipperLib.Clipper.prototype.ProcessHorizontal = function(horzEdge) {\n  var $var = {\n    Dir: null,\n    Left: null,\n    Right: null\n  };\n\n  this.GetHorzDirection(horzEdge, $var);\n  var dir = $var.Dir;\n  var horzLeft = $var.Left;\n  var horzRight = $var.Right;\n\n  var IsOpen = horzEdge.WindDelta === 0;\n\n  var eLastHorz = horzEdge,\n    eMaxPair = null;\n  while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))\n    eLastHorz = eLastHorz.NextInLML;\n  if (eLastHorz.NextInLML === null)\n    eMaxPair = this.GetMaximaPair(eLastHorz);\n\n  var currMax = this.m_Maxima;\n  if (currMax !== null) {\n    //get the first maxima in range (X) ...\n    if (dir === ClipperLib.Direction.dLeftToRight) {\n      while (currMax !== null && currMax.x <= horzEdge.Bot.x) {\n        currMax = currMax.Next;\n      }\n      if (currMax !== null && currMax.x >= eLastHorz.Top.x) {\n        currMax = null;\n      }\n    } else {\n      while (currMax.Next !== null && currMax.Next.x < horzEdge.Bot.x) {\n        currMax = currMax.Next;\n      }\n      if (currMax.x <= eLastHorz.Top.x) {\n        currMax = null;\n      }\n    }\n  }\n  var op1 = null;\n  for (;;) //loop through consec. horizontal edges\n  {\n    var IsLastHorz = (horzEdge === eLastHorz);\n    var e = this.GetNextInAEL(horzEdge, dir);\n    while (e !== null) {\n      //this code block inserts extra coords into horizontal edges (in output\n      //polygons) whereever maxima touch these horizontal edges. This helps\n      //'simplifying' polygons (ie if the Simplify property is set).\n      if (currMax !== null) {\n        if (dir === ClipperLib.Direction.dLeftToRight) {\n          while (currMax !== null && currMax.x < e.Curr.x) {\n            if (horzEdge.OutIdx >= 0 && !IsOpen) {\n              this.AddOutPt(horzEdge, new ClipperLib.FPoint2(currMax.x, horzEdge.Bot.y));\n            }\n            currMax = currMax.Next;\n          }\n        } else {\n          while (currMax !== null && currMax.x > e.Curr.x) {\n            if (horzEdge.OutIdx >= 0 && !IsOpen) {\n              this.AddOutPt(horzEdge, new ClipperLib.FPoint2(currMax.x, horzEdge.Bot.y));\n            }\n            currMax = currMax.Prev;\n          }\n        }\n      }\n\n      if ((dir === ClipperLib.Direction.dLeftToRight && e.Curr.x > horzRight) || (dir === ClipperLib.Direction.dRightToLeft && e.Curr.x < horzLeft)) {\n        break;\n      }\n\n      //Also break if we've got to the end of an intermediate horizontal edge ...\n      //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\n      if (e.Curr.x === horzEdge.Top.x && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)\n        break;\n\n      if (horzEdge.OutIdx >= 0 && !IsOpen) //note: may be done multiple times\n      {\n        op1 = this.AddOutPt(horzEdge, e.Curr);\n        var eNextHorz = this.m_SortedEdges;\n        while (eNextHorz !== null) {\n          if (eNextHorz.OutIdx >= 0 && this.HorzSegmentsOverlap(horzEdge.Bot.x, horzEdge.Top.x, eNextHorz.Bot.x, eNextHorz.Top.x)) {\n            var op2 = this.GetLastOutPt(eNextHorz);\n            this.AddJoin(op2, op1, eNextHorz.Top);\n          }\n          eNextHorz = eNextHorz.NextInSEL;\n        }\n        this.AddGhostJoin(op1, horzEdge.Bot);\n      }\n\n      //OK, so far we're still in range of the horizontal Edge  but make sure\n      //we're at the last of consec. horizontals when matching with eMaxPair\n      if (e === eMaxPair && IsLastHorz) {\n        if (horzEdge.OutIdx >= 0) {\n          this.AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.Top);\n        }\n        this.DeleteFromAEL(horzEdge);\n        this.DeleteFromAEL(eMaxPair);\n        return;\n      }\n\n      if (dir === ClipperLib.Direction.dLeftToRight) {\n        var Pt = new ClipperLib.FPoint2(e.Curr.x, horzEdge.Curr.y);\n        this.IntersectEdges(horzEdge, e, Pt);\n      } else {\n        var Pt = new ClipperLib.FPoint2(e.Curr.x, horzEdge.Curr.y);\n        this.IntersectEdges(e, horzEdge, Pt);\n      }\n      var eNext = this.GetNextInAEL(e, dir);\n      this.SwapPositionsInAEL(horzEdge, e);\n      e = eNext;\n    } //end while(e !== null)\n\n    //Break out of loop if HorzEdge.NextInLML is not also horizontal ...\n    if (horzEdge.NextInLML === null || !ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML)) {\n      break;\n    }\n\n    horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n    if (horzEdge.OutIdx >= 0) {\n      this.AddOutPt(horzEdge, horzEdge.Bot);\n    }\n\n    $var = {\n      Dir: dir,\n      Left: horzLeft,\n      Right: horzRight\n    };\n\n    this.GetHorzDirection(horzEdge, $var);\n    dir = $var.Dir;\n    horzLeft = $var.Left;\n    horzRight = $var.Right;\n\n  } //end for (;;)\n\n  if (horzEdge.OutIdx >= 0 && op1 === null) {\n    op1 = this.GetLastOutPt(horzEdge);\n    var eNextHorz = this.m_SortedEdges;\n    while (eNextHorz !== null) {\n      if (eNextHorz.OutIdx >= 0 && this.HorzSegmentsOverlap(horzEdge.Bot.x, horzEdge.Top.x, eNextHorz.Bot.x, eNextHorz.Top.x)) {\n        var op2 = this.GetLastOutPt(eNextHorz);\n        this.AddJoin(op2, op1, eNextHorz.Top);\n      }\n      eNextHorz = eNextHorz.NextInSEL;\n    }\n    this.AddGhostJoin(op1, horzEdge.Top);\n  }\n\n  if (horzEdge.NextInLML !== null) {\n    if (horzEdge.OutIdx >= 0) {\n      op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\n      horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n      if (horzEdge.WindDelta === 0) {\n        return;\n      }\n      //nb: HorzEdge is no longer horizontal here\n      var ePrev = horzEdge.PrevInAEL;\n      var eNext = horzEdge.NextInAEL;\n      if (ePrev !== null && ePrev.Curr.x === horzEdge.Bot.x && ePrev.Curr.y === horzEdge.Bot.y && ePrev.WindDelta === 0 && (ePrev.OutIdx >= 0 && ePrev.Curr.y > ePrev.Top.y && ClipperLib.ClipperBase.SlopesEqual3(horzEdge, ePrev))) {\n        var op2 = this.AddOutPt(ePrev, horzEdge.Bot);\n        this.AddJoin(op1, op2, horzEdge.Top);\n      } else if (eNext !== null && eNext.Curr.x === horzEdge.Bot.x && eNext.Curr.y === horzEdge.Bot.y && eNext.WindDelta !== 0 && eNext.OutIdx >= 0 && eNext.Curr.y > eNext.Top.y && ClipperLib.ClipperBase.SlopesEqual3(horzEdge, eNext)) {\n        var op2 = this.AddOutPt(eNext, horzEdge.Bot);\n        this.AddJoin(op1, op2, horzEdge.Top);\n      }\n    } else {\n      horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n    }\n  } else {\n    if (horzEdge.OutIdx >= 0) {\n      this.AddOutPt(horzEdge, horzEdge.Top);\n    }\n    this.DeleteFromAEL(horzEdge);\n  }\n};\n\nClipperLib.Clipper.prototype.GetNextInAEL = function(e, Direction) {\n  return Direction === ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;\n};\n\nClipperLib.Clipper.prototype.IsMinima = function(e) {\n  return e !== null && (e.Prev.NextInLML !== e) && (e.Next.NextInLML !== e);\n};\n\nClipperLib.Clipper.prototype.IsMaxima = function(e, Y) {\n  return (e !== null && e.Top.y === Y && e.NextInLML === null);\n};\n\nClipperLib.Clipper.prototype.IsIntermediate = function(e, Y) {\n  return (e.Top.y === Y && e.NextInLML !== null);\n};\n\nClipperLib.Clipper.prototype.GetMaximaPair = function(e) {\n  if ((ClipperLib.FPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null) {\n    return e.Next;\n  } else {\n    if ((ClipperLib.FPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null) {\n      return e.Prev;\n    } else {\n      return null;\n    }\n  }\n};\n\nClipperLib.Clipper.prototype.GetMaximaPairEx = function(e) {\n  //as above but returns null if MaxPair isn't in AEL (unless it's horizontal)\n  var result = this.GetMaximaPair(e);\n  if (result === null || result.OutIdx === ClipperLib.ClipperBase.Skip ||\n    ((result.NextInAEL === result.PrevInAEL) && !ClipperLib.ClipperBase.IsHorizontal(result))) {\n    return null;\n  }\n  return result;\n};\n\nClipperLib.Clipper.prototype.ProcessIntersections = function(topY) {\n  if (this.m_ActiveEdges === null)\n    return true;\n  try {\n    this.BuildIntersectList(topY);\n    if (this.m_IntersectList.length === 0)\n      return true;\n    if (this.m_IntersectList.length === 1 || this.FixupIntersectionOrder())\n      this.ProcessIntersectList();\n    else\n      return false;\n  } catch ($$e2) {\n    this.m_SortedEdges = null;\n    this.m_IntersectList.length = 0;\n    ClipperLib.Error(\"ProcessIntersections error\");\n  }\n  this.m_SortedEdges = null;\n  return true;\n};\n\nClipperLib.Clipper.prototype.BuildIntersectList = function(topY) {\n  if (this.m_ActiveEdges === null)\n    return;\n  //prepare for sorting ...\n  var e = this.m_ActiveEdges;\n  //console.log(JSON.stringify(JSON.decycle( e )));\n  this.m_SortedEdges = e;\n  while (e !== null) {\n    e.PrevInSEL = e.PrevInAEL;\n    e.NextInSEL = e.NextInAEL;\n    e.Curr.x = ClipperLib.Clipper.TopX(e, topY);\n    e = e.NextInAEL;\n  }\n  //bubblesort ...\n  var isModified = true;\n  while (isModified && this.m_SortedEdges !== null) {\n    isModified = false;\n    e = this.m_SortedEdges;\n    while (e.NextInSEL !== null) {\n      var eNext = e.NextInSEL;\n      var pt = new ClipperLib.FPoint0();\n      //console.log(\"e.Curr.x: \" + e.Curr.x + \" eNext.Curr.x\" + eNext.Curr.x);\n      if (e.Curr.x > eNext.Curr.x) {\n        this.IntersectPoint(e, eNext, pt);\n        if (pt.y < topY) {\n          pt = new ClipperLib.FPoint2(ClipperLib.Clipper.TopX(e, topY), topY);\n        }\n        var newNode = new ClipperLib.IntersectNode();\n        newNode.Edge1 = e;\n        newNode.Edge2 = eNext;\n        //newNode.Pt = pt;\n        newNode.Pt.x = pt.x;\n        newNode.Pt.y = pt.y;\n        this.m_IntersectList.push(newNode);\n        this.SwapPositionsInSEL(e, eNext);\n        isModified = true;\n      } else\n        e = eNext;\n    }\n    if (e.PrevInSEL !== null)\n      e.PrevInSEL.NextInSEL = null;\n    else\n      break;\n  }\n  this.m_SortedEdges = null;\n};\n\nClipperLib.Clipper.prototype.EdgesAdjacent = function(inode) {\n  return (inode.Edge1.NextInSEL === inode.Edge2) || (inode.Edge1.PrevInSEL === inode.Edge2);\n};\n\nClipperLib.Clipper.IntersectNodeSort = function(node1, node2) {\n  //the following typecast is safe because the differences in Pt.y will\n  //be limited to the height of the scanbeam.\n  return (node2.Pt.y - node1.Pt.y);\n};\n\nClipperLib.Clipper.prototype.FixupIntersectionOrder = function() {\n  //pre-condition: intersections are sorted bottom-most first.\n  //Now it's crucial that intersections are made only between adjacent edges,\n  //so to ensure this the order of intersections may need adjusting ...\n  this.m_IntersectList.sort(this.m_IntersectNodeComparer);\n  this.CopyAELToSEL();\n  var cnt = this.m_IntersectList.length;\n  for (var i = 0; i < cnt; i++) {\n    if (!this.EdgesAdjacent(this.m_IntersectList[i])) {\n      var j = i + 1;\n      while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))\n        j++;\n      if (j === cnt)\n        return false;\n      var tmp = this.m_IntersectList[i];\n      this.m_IntersectList[i] = this.m_IntersectList[j];\n      this.m_IntersectList[j] = tmp;\n    }\n    this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);\n  }\n  return true;\n};\n\nClipperLib.Clipper.prototype.ProcessIntersectList = function() {\n  for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++) {\n    var iNode = this.m_IntersectList[i];\n    this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt);\n    this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);\n  }\n  this.m_IntersectList.length = 0;\n};\n\nClipperLib.Clipper.TopX = function(edge, currentY) {\n  //if (edge.Bot == edge.Curr) alert (\"edge.Bot = edge.Curr\");\n  //if (edge.Bot == edge.Top) alert (\"edge.Bot = edge.Top\");\n  if (currentY === edge.Top.y)\n    return edge.Top.x;\n  return edge.Bot.x + edge.Dx * (currentY - edge.Bot.y);\n};\n\nClipperLib.Clipper.prototype.IntersectPoint = function(edge1, edge2, ip) {\n  ip.x = 0;\n  ip.y = 0;\n  var b1, b2;\n  //nb: with very large coordinate values, it's possible for SlopesEqual() to\n  //return false but for the edge.Dx value be equal due to double precision rounding.\n  if (edge1.Dx === edge2.Dx) {\n    ip.y = edge1.Curr.y;\n    ip.x = ClipperLib.Clipper.TopX(edge1, ip.y);\n    return;\n  }\n  if (edge1.Delta.x === 0) {\n    ip.x = edge1.Bot.x;\n    if (ClipperLib.ClipperBase.IsHorizontal(edge2)) {\n      ip.y = edge2.Bot.y;\n    } else {\n      b2 = edge2.Bot.y - (edge2.Bot.x / edge2.Dx);\n      ip.y = ip.x / edge2.Dx + b2;\n    }\n  } else if (edge2.Delta.x === 0) {\n    ip.x = edge2.Bot.x;\n    if (ClipperLib.ClipperBase.IsHorizontal(edge1)) {\n      ip.y = edge1.Bot.y;\n    } else {\n      b1 = edge1.Bot.y - (edge1.Bot.x / edge1.Dx);\n      ip.y = ip.x / edge1.Dx + b1;\n    }\n  } else {\n    b1 = edge1.Bot.x - edge1.Bot.y * edge1.Dx;\n    b2 = edge2.Bot.x - edge2.Bot.y * edge2.Dx;\n    var q = (b2 - b1) / (edge1.Dx - edge2.Dx);\n    ip.y = q;\n    if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n      ip.x = edge1.Dx * q + b1;\n    else\n      ip.x = edge2.Dx * q + b2;\n  }\n  if (ip.y < edge1.Top.y || ip.y < edge2.Top.y) {\n    if (edge1.Top.y > edge2.Top.y) {\n      ip.y = edge1.Top.y;\n      ip.x = ClipperLib.Clipper.TopX(edge2, edge1.Top.y);\n      return ip.x < edge1.Top.x;\n    } else\n      ip.y = edge2.Top.y;\n    if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n      ip.x = ClipperLib.Clipper.TopX(edge1, ip.y);\n    else\n      ip.x = ClipperLib.Clipper.TopX(edge2, ip.y);\n  }\n  //finally, don't allow 'ip' to be BELOW curr.y (ie bottom of scanbeam) ...\n  if (ip.y > edge1.Curr.y) {\n    ip.y = edge1.Curr.y;\n    //better to use the more vertical edge to derive X ...\n    if (Math.abs(edge1.Dx) > Math.abs(edge2.Dx))\n      ip.x = ClipperLib.Clipper.TopX(edge2, ip.y);\n    else\n      ip.x = ClipperLib.Clipper.TopX(edge1, ip.y);\n  }\n};\n\nClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function(topY) {\n  var e = this.m_ActiveEdges;\n\n  while (e !== null) {\n    //1. process maxima, treating them as if they're 'bent' horizontal edges,\n    //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\n    var IsMaximaEdge = this.IsMaxima(e, topY);\n    if (IsMaximaEdge) {\n      var eMaxPair = this.GetMaximaPairEx(e);\n      IsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));\n    }\n    if (IsMaximaEdge) {\n      if (this.StrictlySimple) {\n        this.InsertMaxima(e.Top.x);\n      }\n      var ePrev = e.PrevInAEL;\n      this.DoMaxima(e);\n      if (ePrev === null)\n        e = this.m_ActiveEdges;\n      else\n        e = ePrev.NextInAEL;\n    } else {\n      //2. promote horizontal edges, otherwise update Curr.x and Curr.y ...\n      if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML)) {\n        e = this.UpdateEdgeIntoAEL(e);\n        if (e.OutIdx >= 0)\n          this.AddOutPt(e, e.Bot);\n        this.AddEdgeToSEL(e);\n      } else {\n        e.Curr.x = ClipperLib.Clipper.TopX(e, topY);\n        e.Curr.y = topY;\n      }\n\n      //When StrictlySimple and 'e' is being touched by another edge, then\n      //make sure both edges have a vertex here ...\n      if (this.StrictlySimple) {\n        var ePrev = e.PrevInAEL;\n        if ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&\n          (ePrev.OutIdx >= 0) && (ePrev.Curr.x === e.Curr.x) &&\n          (ePrev.WindDelta !== 0)) {\n          var ip = new ClipperLib.FPoint1(e.Curr);\n\n          var op = this.AddOutPt(ePrev, ip);\n          var op2 = this.AddOutPt(e, ip);\n          this.AddJoin(op, op2, ip); //StrictlySimple (type-3) join\n        }\n      }\n      e = e.NextInAEL;\n    }\n  }\n  //3. Process horizontals at the Top of the scanbeam ...\n  this.ProcessHorizontals();\n  this.m_Maxima = null;\n  //4. Promote intermediate vertices ...\n  e = this.m_ActiveEdges;\n  while (e !== null) {\n    if (this.IsIntermediate(e, topY)) {\n      var op = null;\n      if (e.OutIdx >= 0)\n        op = this.AddOutPt(e, e.Top);\n      e = this.UpdateEdgeIntoAEL(e);\n      //if output polygons share an edge, they'll need joining later ...\n      var ePrev = e.PrevInAEL;\n      var eNext = e.NextInAEL;\n\n      if (ePrev !== null && ePrev.Curr.x === e.Bot.x && ePrev.Curr.y === e.Bot.y && op !== null && ePrev.OutIdx >= 0 && ePrev.Curr.y === ePrev.Top.y && ClipperLib.ClipperBase.SlopesEqual5(e.Curr, e.Top, ePrev.Curr, ePrev.Top) && (e.WindDelta !== 0) && (ePrev.WindDelta !== 0)) {\n        var op2 = this.AddOutPt(ePrev2, e.Bot);\n        this.AddJoin(op, op2, e.Top);\n      } else if (eNext !== null && eNext.Curr.x === e.Bot.x && eNext.Curr.y === e.Bot.y && op !== null && eNext.OutIdx >= 0 && eNext.Curr.y === eNext.Top.y && ClipperLib.ClipperBase.SlopesEqual5(e.Curr, e.Top, eNext.Curr, eNext.Top) && (e.WindDelta !== 0) && (eNext.WindDelta !== 0)) {\n        var op2 = this.AddOutPt(eNext, e.Bot);\n        this.AddJoin(op, op2, e.Top);\n      }\n    }\n    e = e.NextInAEL;\n  }\n};\n\nClipperLib.Clipper.prototype.DoMaxima = function(e) {\n  var eMaxPair = this.GetMaximaPairEx(e);\n  if (eMaxPair === null) {\n    if (e.OutIdx >= 0)\n      this.AddOutPt(e, e.Top);\n    this.DeleteFromAEL(e);\n    return;\n  }\n  var eNext = e.NextInAEL;\n  while (eNext !== null && eNext !== eMaxPair) {\n    this.IntersectEdges(e, eNext, e.Top);\n    this.SwapPositionsInAEL(e, eNext);\n    eNext = e.NextInAEL;\n  }\n  if (e.OutIdx === -1 && eMaxPair.OutIdx === -1) {\n    this.DeleteFromAEL(e);\n    this.DeleteFromAEL(eMaxPair);\n  } else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0) {\n    if (e.OutIdx >= 0) this.AddLocalMaxPoly(e, eMaxPair, e.Top);\n    this.DeleteFromAEL(e);\n    this.DeleteFromAEL(eMaxPair);\n  } else\n    ClipperLib.Error(\"DoMaxima error\");\n};\n\nClipperLib.Clipper.ReversePaths = function(polys) {\n  for (var i = 0, len = polys.length; i < len; i++)\n    polys[i].reverse();\n};\n\nClipperLib.Clipper.Orientation = function(poly) {\n  return ClipperLib.Clipper.Area(poly) >= 0;\n};\n\nClipperLib.Clipper.prototype.PointCount = function(pts) {\n  if (pts === null)\n    return 0;\n  var result = 0;\n  var p = pts;\n  do {\n    result++;\n    p = p.Next;\n  }\n  while (p !== pts)\n  return result;\n};\n\nClipperLib.Clipper.prototype.BuildResult = function(polyg) {\n  ClipperLib.Clear(polyg);\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n    var outRec = this.m_PolyOuts[i];\n    if (outRec.Pts === null)\n      continue;\n    var p = outRec.Pts.Prev;\n    var cnt = this.PointCount(p);\n    if (cnt < 2)\n      continue;\n    var pg = new Array(cnt);\n    for (var j = 0; j < cnt; j++) {\n      pg[j] = p.Pt;\n      p = p.Prev;\n    }\n    polyg.push(pg);\n  }\n};\n\nClipperLib.Clipper.prototype.BuildResult2 = function(polytree) {\n  polytree.Clear();\n  //add each output polygon/contour to polytree ...\n  //polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n    var outRec = this.m_PolyOuts[i];\n    var cnt = this.PointCount(outRec.Pts);\n    if ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))\n      continue;\n    this.FixHoleLinkage(outRec);\n    var pn = new ClipperLib.PolyNode();\n    polytree.m_AllPolys.push(pn);\n    outRec.PolyNode = pn;\n    pn.m_polygon.length = cnt;\n    var op = outRec.Pts.Prev;\n    for (var j = 0; j < cnt; j++) {\n      pn.m_polygon[j] = op.Pt;\n      op = op.Prev;\n    }\n  }\n  //fixup PolyNode links etc ...\n  //polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n    var outRec = this.m_PolyOuts[i];\n    if (outRec.PolyNode === null)\n      continue;\n    else if (outRec.IsOpen) {\n      outRec.PolyNode.IsOpen = true;\n      polytree.AddChild(outRec.PolyNode);\n    } else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode !== null)\n      outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);\n    else\n      polytree.AddChild(outRec.PolyNode);\n  }\n};\n\nClipperLib.Clipper.prototype.FixupOutPolyline = function(outRec) {\n  var pp = outRec.Pts;\n  var lastPP = pp.Prev;\n  while (pp !== lastPP) {\n    pp = pp.Next;\n    if (ClipperLib.FPoint.op_Equality(pp.Pt, pp.Prev.Pt)) {\n      if (pp === lastPP) {\n        lastPP = pp.Prev;\n      }\n      var tmpPP = pp.Prev;\n      tmpPP.Next = pp.Next;\n      pp.Next.Prev = tmpPP;\n      pp = tmpPP;\n    }\n  }\n  if (pp === pp.Prev) {\n    outRec.Pts = null;\n  }\n};\n\nClipperLib.Clipper.prototype.FixupOutPolygon = function(outRec) {\n  //FixupOutPolygon() - removes duplicate points and simplifies consecutive\n  //parallel edges by removing the middle vertex.\n  var lastOK = null;\n  outRec.BottomPt = null;\n  var pp = outRec.Pts;\n  var preserveCol = this.PreserveCollinear || this.StrictlySimple;\n  for (;;) {\n    if (pp.Prev === pp || pp.Prev === pp.Next) {\n      outRec.Pts = null;\n      return;\n    }\n\n    //test for duplicate points and collinear edges ...\n    if ((ClipperLib.FPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.FPoint.op_Equality(pp.Pt, pp.Prev.Pt)) || (ClipperLib.ClipperBase.SlopesEqual4(pp.Prev.Pt, pp.Pt, pp.Next.Pt) && (!preserveCol || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt)))) {\n      lastOK = null;\n      pp.Prev.Next = pp.Next;\n      pp.Next.Prev = pp.Prev;\n      pp = pp.Prev;\n    } else if (pp === lastOK)\n      break;\n    else {\n      if (lastOK === null)\n        lastOK = pp;\n      pp = pp.Next;\n    }\n  }\n  outRec.Pts = pp;\n};\n\nClipperLib.Clipper.prototype.DupOutPt = function(outPt, InsertAfter) {\n  var result = new ClipperLib.OutPt();\n  //result.Pt = outPt.Pt;\n  result.Pt.x = outPt.Pt.x;\n  result.Pt.y = outPt.Pt.y;\n  result.Idx = outPt.Idx;\n  if (InsertAfter) {\n    result.Next = outPt.Next;\n    result.Prev = outPt;\n    outPt.Next.Prev = result;\n    outPt.Next = result;\n  } else {\n    result.Prev = outPt.Prev;\n    result.Next = outPt;\n    outPt.Prev.Next = result;\n    outPt.Prev = result;\n  }\n  return result;\n};\n\nClipperLib.Clipper.prototype.GetOverlap = function(a1, a2, b1, b2, $val) {\n  if (a1 < a2) {\n    if (b1 < b2) {\n      $val.Left = Math.max(a1, b1);\n      $val.Right = Math.min(a2, b2);\n    } else {\n      $val.Left = Math.max(a1, b2);\n      $val.Right = Math.min(a2, b1);\n    }\n  } else {\n    if (b1 < b2) {\n      $val.Left = Math.max(a2, b1);\n      $val.Right = Math.min(a1, b2);\n    } else {\n      $val.Left = Math.max(a2, b2);\n      $val.Right = Math.min(a1, b1);\n    }\n  }\n  return $val.Left < $val.Right;\n};\n\nClipperLib.Clipper.prototype.JoinHorz = function(op1, op1b, op2, op2b, Pt, DiscardLeft) {\n  var Dir1 = (op1.Pt.x > op1b.Pt.x ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n  var Dir2 = (op2.Pt.x > op2b.Pt.x ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n  if (Dir1 === Dir2)\n    return false;\n  //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\n  //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\n  //So, to facilitate this while inserting Op1b and Op2b ...\n  //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\n  //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\n  if (Dir1 === ClipperLib.Direction.dLeftToRight) {\n    while (op1.Next.Pt.x <= Pt.x &&\n      op1.Next.Pt.x >= op1.Pt.x && op1.Next.Pt.y === Pt.y)\n      op1 = op1.Next;\n    if (DiscardLeft && (op1.Pt.x !== Pt.x))\n      op1 = op1.Next;\n    op1b = this.DupOutPt(op1, !DiscardLeft);\n    if (ClipperLib.FPoint.op_Inequality(op1b.Pt, Pt)) {\n      op1 = op1b;\n      //op1.Pt = Pt;\n      op1.Pt.x = Pt.x;\n      op1.Pt.y = Pt.y;\n      op1b = this.DupOutPt(op1, !DiscardLeft);\n    }\n  } else {\n    while (op1.Next.Pt.x >= Pt.x &&\n      op1.Next.Pt.x <= op1.Pt.x && op1.Next.Pt.y === Pt.y)\n      op1 = op1.Next;\n    if (!DiscardLeft && (op1.Pt.x !== Pt.x))\n      op1 = op1.Next;\n    op1b = this.DupOutPt(op1, DiscardLeft);\n    if (ClipperLib.FPoint.op_Inequality(op1b.Pt, Pt)) {\n      op1 = op1b;\n      //op1.Pt = Pt;\n      op1.Pt.x = Pt.x;\n      op1.Pt.y = Pt.y;\n      op1b = this.DupOutPt(op1, DiscardLeft);\n    }\n  }\n  if (Dir2 === ClipperLib.Direction.dLeftToRight) {\n    while (op2.Next.Pt.x <= Pt.x &&\n      op2.Next.Pt.x >= op2.Pt.x && op2.Next.Pt.y === Pt.y)\n      op2 = op2.Next;\n    if (DiscardLeft && (op2.Pt.x !== Pt.x))\n      op2 = op2.Next;\n    op2b = this.DupOutPt(op2, !DiscardLeft);\n    if (ClipperLib.FPoint.op_Inequality(op2b.Pt, Pt)) {\n      op2 = op2b;\n      //op2.Pt = Pt;\n      op2.Pt.x = Pt.x;\n      op2.Pt.y = Pt.y;\n      op2b = this.DupOutPt(op2, !DiscardLeft);\n    }\n  } else {\n    while (op2.Next.Pt.x >= Pt.x &&\n      op2.Next.Pt.x <= op2.Pt.x && op2.Next.Pt.y === Pt.y)\n      op2 = op2.Next;\n    if (!DiscardLeft && (op2.Pt.x !== Pt.x))\n      op2 = op2.Next;\n    op2b = this.DupOutPt(op2, DiscardLeft);\n    if (ClipperLib.FPoint.op_Inequality(op2b.Pt, Pt)) {\n      op2 = op2b;\n      //op2.Pt = Pt;\n      op2.Pt.x = Pt.x;\n      op2.Pt.y = Pt.y;\n      op2b = this.DupOutPt(op2, DiscardLeft);\n    }\n  }\n  if ((Dir1 === ClipperLib.Direction.dLeftToRight) === DiscardLeft) {\n    op1.Prev = op2;\n    op2.Next = op1;\n    op1b.Next = op2b;\n    op2b.Prev = op1b;\n  } else {\n    op1.Next = op2;\n    op2.Prev = op1;\n    op1b.Prev = op2b;\n    op2b.Next = op1b;\n  }\n  return true;\n};\n\nClipperLib.Clipper.prototype.JoinPoints = function(j, outRec1, outRec2) {\n  var op1 = j.OutPt1,\n    op1b = new ClipperLib.OutPt();\n  var op2 = j.OutPt2,\n    op2b = new ClipperLib.OutPt();\n  //There are 3 kinds of joins for output polygons ...\n  //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are vertices anywhere\n  //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\n  //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\n  //location at the Bottom of the overlapping segment (& Join.OffPt is above).\n  //3. StrictlySimple joins where edges touch but are not collinear and where\n  //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\n  var isHorizontal = (j.OutPt1.Pt.y === j.OffPt.y);\n  if (isHorizontal && (ClipperLib.FPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.FPoint.op_Equality(j.OffPt, j.OutPt2.Pt))) {\n    //Strictly Simple join ...\n    if (outRec1 !== outRec2) return false;\n\n    op1b = j.OutPt1.Next;\n    while (op1b !== op1 && (ClipperLib.FPoint.op_Equality(op1b.Pt, j.OffPt)))\n      op1b = op1b.Next;\n    var reverse1 = (op1b.Pt.y > j.OffPt.y);\n    op2b = j.OutPt2.Next;\n    while (op2b !== op2 && (ClipperLib.FPoint.op_Equality(op2b.Pt, j.OffPt)))\n      op2b = op2b.Next;\n    var reverse2 = (op2b.Pt.y > j.OffPt.y);\n    if (reverse1 === reverse2)\n      return false;\n    if (reverse1) {\n      op1b = this.DupOutPt(op1, false);\n      op2b = this.DupOutPt(op2, true);\n      op1.Prev = op2;\n      op2.Next = op1;\n      op1b.Next = op2b;\n      op2b.Prev = op1b;\n      j.OutPt1 = op1;\n      j.OutPt2 = op1b;\n      return true;\n    } else {\n      op1b = this.DupOutPt(op1, true);\n      op2b = this.DupOutPt(op2, false);\n      op1.Next = op2;\n      op2.Prev = op1;\n      op1b.Prev = op2b;\n      op2b.Next = op1b;\n      j.OutPt1 = op1;\n      j.OutPt2 = op1b;\n      return true;\n    }\n  } else if (isHorizontal) {\n    //treat horizontal joins differently to non-horizontal joins since with\n    //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\n    //may be anywhere along the horizontal edge.\n    op1b = op1;\n    while (op1.Prev.Pt.y === op1.Pt.y && op1.Prev !== op1b && op1.Prev !== op2)\n      op1 = op1.Prev;\n    while (op1b.Next.Pt.y === op1b.Pt.y && op1b.Next !== op1 && op1b.Next !== op2)\n      op1b = op1b.Next;\n    if (op1b.Next === op1 || op1b.Next === op2)\n      return false;\n    //a flat 'polygon'\n    op2b = op2;\n    while (op2.Prev.Pt.y === op2.Pt.y && op2.Prev !== op2b && op2.Prev !== op1b)\n      op2 = op2.Prev;\n    while (op2b.Next.Pt.y === op2b.Pt.y && op2b.Next !== op2 && op2b.Next !== op1)\n      op2b = op2b.Next;\n    if (op2b.Next === op2 || op2b.Next === op1)\n      return false;\n    //a flat 'polygon'\n    //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges\n\n    var $val = {\n      Left: null,\n      Right: null\n    };\n\n    if (!this.GetOverlap(op1.Pt.x, op1b.Pt.x, op2.Pt.x, op2b.Pt.x, $val))\n      return false;\n    var Left = $val.Left;\n    var Right = $val.Right;\n\n    //DiscardLeftSide: when overlapping edges are joined, a spike will created\n    //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\n    //on the discard Side as either may still be needed for other joins ...\n    var Pt = new ClipperLib.FPoint0();\n    var DiscardLeftSide;\n    if (op1.Pt.x >= Left && op1.Pt.x <= Right) {\n      //Pt = op1.Pt;\n      Pt.x = op1.Pt.x;\n      Pt.y = op1.Pt.y;\n      DiscardLeftSide = (op1.Pt.x > op1b.Pt.x);\n    } else if (op2.Pt.x >= Left && op2.Pt.x <= Right) {\n      //Pt = op2.Pt;\n      Pt.x = op2.Pt.x;\n      Pt.y = op2.Pt.y;\n      DiscardLeftSide = (op2.Pt.x > op2b.Pt.x);\n    } else if (op1b.Pt.x >= Left && op1b.Pt.x <= Right) {\n      //Pt = op1b.Pt;\n      Pt.x = op1b.Pt.x;\n      Pt.y = op1b.Pt.y;\n      DiscardLeftSide = op1b.Pt.x > op1.Pt.x;\n    } else {\n      //Pt = op2b.Pt;\n      Pt.x = op2b.Pt.x;\n      Pt.y = op2b.Pt.y;\n      DiscardLeftSide = (op2b.Pt.x > op2.Pt.x);\n    }\n    j.OutPt1 = op1;\n    j.OutPt2 = op2;\n    return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\n  } else {\n    //nb: For non-horizontal joins ...\n    //    1. Jr.OutPt1.Pt.y == Jr.OutPt2.Pt.y\n    //    2. Jr.OutPt1.Pt > Jr.OffPt.y\n    //make sure the polygons are correctly oriented ...\n    op1b = op1.Next;\n    while ((ClipperLib.FPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b !== op1))\n      op1b = op1b.Next;\n    var Reverse1 = ((op1b.Pt.y > op1.Pt.y) || !ClipperLib.ClipperBase.SlopesEqual4(op1.Pt, op1b.Pt, j.OffPt));\n    if (Reverse1) {\n      op1b = op1.Prev;\n      while ((ClipperLib.FPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b !== op1))\n        op1b = op1b.Prev;\n\n      if ((op1b.Pt.y > op1.Pt.y) || !ClipperLib.ClipperBase.SlopesEqual4(op1.Pt, op1b.Pt, j.OffPt))\n        return false;\n    }\n    op2b = op2.Next;\n    while ((ClipperLib.FPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b !== op2))\n      op2b = op2b.Next;\n\n    var Reverse2 = ((op2b.Pt.y > op2.Pt.y) || !ClipperLib.ClipperBase.SlopesEqual4(op2.Pt, op2b.Pt, j.OffPt));\n    if (Reverse2) {\n      op2b = op2.Prev;\n      while ((ClipperLib.FPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b !== op2))\n        op2b = op2b.Prev;\n\n      if ((op2b.Pt.y > op2.Pt.y) || !ClipperLib.ClipperBase.SlopesEqual4(op2.Pt, op2b.Pt, j.OffPt))\n        return false;\n    }\n    if ((op1b === op1) || (op2b === op2) || (op1b === op2b) ||\n      ((outRec1 === outRec2) && (Reverse1 === Reverse2)))\n      return false;\n    if (Reverse1) {\n      op1b = this.DupOutPt(op1, false);\n      op2b = this.DupOutPt(op2, true);\n      op1.Prev = op2;\n      op2.Next = op1;\n      op1b.Next = op2b;\n      op2b.Prev = op1b;\n      j.OutPt1 = op1;\n      j.OutPt2 = op1b;\n      return true;\n    } else {\n      op1b = this.DupOutPt(op1, true);\n      op2b = this.DupOutPt(op2, false);\n      op1.Next = op2;\n      op2.Prev = op1;\n      op1b.Prev = op2b;\n      op2b.Next = op1b;\n      j.OutPt1 = op1;\n      j.OutPt2 = op1b;\n      return true;\n    }\n  }\n};\n\nClipperLib.Clipper.GetBounds = function(paths) {\n  var i = 0,\n    cnt = paths.length;\n  while (i < cnt && paths[i].length === 0) i++;\n  if (i === cnt) return new ClipperLib.FRect(0, 0, 0, 0);\n  var result = new ClipperLib.FRect();\n  result.left = paths[i][0].x;\n  result.right = result.left;\n  result.top = paths[i][0].y;\n  result.bottom = result.top;\n  for (; i < cnt; i++)\n    for (var j = 0, jlen = paths[i].length; j < jlen; j++) {\n      if (paths[i][j].x < result.left) result.left = paths[i][j].x;\n      else if (paths[i][j].x > result.right) result.right = paths[i][j].x;\n      if (paths[i][j].y < result.top) result.top = paths[i][j].y;\n      else if (paths[i][j].y > result.bottom) result.bottom = paths[i][j].y;\n    }\n  return result;\n}\nClipperLib.Clipper.prototype.GetBounds2 = function(ops) {\n  var opStart = ops;\n  var result = new ClipperLib.FRect();\n  result.left = ops.Pt.x;\n  result.right = ops.Pt.x;\n  result.top = ops.Pt.y;\n  result.bottom = ops.Pt.y;\n  ops = ops.Next;\n  while (ops !== opStart) {\n    if (ops.Pt.x < result.left)\n      result.left = ops.Pt.x;\n    if (ops.Pt.x > result.right)\n      result.right = ops.Pt.x;\n    if (ops.Pt.y < result.top)\n      result.top = ops.Pt.y;\n    if (ops.Pt.y > result.bottom)\n      result.bottom = ops.Pt.y;\n    ops = ops.Next;\n  }\n  return result;\n};\n\nClipperLib.Clipper.PointInPolygon = function(pt, path) {\n  //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n  //See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n  //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n  var result = 0,\n    cnt = path.length;\n  if (cnt < 3)\n    return 0;\n  var ip = path[0];\n  for (var i = 1; i <= cnt; ++i) {\n    var ipNext = (i === cnt ? path[0] : path[i]);\n    if (ipNext.y === pt.y) {\n      if ((ipNext.x === pt.x) || (ip.y === pt.y && ((ipNext.x > pt.x) === (ip.x < pt.x))))\n        return -1;\n    }\n    if ((ip.y < pt.y) !== (ipNext.y < pt.y)) {\n      if (ip.x >= pt.x) {\n        if (ipNext.x > pt.x)\n          result = 1 - result;\n        else {\n          var d = (ip.x - pt.x) * (ipNext.y - pt.y) - (ipNext.x - pt.x) * (ip.y - pt.y);\n          if (d === 0)\n            return -1;\n          else if ((d > 0) === (ipNext.y > ip.y))\n            result = 1 - result;\n        }\n      } else {\n        if (ipNext.x > pt.x) {\n          var d = (ip.x - pt.x) * (ipNext.y - pt.y) - (ipNext.x - pt.x) * (ip.y - pt.y);\n          if (d === 0)\n            return -1;\n          else if ((d > 0) === (ipNext.y > ip.y))\n            result = 1 - result;\n        }\n      }\n    }\n    ip = ipNext;\n  }\n  return result;\n};\n\nClipperLib.Clipper.prototype.PointInPolygon = function(pt, op) {\n  //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n  var result = 0;\n  var startOp = op;\n  var ptx = pt.x,\n    pty = pt.y;\n  var poly0x = op.Pt.x,\n    poly0y = op.Pt.y;\n  do {\n    op = op.Next;\n    var poly1x = op.Pt.x,\n      poly1y = op.Pt.y;\n    if (poly1y === pty) {\n      if ((poly1x === ptx) || (poly0y === pty && ((poly1x > ptx) === (poly0x < ptx))))\n        return -1;\n    }\n    if ((poly0y < pty) !== (poly1y < pty)) {\n      if (poly0x >= ptx) {\n        if (poly1x > ptx)\n          result = 1 - result;\n        else {\n          var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n          if (d === 0)\n            return -1;\n          if ((d > 0) === (poly1y > poly0y))\n            result = 1 - result;\n        }\n      } else {\n        if (poly1x > ptx) {\n          var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n          if (d === 0)\n            return -1;\n          if ((d > 0) === (poly1y > poly0y))\n            result = 1 - result;\n        }\n      }\n    }\n    poly0x = poly1x;\n    poly0y = poly1y;\n  } while (startOp !== op);\n\n  return result;\n};\n\nClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function(outPt1, outPt2) {\n  var op = outPt1;\n  do {\n    //nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon\n    var res = this.PointInPolygon(op.Pt, outPt2);\n    if (res >= 0)\n      return res > 0;\n    op = op.Next;\n  }\n  while (op !== outPt1)\n  return true;\n};\n\nClipperLib.Clipper.prototype.FixupFirstLefts1 = function(OldOutRec, NewOutRec) {\n  var outRec, firstLeft;\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n    outRec = this.m_PolyOuts[i];\n    firstLeft = ClipperLib.Clipper.ParseFirstLeft(outRec.FirstLeft);\n    if (outRec.Pts !== null && firstLeft === OldOutRec) {\n      if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))\n        outRec.FirstLeft = NewOutRec;\n    }\n  }\n}\n\nClipperLib.Clipper.prototype.FixupFirstLefts2 = function(innerOutRec, outerOutRec) {\n  //A polygon has split into two such that one is now the inner of the other.\n  //It's possible that these polygons now wrap around other polygons, so check\n  //every polygon that's also contained by OuterOutRec's FirstLeft container\n  //(including nil) to see if they've become inner to the new inner polygon ...\n  var orfl = outerOutRec.FirstLeft;\n  var outRec, firstLeft;\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n    outRec = this.m_PolyOuts[i];\n    if (outRec.Pts === null || outRec === outerOutRec || outRec === innerOutRec)\n      continue;\n    firstLeft = ClipperLib.Clipper.ParseFirstLeft(outRec.FirstLeft);\n    if (firstLeft !== orfl && firstLeft !== innerOutRec && firstLeft !== outerOutRec)\n      continue;\n    if (this.Poly2ContainsPoly1(outRec.Pts, innerOutRec.Pts))\n      outRec.FirstLeft = innerOutRec;\n    else if (this.Poly2ContainsPoly1(outRec.Pts, outerOutRec.Pts))\n      outRec.FirstLeft = outerOutRec;\n    else if (outRec.FirstLeft === innerOutRec || outRec.FirstLeft === outerOutRec)\n      outRec.FirstLeft = orfl;\n  }\n}\n\nClipperLib.Clipper.prototype.FixupFirstLefts3 = function(OldOutRec, NewOutRec) {\n  //same as FixupFirstLefts1 but doesn't call Poly2ContainsPoly1()\n  var outRec;\n  var firstLeft;\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n    outRec = this.m_PolyOuts[i];\n    firstLeft = ClipperLib.Clipper.ParseFirstLeft(outRec.FirstLeft);\n    if (outRec.Pts !== null && firstLeft === OldOutRec)\n      outRec.FirstLeft = NewOutRec;\n  }\n}\n\nClipperLib.Clipper.ParseFirstLeft = function(FirstLeft) {\n  while (FirstLeft !== null && FirstLeft.Pts === null)\n    FirstLeft = FirstLeft.FirstLeft;\n  return FirstLeft;\n};\n\nClipperLib.Clipper.prototype.JoinCommonEdges = function() {\n  for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++) {\n    var join = this.m_Joins[i];\n    var outRec1 = this.GetOutRec(join.OutPt1.Idx);\n    var outRec2 = this.GetOutRec(join.OutPt2.Idx);\n    if (outRec1.Pts === null || outRec2.Pts === null)\n      continue;\n\n    if (outRec1.IsOpen || outRec2.IsOpen) {\n      continue;\n    }\n\n    //get the polygon fragment with the correct hole state (FirstLeft)\n    //before calling JoinPoints() ...\n    var holeStateRec;\n    if (outRec1 === outRec2)\n      holeStateRec = outRec1;\n    else if (this.OutRec1RightOfOutRec2(outRec1, outRec2))\n      holeStateRec = outRec2;\n    else if (this.OutRec1RightOfOutRec2(outRec2, outRec1))\n      holeStateRec = outRec1;\n    else\n      holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\n    if (!this.JoinPoints(join, outRec1, outRec2)) continue;\n\n    if (outRec1 === outRec2) {\n      //instead of joining two polygons, we've just created a new one by\n      //splitting one polygon into two.\n      outRec1.Pts = join.OutPt1;\n      outRec1.BottomPt = null;\n      outRec2 = this.CreateOutRec();\n      outRec2.Pts = join.OutPt2;\n      //update all OutRec2.Pts Idx's ...\n      this.UpdateOutPtIdxs(outRec2);\n\n      if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts)) {\n        //outRec1 contains outRec2 ...\n        outRec2.IsHole = !outRec1.IsHole;\n        outRec2.FirstLeft = outRec1;\n        if (this.m_UsingPolyTree)\n          this.FixupFirstLefts2(outRec2, outRec1);\n        if ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area$1(outRec2) > 0))\n          this.ReversePolyPtLinks(outRec2.Pts);\n      } else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts)) {\n        //outRec2 contains outRec1 ...\n        outRec2.IsHole = outRec1.IsHole;\n        outRec1.IsHole = !outRec2.IsHole;\n        outRec2.FirstLeft = outRec1.FirstLeft;\n        outRec1.FirstLeft = outRec2;\n        if (this.m_UsingPolyTree)\n          this.FixupFirstLefts2(outRec1, outRec2);\n\n        if ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area$1(outRec1) > 0))\n          this.ReversePolyPtLinks(outRec1.Pts);\n      } else {\n        //the 2 polygons are completely separate ...\n        outRec2.IsHole = outRec1.IsHole;\n        outRec2.FirstLeft = outRec1.FirstLeft;\n        //fixup FirstLeft pointers that may need reassigning to OutRec2\n        if (this.m_UsingPolyTree)\n          this.FixupFirstLefts1(outRec1, outRec2);\n      }\n    } else {\n      //joined 2 polygons together ...\n      outRec2.Pts = null;\n      outRec2.BottomPt = null;\n      outRec2.Idx = outRec1.Idx;\n      outRec1.IsHole = holeStateRec.IsHole;\n      if (holeStateRec === outRec2)\n        outRec1.FirstLeft = outRec2.FirstLeft;\n      outRec2.FirstLeft = outRec1;\n      //fixup FirstLeft pointers that may need reassigning to OutRec1\n      if (this.m_UsingPolyTree)\n        this.FixupFirstLefts3(outRec2, outRec1);\n    }\n  }\n};\n\nClipperLib.Clipper.prototype.UpdateOutPtIdxs = function(outrec) {\n  var op = outrec.Pts;\n  do {\n    op.Idx = outrec.Idx;\n    op = op.Prev;\n  }\n  while (op !== outrec.Pts)\n};\n\nClipperLib.Clipper.prototype.DoSimplePolygons = function() {\n  var i = 0;\n  while (i < this.m_PolyOuts.length) {\n    var outrec = this.m_PolyOuts[i++];\n    var op = outrec.Pts;\n    if (op === null || outrec.IsOpen)\n      continue;\n    do //for each Pt in Polygon until duplicate found do ...\n    {\n      var op2 = op.Next;\n      while (op2 !== outrec.Pts) {\n        if ((ClipperLib.FPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next !== op && op2.Prev !== op) {\n          //split the polygon into two ...\n          var op3 = op.Prev;\n          var op4 = op2.Prev;\n          op.Prev = op4;\n          op4.Next = op;\n          op2.Prev = op3;\n          op3.Next = op2;\n          outrec.Pts = op;\n          var outrec2 = this.CreateOutRec();\n          outrec2.Pts = op2;\n          this.UpdateOutPtIdxs(outrec2);\n          if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts)) {\n            //OutRec2 is contained by OutRec1 ...\n            outrec2.IsHole = !outrec.IsHole;\n            outrec2.FirstLeft = outrec;\n            if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec2, outrec);\n\n          } else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts)) {\n            //OutRec1 is contained by OutRec2 ...\n            outrec2.IsHole = outrec.IsHole;\n            outrec.IsHole = !outrec2.IsHole;\n            outrec2.FirstLeft = outrec.FirstLeft;\n            outrec.FirstLeft = outrec2;\n            if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec, outrec2);\n          } else {\n            //the 2 polygons are separate ...\n            outrec2.IsHole = outrec.IsHole;\n            outrec2.FirstLeft = outrec.FirstLeft;\n            if (this.m_UsingPolyTree) this.FixupFirstLefts1(outrec, outrec2);\n          }\n          op2 = op;\n          //ie get ready for the next iteration\n        }\n        op2 = op2.Next;\n      }\n      op = op.Next;\n    }\n    while (op !== outrec.Pts)\n  }\n};\n\nClipperLib.Clipper.Area = function(poly) {\n  if (!Array.isArray(poly))\n    return 0;\n  var cnt = poly.length;\n  if (cnt < 3)\n    return 0;\n  var a = 0;\n  for (var i = 0, j = cnt - 1; i < cnt; ++i) {\n    a += (poly[j].x + poly[i].x) * (poly[j].y - poly[i].y);\n    j = i;\n  }\n  return -a * 0.5;\n};\n\nClipperLib.Clipper.prototype.Area = function(op) {\n  var opFirst = op;\n  if (op === null) return 0;\n  var a = 0;\n  do {\n    a = a + (op.Prev.Pt.x + op.Pt.x) * (op.Prev.Pt.y - op.Pt.y);\n    op = op.Next;\n  } while (op !== opFirst); // && typeof op !== 'undefined');\n  return a * 0.5;\n}\n\nClipperLib.Clipper.prototype.Area$1 = function(outRec) {\n  return this.Area(outRec.Pts);\n};\n\nClipperLib.Clipper.SimplifyPolygon = function(poly, fillType) {\n  var result = new Array();\n  var c = new ClipperLib.Clipper(0);\n  c.StrictlySimple = true;\n  c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);\n  c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n  return result;\n};\n\nClipperLib.Clipper.SimplifyPolygons = function(polys, fillType) {\n  if (typeof(fillType) === \"undefined\") fillType = ClipperLib.PolyFillType.pftEvenOdd;\n  var result = new Array();\n  var c = new ClipperLib.Clipper(0);\n  c.StrictlySimple = true;\n  c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);\n  c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n  return result;\n};\n\nClipperLib.Clipper.DistanceSqrd = function(pt1, pt2) {\n  var dx = (pt1.x - pt2.x);\n  var dy = (pt1.y - pt2.y);\n  return (dx * dx + dy * dy);\n};\n\nClipperLib.Clipper.DistanceFromLineSqrd = function(pt, ln1, ln2) {\n  //The equation of a line in general form (Ax + By + C = 0)\n  //given 2 points (x,y) & (x,y) is ...\n  //(y - y)x + (x - x)y + (y - y)x - (x - x)y = 0\n  //A = (y - y); B = (x - x); C = (y - y)x - (x - x)y\n  //perpendicular distance of point (x,y) = (Ax + By + C)/Sqrt(A + B)\n  //see http://en.wikipedia.org/wiki/Perpendicular_distance\n  var A = ln1.y - ln2.y;\n  var B = ln2.x - ln1.x;\n  var C = A * ln1.x + B * ln1.y;\n  C = A * pt.x + B * pt.y - C;\n  return (C * C) / (A * A + B * B);\n};\n\nClipperLib.Clipper.SlopesNearCollinear = function(pt1, pt2, pt3, distSqrd) {\n  //this function is more accurate when the point that's GEOMETRICALLY\n  //between the other 2 points is the one that's tested for distance.\n  //nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts\n  if (Math.abs(pt1.x - pt2.x) > Math.abs(pt1.y - pt2.y)) {\n    if ((pt1.x > pt2.x) === (pt1.x < pt3.x))\n      return ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n    else if ((pt2.x > pt1.x) === (pt2.x < pt3.x))\n      return ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n    else\n      return ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n  } else {\n    if ((pt1.y > pt2.y) === (pt1.y < pt3.y))\n      return ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n    else if ((pt2.y > pt1.y) === (pt2.y < pt3.y))\n      return ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n    else\n      return ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n  }\n}\n\nClipperLib.Clipper.PointsAreClose = function(pt1, pt2, distSqrd) {\n  var dx = pt1.x - pt2.x;\n  var dy = pt1.y - pt2.y;\n  return ((dx * dx) + (dy * dy) <= distSqrd);\n};\n\nClipperLib.Clipper.ExcludeOp = function(op) {\n  var result = op.Prev;\n  result.Next = op.Next;\n  op.Next.Prev = result;\n  result.Idx = 0;\n  return result;\n};\n\nClipperLib.Clipper.CleanPolygon = function(path, distance) {\n  if (typeof(distance) === \"undefined\") distance = 1.415;\n  //distance = proximity in units/pixels below which vertices will be stripped.\n  //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have\n  //both x & y coords within 1 unit, then the second vertex will be stripped.\n  var cnt = path.length;\n  if (cnt === 0)\n    return new Array();\n  var outPts = new Array(cnt);\n  for (var i = 0; i < cnt; ++i)\n    outPts[i] = new ClipperLib.OutPt();\n  for (var i = 0; i < cnt; ++i) {\n    outPts[i].Pt = path[i];\n    outPts[i].Next = outPts[(i + 1) % cnt];\n    outPts[i].Next.Prev = outPts[i];\n    outPts[i].Idx = 0;\n  }\n  var distSqrd = distance * distance;\n  var op = outPts[0];\n  while (op.Idx === 0 && op.Next !== op.Prev) {\n    if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd)) {\n      op = ClipperLib.Clipper.ExcludeOp(op);\n      cnt--;\n    } else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd)) {\n      ClipperLib.Clipper.ExcludeOp(op.Next);\n      op = ClipperLib.Clipper.ExcludeOp(op);\n      cnt -= 2;\n    } else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd)) {\n      op = ClipperLib.Clipper.ExcludeOp(op);\n      cnt--;\n    } else {\n      op.Idx = 1;\n      op = op.Next;\n    }\n  }\n  if (cnt < 3)\n    cnt = 0;\n  var result = new Array(cnt);\n  for (var i = 0; i < cnt; ++i) {\n    result[i] = new ClipperLib.FPoint1(op.Pt);\n    op = op.Next;\n  }\n  outPts = null;\n  return result;\n};\n\nClipperLib.Clipper.CleanPolygons = function(polys, distance) {\n  var result = new Array(polys.length);\n  for (var i = 0, ilen = polys.length; i < ilen; i++)\n    result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);\n  return result;\n};\n\nClipperLib.Clipper.Minkowski = function(pattern, path, IsSum, IsClosed) {\n  var delta = (IsClosed ? 1 : 0);\n  var polyCnt = pattern.length;\n  var pathCnt = path.length;\n  var result = new Array();\n  if (IsSum)\n    for (var i = 0; i < pathCnt; i++) {\n      var p = new Array(polyCnt);\n      for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n        p[j] = new ClipperLib.FPoint2(path[i].x + ip.x, path[i].y + ip.y);\n      result.push(p);\n    }\n  else\n    for (var i = 0; i < pathCnt; i++) {\n      var p = new Array(polyCnt);\n      for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n        p[j] = new ClipperLib.FPoint2(path[i].x - ip.x, path[i].y - ip.y);\n      result.push(p);\n    }\n  var quads = new Array();\n  for (var i = 0; i < pathCnt - 1 + delta; i++)\n    for (var j = 0; j < polyCnt; j++) {\n      var quad = new Array();\n      quad.push(result[i % pathCnt][j % polyCnt]);\n      quad.push(result[(i + 1) % pathCnt][j % polyCnt]);\n      quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);\n      quad.push(result[i % pathCnt][(j + 1) % polyCnt]);\n      if (!ClipperLib.Clipper.Orientation(quad))\n        quad.reverse();\n      quads.push(quad);\n    }\n  return quads;\n};\n\nClipperLib.Clipper.MinkowskiSum = function(pattern, path_or_paths, pathIsClosed) {\n  if (!(path_or_paths[0] instanceof Array)) {\n    var path = path_or_paths;\n    var paths = ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);\n    var c = new ClipperLib.Clipper();\n    c.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n    c.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n    return paths;\n  } else {\n    var paths = path_or_paths;\n    var solution = new ClipperLib.Paths();\n    var c = new ClipperLib.Clipper();\n    for (var i = 0; i < paths.length; ++i) {\n      var tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);\n      c.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);\n      if (pathIsClosed) {\n        var path = ClipperLib.Clipper.TranslatePath(paths[i], pattern[0]);\n        c.AddPath(path, ClipperLib.PolyType.ptClip, true);\n      }\n    }\n    c.Execute(ClipperLib.ClipType.ctUnion, solution,\n      ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n    return solution;\n  }\n}\n\nClipperLib.Clipper.TranslatePath = function(path, delta) {\n  var outPath = new ClipperLib.Path();\n  for (var i = 0; i < path.length; i++)\n    outPath.push(new ClipperLib.FPoint2(path[i].x + delta.x, path[i].y + delta.y));\n  return outPath;\n}\n\nClipperLib.Clipper.MinkowskiDiff = function(poly1, poly2) {\n  var paths = ClipperLib.Clipper.Minkowski(poly1, poly2, false, true);\n  var c = new ClipperLib.Clipper();\n  c.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n  c.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n  return paths;\n}\n\nClipperLib.Clipper.PolyTreeToPaths = function(polytree) {\n  var result = new Array();\n  //result.set_Capacity(polytree.get_Total());\n  ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);\n  return result;\n};\n\nClipperLib.Clipper.AddPolyNodeToPaths = function(polynode, nt, paths) {\n  var match = true;\n  switch (nt) {\n    case ClipperLib.Clipper.NodeType.ntOpen:\n      return;\n    case ClipperLib.Clipper.NodeType.ntClosed:\n      match = !polynode.IsOpen;\n      break;\n    default:\n      break;\n  }\n  if (polynode.m_polygon.length > 0 && match)\n    paths.push(polynode.m_polygon);\n  for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])\n    ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);\n};\n\nClipperLib.Clipper.OpenPathsFromPolyTree = function(polytree) {\n  var result = new ClipperLib.Paths();\n  //result.set_Capacity(polytree.ChildCount());\n  for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)\n    if (polytree.Childs()[i].IsOpen)\n      result.push(polytree.Childs()[i].m_polygon);\n  return result;\n};\n\nClipperLib.Clipper.ClosedPathsFromPolyTree = function(polytree) {\n  var result = new ClipperLib.Paths();\n  //result.set_Capacity(polytree.Total());\n  ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);\n  return result;\n};\n\nInherit(ClipperLib.Clipper, ClipperLib.ClipperBase);\nClipperLib.Clipper.NodeType = {\n  ntAny: 0,\n  ntOpen: 1,\n  ntClosed: 2\n};\n\n/**\n * @constructor\n */\nClipperLib.ClipperOffset = function(miterLimit, arcTolerance) {\n  if (typeof(miterLimit) === \"undefined\") miterLimit = 2;\n  if (typeof(arcTolerance) === \"undefined\") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;\n  this.m_destPolys = new ClipperLib.Paths();\n  this.m_srcPoly = new ClipperLib.Path();\n  this.m_destPoly = new ClipperLib.Path();\n  this.m_normals = new Array();\n  this.m_delta = 0;\n  this.m_sinA = 0;\n  this.m_sin = 0;\n  this.m_cos = 0;\n  this.m_miterLim = 0;\n  this.m_StepsPerRad = 0;\n  this.m_lowest = new ClipperLib.FPoint0();\n  this.m_polyNodes = new ClipperLib.PolyNode();\n  this.MiterLimit = miterLimit;\n  this.ArcTolerance = arcTolerance;\n  this.m_lowest.x = -1;\n};\n\nClipperLib.ClipperOffset.two_pi = 6.28318530717959;\nClipperLib.ClipperOffset.def_arc_tolerance = 0.25;\nClipperLib.ClipperOffset.prototype.Clear = function() {\n  ClipperLib.Clear(this.m_polyNodes.Childs());\n  this.m_lowest.x = -1;\n};\n\nClipperLib.ClipperOffset.prototype.AddPath = function(path, joinType, endType) {\n  var highI = path.length - 1;\n  if (highI < 0)\n    return;\n  var newNode = new ClipperLib.PolyNode();\n  newNode.m_jointype = joinType;\n  newNode.m_endtype = endType;\n  //strip duplicate points from path and also get index to the lowest point ...\n  if (endType === ClipperLib.EndType.etClosedLine || endType === ClipperLib.EndType.etClosedPolygon)\n    while (highI > 0 && ClipperLib.FPoint.op_Equality(path[0], path[highI]))\n      highI--;\n  //newNode.m_polygon.set_Capacity(highI + 1);\n  newNode.m_polygon.push(path[0]);\n  var j = 0,\n    k = 0;\n  for (var i = 1; i <= highI; i++)\n    if (ClipperLib.FPoint.op_Inequality(newNode.m_polygon[j], path[i])) {\n      j++;\n      newNode.m_polygon.push(path[i]);\n      if (path[i].y > newNode.m_polygon[k].y || (path[i].y === newNode.m_polygon[k].y && path[i].x < newNode.m_polygon[k].x))\n        k = j;\n    }\n  if (endType === ClipperLib.EndType.etClosedPolygon && j < 2) return;\n\n  this.m_polyNodes.AddChild(newNode);\n  //if this path's lowest pt is lower than all the others then update m_lowest\n  if (endType !== ClipperLib.EndType.etClosedPolygon)\n    return;\n  if (this.m_lowest.x < 0)\n    this.m_lowest = new ClipperLib.FPoint2(this.m_polyNodes.ChildCount() - 1, k);\n  else {\n    var ip = this.m_polyNodes.Childs()[this.m_lowest.x].m_polygon[this.m_lowest.y];\n    if (newNode.m_polygon[k].y > ip.y || (newNode.m_polygon[k].y === ip.y && newNode.m_polygon[k].x < ip.x))\n      this.m_lowest = new ClipperLib.FPoint2(this.m_polyNodes.ChildCount() - 1, k);\n  }\n};\n\nClipperLib.ClipperOffset.prototype.AddPaths = function(paths, joinType, endType) {\n  for (var i = 0, ilen = paths.length; i < ilen; i++)\n    this.AddPath(paths[i], joinType, endType);\n};\n\nClipperLib.ClipperOffset.prototype.FixOrientations = function() {\n  //fixup orientations of all closed paths if the orientation of the\n  //closed path with the lowermost vertex is wrong ...\n  if (this.m_lowest.x >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.x].m_polygon)) {\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++) {\n      var node = this.m_polyNodes.Childs()[i];\n      if (node.m_endtype === ClipperLib.EndType.etClosedPolygon || (node.m_endtype === ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))\n        node.m_polygon.reverse();\n    }\n  } else {\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++) {\n      var node = this.m_polyNodes.Childs()[i];\n      if (node.m_endtype === ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))\n        node.m_polygon.reverse();\n    }\n  }\n};\n\nClipperLib.ClipperOffset.GetUnitNormal = function(pt1, pt2) {\n  var dx = (pt2.x - pt1.x);\n  var dy = (pt2.y - pt1.y);\n  if ((dx === 0) && (dy === 0))\n    return new ClipperLib.FPoint2(0, 0);\n  var f = 1 / Math.sqrt(dx * dx + dy * dy);\n  dx *= f;\n  dy *= f;\n  return new ClipperLib.FPoint2(dy, -dx);\n};\n\nClipperLib.ClipperOffset.prototype.DoOffset = function(delta) {\n  this.m_destPolys = new Array();\n  this.m_delta = delta;\n  //if Zero offset, just copy any CLOSED polygons to m_p and return ...\n  if (ClipperLib.ClipperBase.near_zero(delta)) {\n    //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++) {\n      var node = this.m_polyNodes.Childs()[i];\n      if (node.m_endtype === ClipperLib.EndType.etClosedPolygon)\n        this.m_destPolys.push(node.m_polygon);\n    }\n    return;\n  }\n  //see offset_triginometry3.svg in the documentation folder ...\n  if (this.MiterLimit > 2)\n    this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);\n  else\n    this.m_miterLim = 0.5;\n  var y;\n  if (this.ArcTolerance <= 0)\n    y = ClipperLib.ClipperOffset.def_arc_tolerance;\n  else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)\n    y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;\n  else\n    y = this.ArcTolerance;\n  //see offset_triginometry2.svg in the documentation folder ...\n  var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));\n  this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);\n  this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);\n  this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;\n  if (delta < 0)\n    this.m_sin = -this.m_sin;\n  //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);\n  for (var i = 0; i < this.m_polyNodes.ChildCount(); i++) {\n    var node = this.m_polyNodes.Childs()[i];\n    this.m_srcPoly = node.m_polygon;\n    var len = this.m_srcPoly.length;\n    if (len === 0 || (delta <= 0 && (len < 3 || node.m_endtype !== ClipperLib.EndType.etClosedPolygon)))\n      continue;\n    this.m_destPoly = new Array();\n    if (len === 1) {\n      if (node.m_jointype === ClipperLib.JoinType.jtRound) {\n        var X = 1,\n          Y = 0;\n        for (var j = 1; j <= steps; j++) {\n          this.m_destPoly.push(new ClipperLib.FPoint2(this.m_srcPoly[0].x + X * delta, this.m_srcPoly[0].y + Y * delta));\n          var X2 = X;\n          X = X * this.m_cos - this.m_sin * Y;\n          Y = X2 * this.m_sin + Y * this.m_cos;\n        }\n      } else {\n        var X = -1,\n          Y = -1;\n        for (var j = 0; j < 4; ++j) {\n          this.m_destPoly.push(new ClipperLib.FPoint2(this.m_srcPoly[0].x + X * delta, this.m_srcPoly[0].y + Y * delta));\n          if (X < 0)\n            X = 1;\n          else if (Y < 0)\n            Y = 1;\n          else\n            X = -1;\n        }\n      }\n      this.m_destPolys.push(this.m_destPoly);\n      continue;\n    }\n    //build m_normals ...\n    this.m_normals.length = 0;\n    //this.m_normals.set_Capacity(len);\n    for (var j = 0; j < len - 1; j++)\n      this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));\n    if (node.m_endtype === ClipperLib.EndType.etClosedLine || node.m_endtype === ClipperLib.EndType.etClosedPolygon)\n      this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));\n    else\n      this.m_normals.push(new ClipperLib.FPoint1(this.m_normals[len - 2]));\n    if (node.m_endtype === ClipperLib.EndType.etClosedPolygon) {\n      var k = len - 1;\n      for (var j = 0; j < len; j++)\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      this.m_destPolys.push(this.m_destPoly);\n    } else if (node.m_endtype === ClipperLib.EndType.etClosedLine) {\n      var k = len - 1;\n      for (var j = 0; j < len; j++)\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      this.m_destPolys.push(this.m_destPoly);\n      this.m_destPoly = new Array();\n      //re-build m_normals ...\n      var n = this.m_normals[len - 1];\n      for (var j = len - 1; j > 0; j--)\n        this.m_normals[j] = new ClipperLib.FPoint2(-this.m_normals[j - 1].x, -this.m_normals[j - 1].y);\n      this.m_normals[0] = new ClipperLib.FPoint2(-n.x, -n.y);\n      k = 0;\n      for (var j = len - 1; j >= 0; j--)\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      this.m_destPolys.push(this.m_destPoly);\n    } else {\n      var k = 0;\n      for (var j = 1; j < len - 1; ++j)\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      var pt1;\n      if (node.m_endtype === ClipperLib.EndType.etOpenButt) {\n        var j = len - 1;\n        pt1 = new ClipperLib.FPoint2(this.m_srcPoly[j].x + this.m_normals[j].x * delta, this.m_srcPoly[j].y + this.m_normals[j].y * delta);\n        this.m_destPoly.push(pt1);\n        pt1 = new ClipperLib.FPoint2(this.m_srcPoly[j].x - this.m_normals[j].x * delta, this.m_srcPoly[j].y - this.m_normals[j].y * delta);\n        this.m_destPoly.push(pt1);\n      } else {\n        var j = len - 1;\n        k = len - 2;\n        this.m_sinA = 0;\n        this.m_normals[j] = new ClipperLib.FPoint2(-this.m_normals[j].x, -this.m_normals[j].y);\n        if (node.m_endtype === ClipperLib.EndType.etOpenSquare)\n          this.DoSquare(j, k);\n        else\n          this.DoRound(j, k);\n      }\n      //re-build m_normals ...\n      for (var j = len - 1; j > 0; j--)\n        this.m_normals[j] = new ClipperLib.FPoint2(-this.m_normals[j - 1].x, -this.m_normals[j - 1].y);\n      this.m_normals[0] = new ClipperLib.FPoint2(-this.m_normals[1].x, -this.m_normals[1].y);\n      k = len - 1;\n      for (var j = k - 1; j > 0; --j)\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      if (node.m_endtype === ClipperLib.EndType.etOpenButt) {\n        pt1 = new ClipperLib.FPoint2(this.m_srcPoly[0].x - this.m_normals[0].x * delta, this.m_srcPoly[0].y - this.m_normals[0].y * delta);\n        this.m_destPoly.push(pt1);\n        pt1 = new ClipperLib.FPoint2(this.m_srcPoly[0].x + this.m_normals[0].x * delta, this.m_srcPoly[0].y + this.m_normals[0].y * delta);\n        this.m_destPoly.push(pt1);\n      } else {\n        k = 1;\n        this.m_sinA = 0;\n        if (node.m_endtype === ClipperLib.EndType.etOpenSquare)\n          this.DoSquare(0, 1);\n        else\n          this.DoRound(0, 1);\n      }\n      this.m_destPolys.push(this.m_destPoly);\n    }\n  }\n};\n\nClipperLib.ClipperOffset.prototype.Execute = function() {\n  var a = arguments,\n    ispolytree = a[0] instanceof ClipperLib.PolyTree;\n  if (!ispolytree) // function (solution, delta)\n  {\n    var solution = a[0],\n      delta = a[1];\n    ClipperLib.Clear(solution);\n    this.FixOrientations();\n    this.DoOffset(delta);\n    //now clean up 'corners' ...\n    var clpr = new ClipperLib.Clipper(0);\n    clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n    if (delta > 0) {\n      clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n    } else {\n      var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n      var outer = new ClipperLib.Path();\n      outer.push(new ClipperLib.FPoint2(r.left - 10, r.bottom + 10));\n      outer.push(new ClipperLib.FPoint2(r.right + 10, r.bottom + 10));\n      outer.push(new ClipperLib.FPoint2(r.right + 10, r.top - 10));\n      outer.push(new ClipperLib.FPoint2(r.left - 10, r.top - 10));\n      clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n      clpr.ReverseSolution = true;\n      clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n      if (solution.length > 0)\n        solution.splice(0, 1);\n    }\n    //console.log(JSON.stringify(solution));\n  } else // function (polytree, delta)\n  {\n    var solution = a[0],\n      delta = a[1];\n    solution.Clear();\n    this.FixOrientations();\n    this.DoOffset(delta);\n    //now clean up 'corners' ...\n    var clpr = new ClipperLib.Clipper(0);\n    clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n    if (delta > 0) {\n      clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n    } else {\n      var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n      var outer = new ClipperLib.Path();\n      outer.push(new ClipperLib.FPoint2(r.left - 10, r.bottom + 10));\n      outer.push(new ClipperLib.FPoint2(r.right + 10, r.bottom + 10));\n      outer.push(new ClipperLib.FPoint2(r.right + 10, r.top - 10));\n      outer.push(new ClipperLib.FPoint2(r.left - 10, r.top - 10));\n      clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n      clpr.ReverseSolution = true;\n      clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n      //remove the outer PolyNode rectangle ...\n      if (solution.ChildCount() === 1 && solution.Childs()[0].ChildCount() > 0) {\n        var outerNode = solution.Childs()[0];\n        //solution.Childs.set_Capacity(outerNode.ChildCount);\n        solution.Childs()[0] = outerNode.Childs()[0];\n        solution.Childs()[0].m_Parent = solution;\n        for (var i = 1; i < outerNode.ChildCount(); i++)\n          solution.AddChild(outerNode.Childs()[i]);\n      } else\n        solution.Clear();\n    }\n  }\n};\n\nClipperLib.ClipperOffset.prototype.OffsetPoint = function(j, k, jointype) {\n  //cross product ...\n  this.m_sinA = (this.m_normals[k].x * this.m_normals[j].y - this.m_normals[j].x * this.m_normals[k].y);\n\n  if (this.m_sinA === 0) {\n    return k;\n  }\n\n  /*\n    else if (this.m_sinA < 0.00005 && this.m_sinA > -0.00005)\n  {\n      console.log(this.m_sinA);\n      return k;\n  }\n  */\n  /*\n    if (Math.abs(this.m_sinA * this.m_delta) < 1.0)\n    {\n      //dot product ...\n      var cosA = (this.m_normals[k].x * this.m_normals[j].x + this.m_normals[j].y * this.m_normals[k].y);\n      if (cosA > 0) // angle ==> 0 degrees\n      {\n        this.m_destPoly.push(new ClipperLib.FPoint2(this.m_srcPoly[j].x + this.m_normals[k].x * this.m_delta,\n          this.m_srcPoly[j].y + this.m_normals[k].y * this.m_delta));\n        return k;\n      }\n      //else angle ==> 180 degrees\n    }\n  */\n  else if (this.m_sinA > 1)\n    this.m_sinA = 1.0;\n  else if (this.m_sinA < -1)\n    this.m_sinA = -1.0;\n  if (this.m_sinA * this.m_delta < 0) {\n    this.m_destPoly.push(new ClipperLib.FPoint2(this.m_srcPoly[j].x + this.m_normals[k].x * this.m_delta,\n      this.m_srcPoly[j].y + this.m_normals[k].y * this.m_delta));\n    this.m_destPoly.push(new ClipperLib.FPoint1(this.m_srcPoly[j]));\n    this.m_destPoly.push(new ClipperLib.FPoint2(this.m_srcPoly[j].x + this.m_normals[j].x * this.m_delta,\n      this.m_srcPoly[j].y + this.m_normals[j].y * this.m_delta));\n  } else\n    switch (jointype) {\n      case ClipperLib.JoinType.jtMiter: {\n        var r = 1 + (this.m_normals[j].x * this.m_normals[k].x + this.m_normals[j].y * this.m_normals[k].y);\n        if (r >= this.m_miterLim)\n          this.DoMiter(j, k, r);\n        else\n          this.DoSquare(j, k);\n        break;\n      }\n      case ClipperLib.JoinType.jtSquare:\n        this.DoSquare(j, k);\n        break;\n      case ClipperLib.JoinType.jtRound:\n        this.DoRound(j, k);\n        break;\n    }\n  k = j;\n  return k;\n};\n\nClipperLib.ClipperOffset.prototype.DoSquare = function(j, k) {\n  var dx = Math.tan(Math.atan2(this.m_sinA,\n    this.m_normals[k].x * this.m_normals[j].x + this.m_normals[k].y * this.m_normals[j].y) / 4);\n  this.m_destPoly.push(new ClipperLib.FPoint2(\n    this.m_srcPoly[j].x + this.m_delta * (this.m_normals[k].x - this.m_normals[k].y * dx),\n    this.m_srcPoly[j].y + this.m_delta * (this.m_normals[k].y + this.m_normals[k].x * dx)));\n  this.m_destPoly.push(new ClipperLib.FPoint2(\n    this.m_srcPoly[j].x + this.m_delta * (this.m_normals[j].x + this.m_normals[j].y * dx),\n    this.m_srcPoly[j].y + this.m_delta * (this.m_normals[j].y - this.m_normals[j].x * dx)));\n};\n\nClipperLib.ClipperOffset.prototype.DoMiter = function(j, k, r) {\n  var q = this.m_delta / r;\n  this.m_destPoly.push(new ClipperLib.FPoint2(\n    this.m_srcPoly[j].x + (this.m_normals[k].x + this.m_normals[j].x) * q,\n    this.m_srcPoly[j].y + (this.m_normals[k].y + this.m_normals[j].y) * q));\n};\n\nClipperLib.ClipperOffset.prototype.DoRound = function(j, k) {\n  var a = Math.atan2(this.m_sinA,\n    this.m_normals[k].x * this.m_normals[j].x + this.m_normals[k].y * this.m_normals[j].y);\n\n  var steps = Math.max(Math.round(this.m_StepsPerRad * Math.abs(a)), 1);\n\n  var X = this.m_normals[k].x,\n    Y = this.m_normals[k].y,\n    X2;\n  for (var i = 0; i < steps; ++i) {\n    this.m_destPoly.push(new ClipperLib.FPoint2(\n      this.m_srcPoly[j].x + X * this.m_delta,\n      this.m_srcPoly[j].y + Y * this.m_delta));\n    X2 = X;\n    X = X * this.m_cos - this.m_sin * Y;\n    Y = X2 * this.m_sin + Y * this.m_cos;\n  }\n  this.m_destPoly.push(new ClipperLib.FPoint2(\n    this.m_srcPoly[j].x + this.m_normals[j].x * this.m_delta,\n    this.m_srcPoly[j].y + this.m_normals[j].y * this.m_delta));\n};\n\nClipperLib.Error = function(message) {\n  try {\n    throw new Error(message);\n  } catch (err) {\n    alert(err.message);\n  }\n};\n\n// ---------------------------------------------\n\n// JS extension by Timo 2013\nClipperLib.JS = {};\n\nClipperLib.JS.AreaOfPolygon = function(poly) {\n  return ClipperLib.Clipper.Area(poly);\n};\n\nClipperLib.JS.AreaOfPolygons = function(poly) {\n  var area = 0;\n  for (var i = 0; i < poly.length; i++) {\n    area += ClipperLib.Clipper.Area(poly[i]);\n  }\n  return area;\n};\n\nClipperLib.JS.BoundsOfPath = function(path) {\n  return ClipperLib.JS.BoundsOfPaths([path]);\n};\n\nClipperLib.JS.BoundsOfPaths = function(paths) {\n  var bounds = ClipperLib.Clipper.GetBounds(paths);\n  return bounds;\n};\n\n// Clean() joins vertices that are too near each other\n// and causes distortion to offsetted polygons without cleaning\nClipperLib.JS.Clean = function(polygon, delta) {\n  if (!(polygon instanceof Array)) return [];\n  var isPolygons = polygon[0] instanceof Array;\n  var polygon = ClipperLib.JS.Clone(polygon);\n  if (typeof delta !== \"number\" || delta === null) {\n    ClipperLib.Error(\"Delta is not a number in Clean().\");\n    return polygon;\n  }\n  if (polygon.length === 0 || (polygon.length === 1 && polygon[0].length === 0) || delta < 0) return polygon;\n  if (!isPolygons) polygon = [polygon];\n  var k_length = polygon.length;\n  var len, poly, result, d, p, j, i;\n  var results = [];\n  for (var k = 0; k < k_length; k++) {\n    poly = polygon[k];\n    len = poly.length;\n    if (len === 0) continue;\n    else if (len < 3) {\n      result = poly;\n      results.push(result);\n      continue;\n    }\n    result = poly;\n    d = delta * delta;\n    //d = Math.floor(c_delta * c_delta);\n    p = poly[0];\n    j = 1;\n    for (i = 1; i < len; i++) {\n      if ((poly[i].x - p.x) * (poly[i].x - p.x) +\n        (poly[i].y - p.y) * (poly[i].y - p.y) <= d)\n        continue;\n      result[j] = poly[i];\n      p = poly[i];\n      j++;\n    }\n    p = poly[j - 1];\n    if ((poly[0].x - p.x) * (poly[0].x - p.x) +\n      (poly[0].y - p.y) * (poly[0].y - p.y) <= d)\n      j--;\n    if (j < len)\n      result.splice(j, len - j);\n    if (result.length) results.push(result);\n  }\n  if (!isPolygons && results.length) results = results[0];\n  else if (!isPolygons && results.length === 0) results = [];\n  else if (isPolygons && results.length === 0) results = [\n    []\n  ];\n  return results;\n}\n// Make deep copy of Polygons or Polygon\n// so that also FPoint objects are cloned and not only referenced\n// This should be the fastest way\nClipperLib.JS.Clone = function(polygon) {\n  if (!(polygon instanceof Array)) return [];\n  if (polygon.length === 0) return [];\n  else if (polygon.length === 1 && polygon[0].length === 0) return [\n    []\n  ];\n  var isPolygons = polygon[0] instanceof Array;\n  if (!isPolygons) polygon = [polygon];\n  var len = polygon.length,\n    plen, i, j, result;\n  var results = new Array(len);\n  for (i = 0; i < len; i++) {\n    plen = polygon[i].length;\n    result = new Array(plen);\n    for (j = 0; j < plen; j++) {\n      result[j] = {\n        X: polygon[i][j].x,\n        Y: polygon[i][j].y\n      };\n\n    }\n    results[i] = result;\n  }\n  if (!isPolygons) results = results[0];\n  return results;\n};\n\n// Removes points that doesn't affect much to the visual appearance.\n// If middle point is at or under certain distance (tolerance) of the line segment between\n// start and end point, the middle point is removed.\nClipperLib.JS.Lighten = function(polygon, tolerance) {\n  if (!(polygon instanceof Array)) return [];\n  if (typeof tolerance !== \"number\" || tolerance === null) {\n    ClipperLib.Error(\"Tolerance is not a number in Lighten().\")\n    return ClipperLib.JS.Clone(polygon);\n  }\n  if (polygon.length === 0 || (polygon.length === 1 && polygon[0].length === 0) || tolerance < 0) {\n    return ClipperLib.JS.Clone(polygon);\n  }\n  var isPolygons = polygon[0] instanceof Array;\n  if (!isPolygons) polygon = [polygon];\n  var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;\n  var bxax, byay, l, ax, ay;\n  var len = polygon.length;\n  var toleranceSq = tolerance * tolerance;\n  var results = [];\n  for (i = 0; i < len; i++) {\n    poly = polygon[i];\n    plen = poly.length;\n    if (plen === 0) continue;\n    for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count\n    {\n      poly2 = [];\n      plen = poly.length;\n      // the first have to added to the end, if first and last are not the same\n      // this way we ensure that also the actual last point can be removed if needed\n      if (poly[plen - 1].x !== poly[0].x || poly[plen - 1].y !== poly[0].y) {\n        addlast = 1;\n        poly.push({\n          X: poly[0].x,\n          Y: poly[0].y\n        });\n        plen = poly.length;\n      } else addlast = 0;\n      rem = []; // Indexes of removed points\n      for (j = 0; j < plen - 2; j++) {\n        A = poly[j]; // Start point of line segment\n        P = poly[j + 1]; // Middle point. This is the one to be removed.\n        B = poly[j + 2]; // End point of line segment\n        ax = A.x;\n        ay = A.y;\n        bxax = B.x - ax;\n        byay = B.y - ay;\n        if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.\n        {\n          l = ((P.x - ax) * bxax + (P.y - ay) * byay) / (bxax * bxax + byay * byay);\n          if (l > 1) {\n            ax = B.x;\n            ay = B.y;\n          } else if (l > 0) {\n            ax += bxax * l;\n            ay += byay * l;\n          }\n        }\n        bxax = P.x - ax;\n        byay = P.y - ay;\n        d = bxax * bxax + byay * byay;\n        if (d <= toleranceSq) {\n          rem[j + 1] = 1;\n          j++; // when removed, transfer the pointer to the next one\n        }\n      }\n      // add all unremoved points to poly2\n      poly2.push({\n        X: poly[0].x,\n        Y: poly[0].y\n      });\n      for (j = 1; j < plen - 1; j++)\n        if (!rem[j]) poly2.push({\n          X: poly[j].x,\n          Y: poly[j].y\n        });\n      poly2.push({\n        X: poly[plen - 1].x,\n        Y: poly[plen - 1].y\n      });\n      // if the first point was added to the end, remove it\n      if (addlast) poly.pop();\n      // break, if there was not anymore removed points\n      if (!rem.length) break;\n      // else continue looping using poly2, to check if there are points to remove\n      else poly = poly2;\n    }\n    plen = poly2.length;\n    // remove duplicate from end, if needed\n    if (poly2[plen - 1].x === poly2[0].x && poly2[plen - 1].y === poly2[0].y) {\n      poly2.pop();\n    }\n    if (poly2.length > 2) // to avoid two-point-polygons\n      results.push(poly2);\n  }\n  if (!isPolygons) {\n    results = results[0];\n  }\n  if (typeof(results) === \"undefined\") {\n    results = [];\n  }\n  return results;\n}\n\nClipperLib.JS.PerimeterOfPath = function(path, closed) {\n  if (typeof(path) === \"undefined\") return 0;\n  var sqrt = Math.sqrt;\n  var perimeter = 0.0;\n  var p1, p2, p1x = 0.0,\n    p1y = 0.0,\n    p2x = 0.0,\n    p2y = 0.0;\n  var j = path.length;\n  if (j < 2) return 0;\n  if (closed) {\n    path[j] = path[0];\n    j++;\n  }\n  while (--j) {\n    p1 = path[j];\n    p1x = p1.x;\n    p1y = p1.y;\n    p2 = path[j - 1];\n    p2x = p2.x;\n    p2y = p2.y;\n    perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));\n  }\n  if (closed) path.pop();\n  return perimeter;\n};\n\nClipperLib.JS.PerimeterOfPaths = function(paths, closed) {\n  var perimeter = 0;\n  for (var i = 0; i < paths.length; i++) {\n    perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed);\n  }\n  return perimeter;\n};\n\n/**\n * @constructor\n */\nClipperLib.ExPolygons = function() {\n  return [];\n}\n/**\n * @constructor\n */\nClipperLib.ExPolygon = function() {\n  this.outer = null;\n  this.holes = null;\n};\n\nClipperLib.JS.AddOuterPolyNodeToExPolygons = function(polynode, expolygons) {\n  var ep = new ClipperLib.ExPolygon();\n  ep.outer = polynode.Contour();\n  var childs = polynode.Childs();\n  var ilen = childs.length;\n  ep.holes = new Array(ilen);\n  var node, n, i, j, childs2, jlen;\n  for (i = 0; i < ilen; i++) {\n    node = childs[i];\n    ep.holes[i] = node.Contour();\n    //Add outer polygons contained by (nested within) holes ...\n    for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++) {\n      n = childs2[j];\n      ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);\n    }\n  }\n  expolygons.push(ep);\n};\n\nClipperLib.JS.PolyTreeToExPolygons = function(polytree) {\n  var expolygons = new ClipperLib.ExPolygons();\n  var node, i, childs, ilen;\n  for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++) {\n    node = childs[i];\n    ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);\n  }\n  return expolygons;\n};\n\nmodule.exports = ClipperLib;\n"],"names":["ClipperLib","version","Inherit","ce","ce2","p","Object","getOwnPropertyNames","prototype","$baseCtor","props","i","length","getOwnPropertyDescriptor","defineProperty","Path","push","Array","Paths","PolyNode","this","m_Parent","m_polygon","m_Index","m_jointype","m_endtype","m_Childs","IsOpen","IsHoleNode","result","node","ChildCount","Contour","AddChild","Child","cnt","GetNext","GetNextSiblingUp","Childs","Parent","IsHole","PolyTree","m_AllPolys","call","Clear","ilen","GetFirst","Total","a","PI","PI2","FPoint","arguments","alen","x","y","dp","pt","op_Equality","b","op_Inequality","FPoint0","FPoint1","FPoint1dp","FPoint2","z","FRect","left","top","right","bottom","ir","FRect0","FRect1","FRect4","l","t","r","ClipType","ctIntersection","ctUnion","ctDifference","ctXor","PolyType","ptSubject","ptClip","PolyFillType","pftEvenOdd","pftNonZero","pftPositive","pftNegative","JoinType","jtSquare","jtRound","jtMiter","EndType","etOpenSquare","etOpenRound","etOpenButt","etClosedLine","etClosedPolygon","EdgeSide","esLeft","esRight","Direction","dRightToLeft","dLeftToRight","TEdge","Bot","Curr","Top","Delta","Dx","PolyTyp","Side","WindDelta","WindCnt","WindCnt2","OutIdx","Next","Prev","NextInLML","NextInAEL","PrevInAEL","NextInSEL","PrevInSEL","IntersectNode","Edge1","Edge2","Pt","MyIntersectNodeSort","Compare","node1","node2","LocalMinima","LeftBound","RightBound","Scanbeam","Maxima","OutRec","Idx","FirstLeft","Pts","BottomPt","OutPt","Join","OutPt1","OutPt2","OffPt","ClipperBase","m_MinimaList","m_CurrentLM","m_edges","m_HasOpenPaths","PreserveCollinear","m_Scanbeam","m_PolyOuts","m_ActiveEdges","horizontal","Skip","Unassigned","tolerance","maxValue","Math","sqrt","Number","MAX_VALUE","minValue","MIN_VALUE","near_zero","val","IsHorizontal","e","PointIsVertex","pp","pp2","PointOnLineSegment","linePt1","linePt2","PointOnPolygon","SlopesEqual","e1","e2","pt1","pt2","pt3","pt4","SlopesEqual3","SlopesEqual4","SlopesEqual5","DisposeLocalMinimaList","j","jlen","tmpLm","RangeTest","Error","InitEdge","eNext","ePrev","InitEdge2","polyType","SetDx","FindNextLocMin","E","E2","ProcessBound","LeftBoundIsForward","EStart","Horz","Result","locMin","InsertLocalMinima","ReverseHorizontal","AddPath","pg","Closed","highI","edges","IsFlat","leftBoundIsForward","eStart","eLoopStop","Pt2IsBetweenPt1AndPt3","RemoveEdge","EMin","AddPaths","ppg","closed","newLm","PopLocalMinima","Y","current","v","tmp","Reset","lm","InsertScanbeam","newSb","sb2","newSb1","PopScanbeam","LocalMinimaPending","CreateOutRec","DisposeOutRec","index","outRec","UpdateEdgeIntoAEL","AelPrev","AelNext","SwapPositionsInAEL","edge1","edge2","next","prev","next1","prev1","next2","prev2","DeleteFromAEL","Clipper","InitOptions","m_ClipType","m_Maxima","m_SortedEdges","m_IntersectList","m_IntersectNodeComparer","m_ExecuteLocked","m_ClipFillType","m_SubjFillType","m_Joins","m_GhostJoins","m_UsingPolyTree","ReverseSolution","StrictlySimple","ioReverseSolution","ioStrictlySimple","ioPreserveCollinear","DisposeAllPolyPts","InsertMaxima","X","newMax","m","Execute","ispolytree","clipType","solution","subjFillType","clipFillType","succeeded","ExecuteInternal","BuildResult","polytree","BuildResult2","FixHoleLinkage","orfl","botY","topY","InsertLocalMinimaIntoAEL","ProcessHorizontals","ProcessIntersections","ProcessEdgesAtTopOfScanbeam","Area$1","ReversePolyPtLinks","JoinCommonEdges","FixupOutPolyline","FixupOutPolygon","DoSimplePolygons","AddJoin","Op1","Op2","AddGhostJoin","Op","lb","rb","InsertEdgeIntoAEL","SetWindingCount","IsContributing","AddOutPt","AddLocalMinPoly","AddEdgeToSEL","HorzSegmentsOverlap","IntersectEdges","edge","startEdge","E2InsertsBeforeE1","TopX","IsEvenOddFillType","IsEvenOddAltFillType","pft","pft2","abs","Inside","PopEdgeFromSEL","oldE","CopyAELToSEL","SwapPositionsInSEL","AddLocalMaxPoly","AppendPolygon","prevE","xPrev","xE","outPt","newOp","SetHoleState","op","ToFront","GetLastOutPt","SwapPoints","Value","seg1a","seg1b","seg2a","seg2b","eTmp","GetDx","FirstIsBottomPt","btmPt1","btmPt2","dx1p","dx1n","dx2p","dx2n","max","min","Area","GetBottomPt","dups","GetLowermostRec","outRec1","outRec2","bPt1","bPt2","OutRec1RightOfOutRec2","GetOutRec","idx","outrec","holeStateRec","p1_lft","p1_rt","p2_lft","p2_rt","OKIdx","ObsoleteIdx","pp1","SwapSides","side","SwapPolyIndexes","outIdx","e1FillType","e2FillType","e1FillType2","e2FillType2","e1Wc","e2Wc","e1Contributing","e2Contributing","oldE1WindCnt","e1Wc2","e2Wc2","DeleteFromSEL","SelPrev","SelNext","horzEdge","ProcessHorizontal","GetHorzDirection","HorzEdge","$var","Left","Right","Dir","dir","horzLeft","horzRight","eLastHorz","eMaxPair","GetMaximaPair","currMax","op1","IsLastHorz","GetNextInAEL","eNextHorz","op2","IsMinima","IsMaxima","IsIntermediate","GetMaximaPairEx","BuildIntersectList","FixupIntersectionOrder","ProcessIntersectList","$$e2","isModified","IntersectPoint","newNode","EdgesAdjacent","inode","IntersectNodeSort","sort","iNode","currentY","ip","b1","b2","q","IsMaximaEdge","DoMaxima","ePrev2","ReversePaths","polys","len","reverse","Orientation","poly","PointCount","pts","polyg","pn","lastPP","tmpPP","lastOK","preserveCol","DupOutPt","InsertAfter","GetOverlap","a1","a2","$val","JoinHorz","op1b","op2b","DiscardLeft","Dir1","Dir2","JoinPoints","isHorizontal","reverse1","DiscardLeftSide","Reverse1","Reverse2","GetBounds","paths","GetBounds2","ops","opStart","PointInPolygon","path","ipNext","d","startOp","ptx","pty","poly0x","poly0y","poly1x","poly1y","Poly2ContainsPoly1","outPt1","outPt2","res","FixupFirstLefts1","OldOutRec","NewOutRec","firstLeft","ParseFirstLeft","FixupFirstLefts2","innerOutRec","outerOutRec","FixupFirstLefts3","join","UpdateOutPtIdxs","op3","op4","outrec2","isArray","opFirst","SimplifyPolygon","fillType","c","SimplifyPolygons","DistanceSqrd","dx","dy","DistanceFromLineSqrd","ln1","ln2","A","B","C","SlopesNearCollinear","distSqrd","PointsAreClose","ExcludeOp","CleanPolygon","distance","outPts","CleanPolygons","Minkowski","pattern","IsSum","IsClosed","delta","polyCnt","pathCnt","quads","quad","MinkowskiSum","path_or_paths","pathIsClosed","TranslatePath","outPath","MinkowskiDiff","poly1","poly2","PolyTreeToPaths","AddPolyNodeToPaths","NodeType","ntAny","polynode","nt","match","ntOpen","ntClosed","$i3","$t3","$l3","OpenPathsFromPolyTree","ClosedPathsFromPolyTree","ClipperOffset","miterLimit","arcTolerance","def_arc_tolerance","m_destPolys","m_srcPoly","m_destPoly","m_normals","m_delta","m_sinA","m_sin","m_cos","m_miterLim","m_StepsPerRad","m_lowest","m_polyNodes","MiterLimit","ArcTolerance","two_pi","joinType","endType","k","FixOrientations","GetUnitNormal","f","DoOffset","steps","acos","sin","cos","OffsetPoint","n","DoSquare","DoRound","X2","clpr","outer","outerNode","splice","jointype","DoMiter","tan","atan2","round","message","err","alert","JS","AreaOfPolygon","AreaOfPolygons","area","BoundsOfPath","BoundsOfPaths","Clean","polygon","isPolygons","Clone","k_length","results","plen","Lighten","P","rem","addlast","bxax","byay","ax","ay","toleranceSq","pop","PerimeterOfPath","p1","p2","perimeter","p1x","p1y","p2x","p2y","PerimeterOfPaths","ExPolygons","ExPolygon","holes","AddOuterPolyNodeToExPolygons","expolygons","ep","childs2","childs","PolyTreeToExPolygons","module","exports"],"mappings":"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"}